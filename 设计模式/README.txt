HEAD FISRST 设计模式的读书笔记
前言：
	使用设计模式是为了让代码更易于理解，便于维护等。
	而不是为了使用设计模式而使用设计模式，搞太难于理解的东西。

设计模式：
	介绍：
		设计模式即构建面向对象系统经验的总结和复用。
			研究方式之一：找出代码中变的与不变的部分，然后研究如何构建变的代码。
		设计模式告诉我们如何组织类和对象以解决某种问题。
	设计模式作用：
		设计模式可以帮助我们将应用组织成容易了解，容易维护，具有弹性的架构。
	使用模式的最好方式：
		把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们。
	附：
		改进时找不到符合的设计模式：p31	
附：
	库,框架，架构：
		库：一系列相关代码包的集合。
		框架：
			一系列代码的整合，提供给我们某种特定的实现。
			代码中我们可以轻易的引用框架，并符合框架的使用规则，我们就可以轻松的实现某种功能。
		架构：
			为应用搭建一个骨架，然后后续只需填充这个骨架即可实现该应用。
	软件开发：
		软件开发的不变真理：
			不管当初软件设计的多好，一段时间之后，总会需要成长与改变，否则软件就会死亡。
			即：
				软件设计时就要考虑到后续的维护和二次开发等。
				所以我们应该致力于提高可维护性和可扩展性上的复用程度。
		附：
			软件设计步骤：
				1.明确需求
				2.设计时尽量填上你能想到的坑或bug
				3.考虑下代码的逻辑是否理解，清晰
				4.考虑下代码是否容易维护，具有弹性的架构
					通常系统的维护和变化上，比原先开发花的时间更多。
				5.
					...
OO(面向对象)基本特征：
	抽象
		先不考虑细节
			即由子类来实现方法
	封装
		隐藏内部实现
			即通过访问修饰符来将类的方法和数据隐藏起来。
	继承
		复用现有代码
	多态 （改写对象行为）
		https://www.runoob.com/java/java-polymorphism.html
		多态是同一个行为具有多个不同表现形式或形态的能力。
		多态存在的三个必要条件：
			继承
			重写
			父类引用指向子类对象
oo(面向对象)设计原则：
	1.封装变化：p9
		找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。
		好处：
			把会变化的部分封装起来，以便以后可以轻易的改动或扩充此部分，而不影响不需要变化的其他部分。
	2.针对接口编程，而不是针对实现编程。p11
		这样子会是设计更有弹性。
		如：
			类中有一个接口属性。
		好处：
			针对接口编程，可以隔离以后系统发生的一大堆改变。
			因为代码如果针对接口写的，那么通过多态，它可以让任何新类实现该接口。
	3.多用组合少用继承。p23
		将两个类结合起来使用就是组合。
		例:
			鸭子接口有两个组合属性FlyBehavior和QuackBehavior，
			具体鸭子类在实现时只需将飞行和叫行为委托给它们代为处理。
		好处：
			前言：
				软件在开发完成前与后，后者会花费更多时间。
				因为系统是要维护和变化的，这方面花费的时间会很多。
				所以我们应该提高代码的可维护性和可扩展性上。
			而继承仅是对代码的复用高，其可扩展性不如组合，使用组合不仅可以达到服用更可以在运行时动态的改变行为，后续的维护与扩展也更方便。
	4.开放-关闭原则：p86
		类应该对扩展开放，对修改关闭。
		即：
			即允许类容易扩展，能在不修改现有代码的情况下，就可扩展新的行为。
		例：
			装饰者模式，观察者模式中的组合。
		附：
			什么时候应用该原则：
				遵循开放关闭原则，通常会引入新的抽象层次，增加代码的复杂度。
				你应该把注意力集中在设计中最有可能改变的地方，然后应用开放关闭原则。
	5.为交互对象之间的松耦合设计而努力：p53
		松耦合：
			耦合指，两个对象之间的依赖程度。
			松耦合指，两个对象之间的依赖程度较低。
				即两对象之间依然可以进行交互，但是无需清楚彼此的细节。
			观察者模式中的松耦合：
				主题只知道观察者实现了某个接口（Observer），无需知道观察者的具体实现类，和实现类的细节。
				改变出版者或观察者任意一方，并不会影响另一方，只要它们之间的接口任被遵守即可。
				这就是观察者模式的松耦合。
				
	6.依赖倒置原则p139：依赖抽象，不要依赖具体类
		说明：
			这个原则听起来很像是"针对接口编程,不针对实现编程"。
			但这个原则更强调抽象，不管高层或低层组件,"两者"都应该依赖于抽象类,而不依赖具体类。

			依赖倒置原则,究竟倒置在哪里：
				依赖倒置原则中的倒置指的是和一般OO设计的思考方式完全相反。
				低层组件依赖一个抽象（算高层的）。
				同样地,高层组件现在也依赖相同的抽象。
				通常依赖图是由上而下的,现在却倒置了,而且高层与低层模块现在都依赖这个抽象。
			例：
				p140
		如何避免在OO设计中违反依赖倒置原则:
			1.变量不可以持有具体类的引用。
				如果使用new就会持有具体类的引用，你可以使用工厂来避开这样的作法。
			2.不要让类派生自具体类。
				如果派生自具体类,你就会依赖具体类。请派生自一个抽象（接口或抽象类）。
			3.不要覆盖基类中已实现的方法。
				如果覆盖基类已实现的方法．那么你的基类就不是一个真正适合被继承的抽象。 基类中已实现的方法,应该由所有的子类共享。
	7.最少知识原则p265：只和朋友谈
	说明：
		设计一个类时,你都要注意它所交互的类有哪些。
		降低类之间的耦合,避免得修改系统中一部分,会影响到其他部分。
		
		降低耦合的方式：
			在对象的方法内,我们只应该调用属于以下范围的方法：
			1.该对象本身
			2.当做方法的参数而传递进来的对象
			3.此方法所创建或实例化的任何对象
			4.对象的任何组件。（该对象实例变量所引用的对象）
			注：
				避免调用从另一个调用中返回的对象的方法。
	8.好莱坞原则p296:别调用（打电话给）我们，我们会调用（打电话给）你。
	说明：	
		我们允许低层组件将自己挂钩到系统上,但是高层组件会决定什么时候和怎样使用这些低层组件。
		例：
			模板方法中应用好莱坞原则：
				CaffeineBevevase是高层组件，它控制冲泡的算法。
				且在冲泡算法中定义了一个钩子，如果用户想要调料则调用abstract addCondiment()。
		
	附：
		1.工厂模式，观察者，模板方法均使用了好莱坞原则。
		2.好莱坞原则可以防止依赖腐败，因为根据好莱坞原则，我们允许低层组件将自己挂钩到系统上，然后高层组件会决定什么是否调用低层组件，这样子就会让系统的调用关系很清晰，避免了依赖腐败。
		附：
		依赖腐败：
			当高层组件依赖低层组件,而低层组件又依赖高层组件,而高层组件又依赖边侧组件,而边侧组件又依赖低层组件时,依赖腐败就发生了。
			在这种情况下,没有人可以轻易地搞懂系统是如何设计的。
	9.单一责任p339：一个类应该只有一个引起变化的原因。
		说明：
			当我们允许一个类不但要完成自己的事情（如管理某种聚合），同时还要负担跟多的责任（如遍历），
			那么当1.集合改变时，这个类要改变。2.遍历方式改变，这个类也得改变。
			hcg：
				一个类只承担一个类型的功能。
		附：
			内聚：用来度量一个类或模块紧密达到单一目的或责任的程度。
			高内聚：当一个模块或一个类被设计成只支持一组相关的功能时,我们说它具有高内聚。
	注：
		一个程序不可能遵守所有的原则或指导方针,
		应该尽量达到这个原则,而不是随时都要遵循这个原则。
		我们都很清楚,任何Java程序都有违反这些原则的地方。		

		