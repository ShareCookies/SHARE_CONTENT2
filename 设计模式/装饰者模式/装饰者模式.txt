装饰者模式介绍：
	动态地将责任附加到对象上。
	即：
		装饰技巧能够在不修改任何底层代码的情况下，给你的（或别人的）对象赋予新的职责。
功能：
	装饰者可以在被装饰者的行为前面或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。
缺陷：
	装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。
javaI/O的装饰者模式介绍：p100
	
注：
	装饰者模式，应针对抽象组件类型编程。

知识点扩展：
	用继承处理一切是错误的思路，运行时扩展，远比编译时期的继承威力大。
	复用的实现：
		1.通过继承来达到代码的复用。（编译时决定的属于静态）
		2.利用组合和委托可以在运行时具有继承行为的效果。（运行时决定的属于动态扩展）
		
		？：
			动态和静态的概念：
				不是都是通过写代码来实现的行为吗？
				
				