https://blog.csdn.net/jackfrued/article/details/44921941
1、面向对象特征：
	抽象
		先不考虑细节
			抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。
			抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。
	封装
		隐藏内部实现
			通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。
			我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。
			可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。
	继承
		复用现有代码
			继承是从已有类得到继承信息创建新类的过程。
			提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。
			继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。
	多态 （改写对象行为）
		https://www.runoob.com/java/java-polymorphism.html
		多态是同一个行为具有多个不同表现形式的能力。
		多态存在的三个必要条件：
			继承
			重写
			父类引用指向子类对象
2、访问修饰符
	public,private,protected,default(不写package)
	default：默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。
	protected（受保护）：对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。
	附：
		类修饰符：Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。
3、float f=3.4;是否正确？
	不正确。
	3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，
	因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。
	浮点型强转转换会造成精度丢失吗：
		会的，当然float能表示的数据 转换成float，并没有丢失。
4、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？
	答：
	对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。
	而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。
6、Java有没有goto：
	答：goto和const 是Java中的保留字，在目前版本的Java中没有使用。
7、int和Integer有什么区别
	基本数据类型和引用类型。自动装箱/拆箱机制，使得二者可以相互转换。
	public static void main(String[] args) {
        Integer a = new Integer(3);
        Integer b = 3;                  // 将3自动装箱成Integer类型
        int c = 3;
        System.out.println(a == b);     // false 两个引用没有引用同一对象
        System.out.println(a == c);     // true a自动拆箱成int类型再和c比较
    }
8、&和&&的区别
	https://www.cnblogs.com/shuaiding/p/11124974.html
	System.err.println(129 & 128);128 与运算符	
		二进制进行与运算，同0异1
	A&&B 逻辑运算符
9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。（JVM）
	栈空间:基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间?；
	堆:而通过new关键字和构造器创建?的对象则放在堆空间.
		堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代...
	方法区:用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；
		程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在常量池中，常量池是方法区的一部分，。
	例：
		String str = new String("hello");
		上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区的。
	附：
		1.方法区和堆都是各个线程共享的内存区域.
		2.栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间.
		3.栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。
	附：
		补充1：较新版本的Java（从Java 6的某个更新开始）中，由于JIT编译器的发展和"逃逸分析"技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。
		补充2：运行时常量池相当于Class文件，常量池具有动态性，Java语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String类的intern()方法就是这样的。
10：...
11、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上
	答：在Java 5以前，switch(expr)中，expr只能是byte、short、int、char。
	从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。
12、用最有效率的方法计算2乘以8？
13、数组有没有length()方法.String有没有length()方法.
	答：数组没有length()方法，有length 的属性。String 有length()方法。
14、在Java中，如何跳出当前的多重嵌套循环。
	答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）
15、构造器（constructor）是否可被重写（override）。
	答：构造器不能被继承，因此不能被重写，但可以被重载。
	附：
		构造器重载意义：
			提供多种初始化实例的方法。
			根据不同的需求使用不同的参数创建对象
*16、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？
	答：
		不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。
		Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。
		当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。
		即：
			如何判断两对象相同：hashcode同，则在判断equals是否同，同才同。
	附：
		...
18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？
17、是否可以继承String类。
	答：String 类是final类，不可以被继承。
19、String和StringBuilder、StringBuffer的区别？
	答：Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。
	其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。
	而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。
	面试题1 - 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？
	面试题2 - 请说出下面程序的输出。
	...
	https://www.runoob.com/java/java-string-intern.html
20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分。
	答：
	重载：重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；
		重载对返回类型没有特殊的要求。
	重写：重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。
	
	面试题：华为的面试题中曾经问过这样一个问题 - "为什么不能根据返回类型来区分重载"，快说出你的答案吧！
！21、描述一下JVM加载class文件的原理机制：
	答：
	由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。
	当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。
		类的加载:
			类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。
			
			类加载器：
				Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。
				类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。
				父委托机制（PDM）：
					从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM），PDM更好的保证了Java平台的安全性。
					在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。
					类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。
				关于几个类加载器说明：
					Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
					Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
					System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。
		类的连接:		
			加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。
		类的初始化:
			最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。
22、char 型变量中能不能存贮一个中文汉字，为什么。
	答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。
	补充：
		使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。
		所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。
		？
			Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法?）?
			Unicode?
				https://baike.baidu.com/item/Unicode/750500?fr=aladdin
			Unicode 和 UTF-8 之间的关系?
				https://www.cnblogs.com/tsingke/p/10853936.html
23、抽象类（abstract class）和接口（interface）有什么异同。
	答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。
		1.均不能够实例化
		2.都要对抽象方法进行实现
		
		1.抽象类单继承，接口多实现
		2.抽象类成员修饰符更多样化，接口中定义的成员变量实际上都是常量
		3.抽象类中可以定义构造器，可以有抽象方法和具体方法
24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同。
	答：Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。
		而通常的内部类需要在外部类实例化后才能实例化。
25、Java 中会存在内存泄漏吗，请简单描述。
	答：
		理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；
		*然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。
		例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。
	例	
		下面例子中的代码也会导致内存泄露。
		import java.util.Arrays;
		import java.util.EmptyStackException;
		public class MyStack<T> {
			private T[] elements;
			private int size = 0;
			private static final int INIT_CAPACITY = 16;
			public MyStack() {
				elements = (T[]) new Object[INIT_CAPACITY];
			}
			public void push(T elem) {
				ensureCapacity();
				elements[size++] = elem;
			}
			public T pop() {
				if(size == 0) 
					throw new EmptyStackException();
				return elements[--size];
			}
			private void ensureCapacity() {
				if(elements.length == size) {
					elements = Arrays.copyOf(elements, 2 * size + 1);
				}
			}
		}
		上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。
		然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。
		在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。
		
		为什么会引起内存泄漏了：
			https://www.cnblogs.com/kissazi2/p/3618464.html
			因为数组其实还是引用着对象，要把对应的位置赋为null数组才没有引用对象，
			不然你只能期望等这整个栈失去引用（将被GC回收时），栈内的elements数组一起被GC回收。
			这种问题很隐蔽，通常只要类自己管理内存（如类中有一个Array或List型的结构），那么我们就应该警惕内存泄露的问题。
26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？
	答：都不能。
	抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。
	本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。
	synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。
		3.synchronized关键字不属于方法特征签名组成部分，所以可以在覆盖方法的时候加上去。所以无法被继承
27、阐述静态变量和实例变量的区别。
	静态变量存在于方法区。它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；
	实例变量存在于栈空间。它属于实例对象，需要先创建对象然后通过对象才能访问到它。
28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？
	答：
	不可以，静态方法只能访问静态成员。
	除非创建对像，然后通过对象类调用非静态方法。
29、如何实现对象克隆？
	答：有两种方式：
	  1). 实现Cloneable接口并重写Object类中的clone()方法；
	  2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。
30、GC是什么.为什么要有GC.
	答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。
	垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。
	补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：
	- 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。
	- 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。
	- 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。
	与垃圾回收相关的JVM参数：
	-Xms / -Xmx — 堆的初始大小 / 堆的最大大小
	-Xmn — 堆中年轻代的大小
	-XX:-DisableExplicitGC — 让System.gc()不产生任何作用
	-XX:+PrintGCDetails — 打印GC的细节
	-XX:+PrintGCDateStamps — 打印GC操作的时间戳
	-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小
	-XX:NewRatio — 可以设置老生代和新生代的比例
	-XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布
	-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值
	-XX:TargetSurvivorRatio：设置幸存区的目标使用率
31、String s = new String("xyz");创建了几个字符串对象？
	答：两个对象，一个是静态区的"xyz"，一个是用new创建在堆上的对象。
32、接口是否可继承（extends）接口.抽象类是否可实现（implements）接口.抽象类是否可继承具体类（concrete class）.
	答：接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。
33、一个".java"源文件中是否可以包含多个类（不是内部类）。有什么限制。
	答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。
34、Anonymous Inner Class(匿名内部类)是否可以继承其它类.是否可以实现接口.
	答：可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。
35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制.
	答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。
36、Java 中的final关键字有哪些用法.
	答：(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。
37、指出下面程序的运行结果。
	class A {
		static {
			System.out.print("1");
		}
		public A() {
			System.out.print("2");
		}
	}
	class B extends A{
		static {
			System.out.print("a");
		}
		public B() {
			System.out.print("b");
		}
	}
	public class Hello {
		public static void main(String[] args) {
			A ab = new B();
			ab = new B();
		}
	}
	答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。
	提示：如果不能给出此题的正确答案，说明之前第21题Java类加载机制还没有完全理解，赶紧再看看吧
38、数据类型之间的转换：
	- 如何将字符串转换为基本数据类型？
	- 如何将基本数据类型转换为字符串？
	答：
	- 调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；
	- 一种方法是将基本数据类型与空字符串（""）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串

39、如何实现字符串的反转及替换？
答：方法很多，可以自己写实现也可以使用String或StringBuffer/StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：

    public static String reverse(String originStr) {
        if(originStr == null || originStr.length() <= 1) 
            return originStr;
        return reverse(originStr.substring(1)) + originStr.charAt(0);
    }
40、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串
	答：代码如下所示：

	String s1 = "你好";
	String s2 = new String(s1.getBytes("GB2312"), "ISO-8859-1");
41、日期和时间：
	- 如何取得年月日、小时分钟秒？
	- 如何取得从1970年1月1日0时0分0秒到现在的毫秒数？
	- 如何取得某月的最后一天？
	- 如何格式化日期？
	答：
	问题1：创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值。Java 8中可以使用java.time.LocalDateTimel来获取，代码如下所示。
	问题2：以下方法均可获得该毫秒数。
	问题3：代码如下所示。
		Calendar time = Calendar.getInstance();
		time.getActualMaximum(Calendar.DAY_OF_MONTH);
	问题4：利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。Java 8中可以用java.time.format.DateTimeFormatter来格式化时间日期，代码如下所示。
42、打印昨天的当前时刻。
	答：

	import java.util.Calendar;

	class YesterdayCurrent {
		public static void main(String[] args){
			Calendar cal = Calendar.getInstance();
			cal.add(Calendar.DATE, -1);
			System.out.println(cal.getTime());
		}
	}

	在Java 8中，可以用下面的代码实现相同的功能。

	import java.time.LocalDateTime;

	class YesterdayCurrent {

		public static void main(String[] args) {
			LocalDateTime today = LocalDateTime.now();
			LocalDateTime yesterday = today.minusDays(1);

			System.out.println(yesterday);
		}
	}
43、比较一下Java和JavaSciprt。
	答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。
	下面对两种语言间的异同作如下比较：
	- 基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。
	- 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）
	- 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。
	- 代码格式不一样。

	补充：上面列出的四点是网上流传的所谓的标准答案。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。639.......。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民，因此JavaScript支持函数式编程，可以使用Lambda函数和闭包（closure），当然Java 8也开始支持函数式编程，提供了对Lambda表达式?以及函数式接口?的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。
44、什么时候用断言（assert）？
	答：断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。
	断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。
	断言的使用如下面的代码所示：

	assert(a > 0); // throws an AssertionError if a <= 0
	1
	断言可以有两种形式：
	assert Expression1;
	assert Expression1 : Expression2 ;
	Expression1 应该总是产生一个布尔值。
	Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。

	要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或者禁用断言。

	注意：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。
45、Error和Exception有什么区别
答：
	Error
		Error是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。
		此类异常无法被捕获，所以发生此类错误时，JVM将终止线程。
	Exception：
			表程序可以捕获并且可以处理的异常。
			该类型异常可分为两类。
			RuntimeException运行时异常：(不受检异常)（可自定义该类型异常）
				RuntimeException类及其子类异常，表示程序在运行期间可能出现的错误。此类异常属于不可查异常，编译器不会检查此类异常。	
					比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。
				一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。

			非运行时异常：(受检异常)
				Exception中除RuntimeException及其子类之外的异常。编译器会检查此类异常
				如果程序中出现此类异常，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。
					比如说IOException，

	面试题：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java程序在运行时也可能会遭遇StackOverflowError，这是一个无法恢复的错误，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：

	class StackOverflowErrorTest {

		public static void main(String[] args) {
			main(null);
		}
	}
	提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再继续递归）。
48、运行时异常与受检异常有何异同
	均为Exception子类。
	RuntimeException运行时异常表程序在运行时会出现的异常，可无需处理。
	受检异常非运行时异常，编译器会检查此类异常所以你要吗捕获要么抛出。

49、列出一些你常见的运行时异常？
	答：
	- ArithmeticException（算术异常）
	- ClassCastException （类转换异常）
	- IllegalArgumentException （非法参数异常）
	- IndexOutOfBoundsException （下标越界异常）
	- NullPointerException （空指针异常）
	- SecurityException （安全异常）
46、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后
	答：会执行，在方法返回调用者前执行。

	注意：在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。
47、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用
	答：Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。
	在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。
	Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。
	一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；

50、阐述final、finally、finalize的区别。
	答：
	- final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。
	- finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。
	- finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。
51、类ExampleA继承Exception，类ExampleB继承ExampleA。
	有如下代码片断：

	try {
		throw new ExampleB("b")
	} catch（ExampleA e）{
		System.out.println("ExampleA");
	} catch（Exception e）{
		System.out.println("Exception");
	}

	请问执行此段代码的输出是什么？
	答：输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）
52、List、Set、Map是否继承自Collection接口？
	答：List、Set 是，Map 不是。
	Map是键值对映射容器，与List和Set有明显的区别。
	而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。
53、阐述ArrayList、Vector、LinkedList的存储性能和特性。
	答：ArrayList 和Vector都是使用数组方式存储数据，
	此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，
	Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。
	LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。
	Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。

	补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。
54、Collection和Collections的区别：
	答：
		Collection是一个接口，它是Set、List等容器的父接口；
		Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。
55、List、Map、Set三个接口存取元素时，各有什么特点？
	答：List以特定索引来存取元素，可以有重复元素。
	Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。
	Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。
	Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。
56、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？
答：
	TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。
	TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。
	Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。
57、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别。
	答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。
	wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

	补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。
58、线程的sleep()方法和yield()方法有什么区别？
	答：
	① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
	② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
	③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
	④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。
59、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B。
	答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。
60、请说出与线程同步以及线程调度相关的方法。
	答：
	- wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
	- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；
	- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；
	- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；
	...
61、编写多线程程序有几种实现方式
答：
	Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。
	两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。

	Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示：
	...
62、synchronized关键字的用法。
	答：synchronized关键字可以将方法或代码块标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。
63、举例说明同步和异步。
	答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。
	事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。

64、启动一个线程是调用run()还是start()方法？
	答：
		启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。
		.run()
			只是调用任务,未开辟线程。
			程序还是按顺序执行。
65、什么是线程池（thread pool）
	
	为了避免重复的创建线程（不加限制的创建线程会对系统造成负担），线程的创建本身也耗费资源。
	线程池的出现让线程可进行复用。
		答：线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。
66、线程的基本状态以及状态之间的关系
	答：
		说明：其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。死亡状态（Terminated）。
67、简述synchronized 和java.util.concurrent.locks.Lock的异同？
	答：Lock是Java 5以后引入的新的API。
		和关键字synchronized相比
		主要相同点：Lock 能完成synchronized所实现的所有功能；
		主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。
		synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。
68、Java中如何实现序列化，有什么意义？
	答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。
	可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。
	序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。
	要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的。
	然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；
	如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。
	序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第29题）。
69、Java中有几种类型的流
答：
	字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。
	在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。

	面试题 - 编程实现文件拷贝。（这个题目在笔试的时候经常出现，下面的代码给出了两种实现方案）
70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。
71、如何用Java代码列出一个目录下所有的文件
72、用Java的套接字编程实现一个多线程的回显（echo）服务器。
73、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式
74、你在项目中哪些地方用到了XML
75、阐述JDBC操作数据库的步骤。
	加载驱动。创建连接。创建语句。执行语句。处理结果。关闭资源。
76、Statement和PreparedStatement有什么区别？哪个性能更好？
77、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？
78、在进行数据库编程时，连接池有什么作用？
	避免频繁创建和释放连接所造成的开销
79、什么是DAO模式？
答：DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。
	在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。

80、事务的ACID是指什么？
	acid，事务隔离级别
81、JDBC中如何进行事务处理？
答：Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。
除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。
82、JDBC能否处理Blob和Clob？
答： Blob是指二进制大对象（Binary Large Object），而Clob是指大字符对象（Character Large Objec），因此其中Blob是为存储大的二进制数据而设计的，而Clob是为存储大的文本数据而设计的。
JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。
	PreparedStatement ps = con.prepareStatement("insert into tb_user values (default, ?, ?)");
	ps.setString(1, "骆昊");              // 将SQL语句中第一个占位符换成字符串
	try (InputStream in = new FileInputStream("test.jpg")) {    // Java 7的TWR
		ps.setBinaryStream(2, in);      // 将SQL语句中第二个占位符换成二进制流
		// 4. 发出SQL语句获得受影响行数
		System.out.println(ps.executeUpdate() == 1 ? "插入成功" : "插入失败");
	} catch(IOException e) {
		System.out.println("读取照片失败!");
	}
83、简述正则表达式及其用途。
答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。
84、Java中是如何支持正则表达式操作的
答：Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。
面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？
import java.util.regex.Matcher;
import java.util.regex.Pattern;
class RegExpTest {

    public static void main(String[] args) {
        String str = "北京市(朝阳区)(西城区)(海淀区)";
        Pattern p = Pattern.compile(".*?(?=\\()");
        Matcher m = p.matcher(str);
        if(m.find()) {
            System.out.println(m.group());
        }
    }
}
85、获得一个类的类对象有哪些方式
答：
- 方法1：类型.class，例如：String.class
- 方法2：对象.getClass()，例如："hello".getClass()
- 方法3：Class.forName()，例如：Class.forName("java.lang.String")
86、如何通过反射创建对象？
答：
- 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()
- 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance("Hello");
87、如何通过反射获取和设置对象私有字段的值？
答：可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。
88、如何通过反射调用对象的方法
	答：请看下面的代码：
	import java.lang.reflect.Method;
	class MethodInvokeTest {

		public static void main(String[] args) throws Exception {
			String str = "hello";
			Method m = str.getClass().getMethod("toUpperCase");
			System.out.println(m.invoke(str));  // HELLO
		}
	}
89、简述一下面向对象的"六原则一法则"。
 单一职责原则：	(类设计原则)
	一个类只做它该做的事情。（单一职责原则想表达的就是"高内聚"，写代码最终极的原则只有六个字"高内聚、低耦合"，就如同葵花宝典或辟邪剑谱的中心思想就八个字"欲练此功必先自宫"，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫"因为专注，所以专业"，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）
开闭原则：(类设计原则，针对方法)
	类应当对扩展开放，对修改关闭。
	软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）
- 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）
里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）
- 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）
- 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）
迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到"低耦合"，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）
90、简述一下你了解的设计模式...
答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。
在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。
面试被问到关于设计模式的知识时，可以拣最常用的作答，例如：
- 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。
- 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。
- 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。
- 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。
除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I/O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。
91、用Java写一个单例类。
	注意：实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器创建对象；②通过公开的静态方法向外界返回类的唯一实例。
	这里有一个问题可以思考：Spring的IoC容器可以为普通的类创建单例，它是怎么做到的呢？
92、什么是UML？
	答：UML是统一建模语言（Unified Modeling Language）的缩写，
	它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，
	为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。

93、UML中有哪些常用的图？
答：UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，
	包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。
	...
94、用Java写一个冒泡排序。
95、用Java写一个折半查找。
Java面试题全集（中）

置顶 骆昊 2015-04-09 22:05:20  233520  收藏
分类专栏： 面试笔试 Java就业专栏 文章标签： Java面试题 面试题大全 Web服务 JSP Servlet
版权
这部分主要是与Java Web和Web Service相关的面试题。

96、阐述Servlet和CGI的区别?
答：Servlet与CGI的区别在于Servlet处于服务器进程中，它通过多线程方式运行其service()方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，
而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet。

补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。
Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。
通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。
97、Servlet接口中有哪些方法？
答：Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关：
- void init(ServletConfig config) throws ServletException
- void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException
- void destory()
- java.lang.String getServletInfo()
- ServletConfig getServletConfig()

Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；
请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；
当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。


99、JSP有哪些内置对象？作用分别是什么？
答：JSP有9个内置对象：
- request：封装客户端的请求，其中包含来自GET或POST请求的参数；
- response：封装服务器对客户端的响应；
- pageContext：通过该对象可以获取其他对象；
- session：封装用户会话的对象；
- application：封装服务器运行环境的对象；
- out：输出服务器响应的输出流对象；
- config：Web应用的配置对象；
- page：JSP页面本身（相当于Java程序中的this）；
- exception：封装页面抛出异常的对象。