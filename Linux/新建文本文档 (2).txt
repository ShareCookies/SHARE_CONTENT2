本章主要讲述Linux性能调优的基础，具体包括性能调优的指标、性能调优工具如何使用以及如何发现系统性能瓶颈


附录-4.1.1 程序基础：
	程序与进程
		程序只占用磁盘空间，而不占用系统运行资源；
		而进程仅仅占用系统内存空间，是动态的、可变的，关闭进程，占用的内存资源随之释放。	
	进程之间的关系
		父进程与子进程之间是管理与被管理的关系，当父进程停止时，子进程也随之消失，但是子进程关闭时，父进程不一定终止。
	进程与线程
		进程是程序的一次动态执行，它对应着从代码加载、执行至执行完毕的一个完整的过程，是一个动态的实体，它有自己的生命周期。
		线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
	
		进程和线程的关系如下所述：
			一个线程只能属于一个进程，而一个进程可以有多个（至少有一个）线程。
			*进程作为资源分配的最小单位，资源是分配给进程的，同一进程的所有线程共享该进程的所有资源。
			*线程是cpu调度的最小单位-真正在处理机上运行的是线程。
		附：
			系统开销：在创建或撤销进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤销线程时的开销。
	进程优先级和nice级别：
		Linux是一个多用户多任务的操作系统。
		所有的任务都放在一个队列中，操作系统根据每个任务的优先级为每个任务分配合适的时间片（时间片是进程在处理器中的执行时间）。
		附：
			一个任务对应一个线程吗	
		
		进程优先级：
			在CPU执行每个进程任务的过程中，还涉及一个概念，即进程的优先级，它决定了进程在CPU中的执行顺序。优先级越高的进程被处理器执行的机会越大。
			进程优先级由动态优先级和静态优先级决定：
				根据进程的行为，内核使用启发式算法决定开启或关闭动态优先级。
				*可以通过nice级别直接修改进程的静态优先级，拥有越高静态优先级的进程会获得更长的时间片。Linux支持的nice级别从19（最低优先级）到-20（最高优先级），默认为0。只有root身份的用户才能把进程的nice级别调整为负数（让其具备较高优先级）。
				？
					系统内存不足时，为什么该应用会被关闭，是因为优先级吗
	进程的状态：
		...
		
		？
			进程状态与线程状态


4.1.2 内存指标：
	内存：在进程执行过程中，Linux内核会根据需要给进程分配一块内存区域，进程就把这片区域作为工作区。
	*1. 物理内存、逻辑内存、虚拟内存：
		物理内存就是系统硬件提供的内存大小，是真正的内存。
		在Linux下还有一个逻辑内存的概念，逻辑内存就是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存区域，用作逻辑内存的磁盘空间被称为交换空间（Swap Space）。
		但是，在Linux操作系统中，无论是系统内核，还是应用程序，都不能直接使用物理内存和逻辑内存，要使用这些内存，需要通过一个映射机制来实现。也就是说，Linux操作系统会把所有内存（包含物理内存和逻辑内存）都映射成虚拟内存，这样，应用程序在使用内存时，就需要向Linux内核请求一个特定大小的内存映射，并且收到一个虚拟内存的映射。这个申请到的虚拟内存不一定全部是物理内存的映射，还可能包含由磁盘上的交换空间映射来的内存。
	2．页高速缓存和页写回机制
		页:页是物理内存或虚拟内存中一组连续的线性地址，Linux内核以页为单位处理内存，页的大小通常是4KB。
		当一个进程请求一定量的页面时，如果有可用的页面，内核会直接把这些页面分配给这个进程，否则，内核会从其他进程或者页缓存中拿来一部分给这个进程用。内核知道有多少页可用，也知道它们的位置。
		附-内存回收:
			如果在进程请求指定数量的内存页时没有可用的内存页，内核就会尝试释放特定的内存页给新的请求使用。这个过程叫作内存回收。其中，kswapd内核线程负责页面回收。
		附：
			Linux在负载比较大（内存很紧张）的时候一般会看到这样的两个进程：kswapd0和kswapd1。
			如果这些进程占用系统资源很多，尤其是在负载很大的业务系统中，可能引起系统的宕机，如果这些进程占用资源非常高，就要考虑优化系统，或添加硬件资源。
			
	3．Swap交换空间：
		Linux的内存管理采取的是分页存取机制。
		为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到Swap交换空间中，而将经常使用的信息保留到物理内存。
		
		Linux内存运行机制：
			首先，Linux系统会不时地进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux也会交换出暂时不用的内存页面。这可以避免等待交换所需的时间。
			其次，Linux进行页面交换是有条件的，不是所有页面在不用时都交换到Swap。Linux内核根据“最近最经常使用”算法，仅仅将一些不经常使用的页面文件交换到Swap。
			
			最后，
				Swap的页面在使用时会首先被交换到物理内存，
				如果此时没有足够的物理内存来容纳这些页面，它们又会被马上交换出去，
				如此一来，虚拟内存中可能没有足够空间来存储这些交换页面，最终会导致Linux出现假死机、服务异常等问题。Linux虽然可以在一段时间内自行恢复，但是恢复后的系统已经基本不可用了。
	？如何判断是否内存达到瓶颈
4.1.3 文件系统指标
	下面针对不同的应用环境介绍一下如何选择合理的文件系统。
		（1）Web类的应用网站系统、APP、博客等应用的特点是读操作频繁，写操作一般，那么EXT4或XFS文件系统都是不错的选择。
		（2）数据库类应用对于MySQL、Oracle、邮件系统等写操作频繁的结构化数据库类应用，XFS文件系统是最佳选择。根据实际应用经验，对XFS、EXT4、EXT3块写入性能对比，整体上性能差不多，但在效率上（CPU利用率）最好的是XFS，接下来依次是EXT4和EXT3。
		（3）普通应用类场景对性能要求不高、数据安全要求不高的业务，EXT3/EXT2文件系统是比较好的选择，因为EXT2没有日志记录功能，这样就节省了很多磁盘性能。例如，Linux系统下的/tmp分区就可以采用EXT2文件系统。
4.1.4 磁盘I/O指标
	1．磁盘I/O调度策略
		...
	2．磁盘与缓存机制
		...
		*附：
			所以写入磁盘的数据是存在丢失可能的，如果不进行冲刷的话。
			
	？如何判断是否磁盘达到瓶颈
4.1.5 网络指标
	...
	如何判断是否网络达到瓶颈:
	
4.3.1 如何找到CPU瓶颈
	怎么样才能说明有CPU瓶颈呢。这主要看CPU的繁忙程度，如果CPU资源持续满负荷运转，而应用系统仍然缓慢甚至无响应，但在重新启动应用服务后，CPU负载又马上耗尽，此时基本就能判断CPU出现了瓶颈。
	？
		1. 可通过top或uptime的平均负载，来判断系统整体的CPU整体负载情况。
		如果负载高于cpu数，则说明等待处理的任务多。
		但是不是cpu的问题还要进一步判断，因为Load高只是代表需要运行的队列累计过多了。但队列中的任务实际可能是耗Cpu的，也可能是耗i/0、内存不足或者其他因素的。
		2.1 先判断cpu：
			相关命令：top、vmstat
			可看整体CPU使用率 项us、sy和id列的值。根据经验，us值不建议大于50% 如果us+sy大于80%说明可能存在CPU资源不足的情况。
			详细那个进程什么问题则：？top、jstack、mpstat等...
		2.2 磁盘
io等待为什么会占用cpu 使用时间比：
	https://blog.csdn.net/michaelwoshi/article/details/122890778
	
	你一定不止在一个地方看到类似"cpu等待IO就绪，线程挂起..."的描述，不知你有没有想过CPU到底在等待个啥，等待个寂寞吗。为什么CPU要等待呢。CPU不能参与吗。

	
	1.
		首先，cpu有两种状态，用户态和内核态，cpu会根据需要在两种状态之间切换。
		内核态的cpu有较高的权限，它能调用一些高级别的资源，比如访问一些安全级别较高的地址空间。主存(内存)这一层面内部同样进行了逻辑划分，分为用户空间和内核空间。顾名思义，内核空间只有处于内核状态的cpu才能访问的。其次，计算机中存储是分结构的。
	2. DMA：-(直接存储器访问，director memory access)
		“读操作”时，DMA负责将数据从磁盘拷贝到内核空间，然后cpu再从内核空间拷贝到用户空间。
		计算机硬件上使用DMA来访问磁盘等IO，也就是请求发出后，CPU就不再管了，直到DMA处理器完成任务，再通过中断告诉CPU完成了。所以总体来说单个IO对CPU占用的并不多。所以IO占用CPU资源，但是不多。
		附：为什么CPU要将它交给DMA搞：
			因为CPU处理数据的速度远远大于IO准备数据的速度。
			磁盘到内核空间的拷贝太慢了（想必你也知道不同级别的存储结构读写速度不一样），CPU的时间很宝贵的，它应该去做一些价值更大的东西。
	
	？cpu等待io就绪 等的是什么
	io过多为什么会引起cpu过多：？
		https://blog.csdn.net/weixin_40065538/article/details/118999214
		https://blog.csdn.net/weixin_40065538/article/details/118999214
	2.3 内存
	2.4 网络
	附：
		出现CPU瓶颈有两种原因：一种是应用程序bug导致CPU资源耗尽；另一种是CPU资源确实不足。
	附：
		有些应用软件会专门针对CPU做一些性能优化，例如，Nginx可以设置将其进程绑定到指定的CPU核上，这么做的主要好处是CPU缓存优化，它可以让同样的进程运行在一个CPU上，而不是在多个CPU上切换。当进程在CPU间切换的时候，要刷新CPU的缓存。而很多缓存刷新会使一个独立的进程要花费更多的时间才能处理完任务，所以将进程绑定到指定CPU是性能优化的一个不错的办法
		
	
	
4.2.1 CPU性能调优工具
	CPU性能评估常用的工具有vmstat、uptime、mpstat等，下面分别进行介绍。
	
	1．vmstat命令- Virtual Meomory Statistics（虚拟内存统计）的缩写:
		./vmstat.txt
	2．uptime命令
		./uptime.txt
	3．mpstat命令
		使用mpstat最大的好处是，它可以查看多核CPU中每个计算核的统计数据，而vmstat只能查看系统整体的CPU情况
4.2.2 内存性能调优工具
	1．free命令
		./free.txt
	2．smem命令
		通过smem，可以很轻松地获取每个进程占用的内存资源。smem绝对是Linux运维的必备工具。
		...
	
4.2.3 磁盘性能调优工具
	磁盘性能评估的常用工具有iotop、iostat等，下面分别进行介绍。
	1．iotop命令
		iotop是一个用来监视磁盘I/O使用状况的top类工具，可监测到某一个程序使用的磁盘I/O的实时信息。
		这对于线上业务系统来说非常有用。要使用这个工具，需要进行简单安装，在CentOS7.x版本下，直接执行yum在线安装即可.
	2．iostat命令
		iostat是I/O statistics（输入/输出统计）的缩写，主要的功能是对系统的磁盘I/O操作进行监视。
		iostat一般都不随系统安装，要使用iostat工具，需要在系统上安装一个sysstat的工具包，可以通过yum在线安装.
4.2.4 网络性能调优工具
	网络性能评估的常用工具有ping、traceroute和mtr等，下面分别进行介绍。
	1．ping命令
		ping命令很简单，但是功能强大，如果发现网络反应缓慢，或者连接中断，可以通过ping来测试网络的连通情况.
		注：
			1. time值显示了两台主机之间的网络延时情况，如果此值很大，则表示网络的延时很大，单位为ms。
			2. packet loss表示网络的丢包率，此值越小表示网络的质量越高。
	2．traceroute命令
		traceroute命令可以用来显示网络数据包传输到指定主机的路由信息，追踪数据传输路由状况。
		这对于网络性能调优非常有帮助.
4.2.5 系统性能综合调优工具
	有几个不错的工具可以用来全面监控Linux系统性能，如top、htop命令。
	
	2．利用top监控系统进程
		top命令是监控系统进程必不可少的工具。与ps命令相比，top命令动态、实时地显示进程状态，而ps只能显示进程某一时刻的信息。
		同时，top命令提供了一个交互界面，用户可以根据需要，人性化地定制自己的输出，更清楚地了解进程的实时状态。
		
		输出信息：
			进程PID为21115的java进程由root用户启动，优先级（PR）为23，
			占用的虚拟内存总量（VIRT）为1236M，未被换出的物理内存（RES）为360M，共享内存（SHR）为2384KB？。通过这几个选项可以了解java进程对内存的使用量，有助于系统管理员对系统虚拟内存使用状况的掌控。
			此刻java进程处于休眠状态（S），从上次更新到现在java占用CPU时间（%CPU）为6%，占用物理内存（%MEM）为4.4%，从进程启动到现在java占用CPU总时间（TIME+）为382:24.14，单位是（1/100）s。通过了解这些信息，可以使系统管理员掌握java进程对系统CPU、物理内存的使用状况。