



Java接口：
接口作为参数传递：
	介绍：
将接口类型的参数作为方法参数，
在使用时则可以将,
实现了接口的类传递给方法。
		注：
			1.传递过去的类可不用强转。
			（强制转为接口那变成什么？）
			2.传递过去的类只能调用接口定义的方法。
接口做方法返回值类型：
即返回值只要是实现了该接口的类的对象即可。
接口之间的多继承：
https://www.cnblogs.com/littlepanpc/p/3616300.html
一个类只能extends一个父类，可以implements多个接口。
但一个接口则可以同时extends多个接口，却不能implements任何接口。因而，Java中的接口是支持多继承的。

Serializable接口（序列化接口）：！！！
https://blog.csdn.net/leixingbang1989/article/details/50556966
历史：
jvm中引用数据类型存在于栈中，而new创建出的对象存在于堆中。如果电脑断电那么存在于内存中的对象就会丢失。
那么有没有方法将对象保存到磁盘(对象持久化存储)或通过网络传输到远处的其他地方呢？
答案是可以，但要求类实现Serializable接口。
原因是，jvm不仅需要考虑将对象存储到硬盘等其他介质，还需要考虑将其读取(反序列化)出来。
序列化就是起到告诉JVM,这个对象是由哪个类创建的。
将对象存盘部分原理：
Serializable接口，将类与一个称为serialVersionUID的变量关联起来，
这个serialVersionUID就是在反序列化中用来确定由哪个类来加载这个对象。
注：
	1.持久化的数据均为存在于堆中的数据，static类型的数据存在于方法区中，不能被持久化。
	如果想不持久化某个成员变量，则需要在成员变量加上关键字transient。
	2.如果不指定serialVersionUID，那么serialVersionUID值是和类中的成员变量相关联的。
	即保存到磁盘中的类不能用记事本打开手动修改成员变量，
	不然就不能读取到jvm中。
序列化接口作用：
允许将对象保存到磁盘中。
自定义serialVersionUID：
	介绍：
		指定serialVersionUID的数值，使得其不再与类的成员变量相关联。
	实现：
		实现序列话接口的同时创建一个serialVersionUID变量。
		private static final long serialVersionUID = -5182532647273106745L;  
	注：
		1.serialVersionUID不是决定由哪个类加载硬盘文件中的唯一因素，类的包名、类的名称都有关联。
		如果不一致，也会出现类型转化错误。原因是类的包名，类名已经被写入了文件当中。
		即只有指定的类才能从磁盘中读取该对象（某个实现了序列化接口并存盘的对象）。
注:
1.Serializable当参数类型:
即往该方法传递参数时，只要该参数是实现了Serializable接口的类对象就行。
Java<>:
http://www.importnew.com/24029.html
介绍:<>这叫范型，或者泛型！在集合中频繁出现，主要用来规定你这个集合中出现的数据类型！
例子：一个碗可以装很多种食物，加上范型，比如是面，那么这个碗只能是装上面这类的食物的！
例:TreeSet<Displayer> displayerSet = new TreeSet<Displayer>();//一个二叉树集合，这个集合里的参数只能是Displayer类displayerSet.add(displayer);
//往二叉树集合中插入
应该去看二叉树源码深刻理解下范型???

定义泛型接口:
https://www.cnblogs.com/alsf/p/5697548.html
接口应用泛型，即接口后加<>。
子类实现此接口，要求?
定义泛型类:
介绍:
类应用泛型，则类中属性类型可以用泛型暂代即属性类型，在实际使用时再确认属性的类型。
注:
这样类便可以得到复用，我们可以将泛型替换成任何我们想要的类型。
父类|接口有泛型时:
子类指定泛型具体值:
介绍:
实例化该类时部分地方法只能传字符串参数。
public class WordsDao extends BaseDaoHibImpl<String>
子类不指定泛型具体值:
介绍:
实例化该类后部分在确认泛型实际类型。
public class WordsDao<T> extends BaseDaoHibImpl<T>
泛型方法:
只要在返回类型前面加上一个类似<K, V>的形式就行了。
……
注意点:
1.父类或接口有泛型时，子类可指定泛型具体值，或子类可不指定泛型具体值继续用T来代指约束类。例:public class WordsDao<T> extends BaseDaoHibImpl<T>



GeneralKnowledges:
接口不可以直接实例化。
子类继承父类:
1.子类的访问修饰符要比父类的大，因为如果父类的方法是public修饰，而子类重写后改为private，那么就用父类访问变量指向子类对象时就调用不了共有的方法，这个不符合多态三要素，所以是错的。
2.子类是protect父类为啥也能访问!!!
3.子类初始化的时候会先去调用父类的无参构造函数，所以建议类都写无参构造函数。
4.子类不能和父类有相同方法名、相同参数而不同返回值的方法。即子类不能重载父类方法，子类只能重写父类方法。
5.子类方法与父类相同｛｝花括号中即使为空也算重写。子类方法与父类相同｛super.同方法名();｝即不算重写，是继承父类。
对象：
实例化后的类叫对象
方法：
静态||实例方法的调用:
静态方法属于类最好用类名.静态方法来直接调用
实例方法用对象.实例方法调用。
静态方法：
静态方法不能访问任何实例属性和实例方法。



