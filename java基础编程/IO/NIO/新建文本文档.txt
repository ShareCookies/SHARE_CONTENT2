IO多路复用机制详解
https://blog.csdn.net/sehanlingfeng/article/details/78920423


常见的IO模型有四种：
	1.同步阻塞IO（Blocking IO）：
		传统的IO模型。
		例：
			用户线程读取时(read)需要等待socket中的数据读取到buffer后，才继续处理接收的数据。
			整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。

	2.同步非阻塞IO（Non-blocking IO）：
		附：
			这里所说的NIO并非Java的NIO（New IO）库。
		例：
			默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。
			则用户线程发起IO读取时请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求。
			这种模型消耗了大量的CPU的资源,一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。
			？
				为什么大量耗费cpu资源	
	3.IO多路复用（IO Multiplexing）：
		IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。
		例：	
			用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。
			当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。
		用户线程使用select函数的伪代码描述为：
			select(socket);//将socket添加到select监视中
			while(1) 
			{
				sockets = select();
				for(socket in sockets) //在while内一直调用select获取被激活的socket
				{
					if(can_read(socket)) //一旦socket可读，
					{
						read(socket, buffer);//便调用read函数将socket中的数据读取出来。
						process(buffer);
					}
				}
			}

 

			
			
			？
				优势在于避免线程主动多次向cpu发起请求，减少cpu资源损耗等？
			？
				从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。
				但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。

		
		Reactor设计模式：
			有时也称为异步阻塞IO.
			上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），
				?
					是指select中只能一个一个运行吗？
					一线程中多个socket不行吗，一定要select？
			平均时间甚至比同步阻塞IO模型还要长。
				？
			如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。Reactor设计模式就是实现了该效果。
			
			...
			介绍：
				用户线程注册事件处理器之后可以继续执行做其他的工作（异步）。
				而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。
				由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。
					注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。
					一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。

		附：
			Java中的Selector和Linux中的epoll都是这种模型。?

	
	
	4.异步IO（Asynchronous IO）：
		即经典的Proactor设计模式，也称为异步非阻塞IO。

		“真正”的异步IO需要操作系统更强的支持。
		在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。
		而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。
		
		Proactor设计模式:
			异步IO模型使用了Proactor设计模式实现了这一机制。
			...
前言：？
	同步和异步:
		同步和异步的概念描述的是用户线程与内核的交互方式：
		同步：
			是指用户线程发起IO请求后需要等待(或者轮询)，内核IO操作，完成后才能继续执行；
		异步：
			是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。
		附：
    		java中 内核io应该是指编程语言的底层io 并不是操作系统的!
	阻塞和非阻塞：
		阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式：
		阻塞
			阻塞是指IO操作需要彻底完成后才返回到用户线程；
		非阻塞
			非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。
    ？
		这么理解：
		同步是用户来决定的，我可以用同步的方式来操作也可以用异步的方式来操作，如果使用异步的话那么一定要系统能支持(或使用变通的方式来实现异步)。
			总之同异步就是去发起一请求后，能先去干别的活，在回来找你。
		阻塞则是系统来决定的，如果是阻塞系统，则我们只能等待其完成io完成返回后。
			阻塞就是对系统io操作来说，一定要完成该io才返回状态(失败或成功)给你。
			非阻塞则.
	附：
		另外，Richard Stevens 在《Unix 网络编程》卷1中提到的基于信号驱动的IO（Signal Driven IO）模型，由于该模型并不常用，本文不作涉及。

