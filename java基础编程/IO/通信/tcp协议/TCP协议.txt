参考链接：https://blog.csdn.net/weixin_44198965/article/details/90083126
TCP协议：
	介绍：
		TCP 用于应用程序之间的通信。
		当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求，
		在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。
			？
				IP 是无连接不占用通道，基于ip的是如何实现有连接的了占用通道了。
				通信线路是指？
	TCP报文格式
		图:
			./TCP报文格式.png
		32
			16位源端口号：16位的源端口中包含初始化通信的端口。源端口和源IP地址的作用是标识报文的返回地址。

			16位目的端口号：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。
			附：
				端口号：用来标识同一台计算机的不同的应用进程。
			注：
				TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。

		32位序号(seq)：
			32位(4个字节)的序列号由接收端计算机使用,序号确保了TCP传输的有序性。
			
			
			?
				序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号？。
				例：一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性
				？
					tcp分多次包传输一个数据的
		32位确认序号(ack)：
			确认号ack，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。
			如果设置了ACK控制位，这个值表示下一个准备接收的包的序列码。
		附：
			序号和确认号：是TCP可靠传输的关键部分。

		32
			4位首部长度：
				由于首部可能含有可选项内容，因此TCP报头的长度是不确定的？，4位首部长度指示何处数据开始。
				附：
					首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。
			保留（6位）：
				6位值域，这些位必须是0。为了将来定义新的用途而保留。

			标志：
				6位标志域。
				分别表示为：URG(紧急标志)、ACK(有意义的应答标志)、PSH(推)、RST(重置连接标志)、SYN(同步序列号标志)、FIN(完成发送数据标志)。
				1）URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。

				2. ACK：
					确认序号标志(Acknowledgement Number)，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。

				3）PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。

				4）RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。

				5）SYN：
					同步序号(Synchronous)，用于建立连接
					在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。

				6）FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。
			16位窗口大小：
				用来表示想收到的每个TCP数据段的大小。TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16字节字段，因而窗口大小最大为65535字节。
				用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。
		32：
			16位校验和：16位TCP头。源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。
				奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。

			16位紧急指针：
				指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。
				？
					程序处理还是tcp处理

		选项：
			长度不定，但长度必须为1个字节。如果没有选项就表示这个1字节的域等于0。
		
		数据：
			该TCP协议包负载的数据。
			附：
				TCP 报文段中的数据部分是可选的
				。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。
				如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。
		附：
			https://blog.csdn.net/paincupid/article/details/79726795
		？
			TCP报文格式是符合ip包规范
	TCP三次握手:(建立TCP连接)
		https://blog.csdn.net/Tomwildboar/article/details/104008537
		所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。
		例：
			在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：
		
			1. 第一次握手：
				Client将标志位SYN置为1，随机产生一个序列号seq(例J)，
				并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

			2. 第二次握手：
				Server收到数据包后由标志位SYN=1知道Client请求建立连接，
				Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个序列号seq(例K)，
				并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

			3. 第三次握手：
				Client收到确认后，检查ack是否为J+1，ACK是否为1，
				如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，
				Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
			图:
				./三次握手.png
		注：
			为什么必须三次连接两次行不行：
				A：不行，因为TCP是安全的传输，必须保证每一个数据包都不丢失。所以必须保持客户端和服务端都接收、发送正常。
		附：
			SYN攻击：
				在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。
				SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。
				SYN攻击是一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：
					#netstat -nap | grep SYN_RECV		
		
	TCP四次挥手：(断开TCP连接)
		https://blog.csdn.net/Tomwildboar/article/details/104008537

		所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。
		由于TCP连接时全双工的，因此每个方向都必须要单独进行关闭.
			一方发送一个FIN来终止这一方向的连接后，意味着这一方向上没有数据流出了，即主动关闭连接的一方还具有接收功能。（半关闭）
		例：
			在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：
			是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

			1. 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

			2. 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

			3. 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

			4. 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

			图：
				./四次挥手.png
		附：
			为什么必须四次挥手关闭：
				因为被动关闭的一方，可能存在没有发完的数据，等它发送完毕后还需要再次告诉一下关闭方，这样关闭方才可以进行确认关闭。
			客户端异常如何关闭tcp：
				客户端如果出现故障，服务器不能一直等下去，白白浪费资源。
				服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。	
	
				
	附：
		为什么称其为提供应用程序间的通信:
			因为应用层通过该协议能实现信息传输
		？UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。	
		TCP/IP
			TCP/IP 意味着 TCP 和 IP 在一起协同工作。
			TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。
			IP 负责计算机之间的通信。
			TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。
			IP 负责将包发送至接受者。
UDP协议：
	用户数据报协议（User Data Protocol），是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。
	附：
		为什么不说udp/ip ：？
			https://www.zhihu.com/question/315014201		