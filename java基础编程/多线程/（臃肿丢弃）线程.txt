最新链接：
	http://note.youdao.com/noteshare?id=c450556f4fb5ab052c35e6f0aa5aedc8&sub=BBFFA379C1E544D0B6975B2049A6E45A
java线程:
	java创建线程的三种方式：
		1.用new Thread(Runnable target).start()启动一线程，并驱动任务：
			介绍：
				线程可以驱动任务，因此需要一种描述任务的方式。、
				Runnable接口可以定义任务，实现Runnable接口并编写run()方法即定义了一个任务。
			例：
				new Thread(new Runnabel(){//实现Runnable接口
					public void run(){
						System.err.println("线程");
					}
				}).start();
		2.实现Callable接口：
			介绍：
				Callable 接口相较于Runnable 接口，可以有返回值，并且可以抛出异常。
				https://www.cnblogs.com/baizhanshi/p/6425209.html
				http://www.threadworld.cn/archives/39.html
			实现：
				1.任务实现Callable接口
					注：Callable的泛型用来，修饰从call()中返回的值
				2.FastTask修饰任务
				3.线程驱动FastTask(修饰过的任务)
				4.通过FastTask获取任务完成后返回结果
			例：
				Callable/CallaleDemo.java
			Future：
				介绍：
					通过Future可以获取任务的执行结果
				方法：
					isDone()：
						isDone()方法可以用来检查分配的任务是否已经被处理了
					get()：	
						？
		3.继承Thread，并重写run()方法:
			介绍：
				任务简单的情况下，直接继承Thread，在里头编写任务
			例：
				class ThreadTest extends Thread{
					public void run(){//在该方法里写该线程要干的事。
						System.err.println("线程");
					}
				}
				ThreadTest t = new ThreadTest();
				t.start();//线程的启动:		
	Thread类:
		方法:
			.start():
				该方法用于启动线程来驱动任务。			
			.run()
				只是调用任务,未开辟线程。
				程序还是按顺序执行。
			.setPriority():
				介绍：
					设置线程的优先级
				例：
					Thread.currentThread().setPriority();
					//值建议Thread.MAX_ PRIORITY、 NORM_ PRIORITY和MIN_ PRIORITY
			.join()：
				加入一个线程。
				在某个线程中(调用线程)调用其他线程的join方法(被调用线程)时，
				调用线程将被阻塞，直到被调用线程执行完它才会继续运行。
				例：
					b任务的run中，写a线程.join(),则b线程要等待a线程运行完才能继续运行。
				注：
					调用线程将被阻塞，那么其恢复后是重新排队还是直接运行！
					若调用的线程耗时，那么会被剥夺cpu资源吧，那么此时调用线程还是在阻塞状态吗！
				join()中断：
					介绍：
						interrupt()；
						调用interrupt方法可以中断join。
					例：
						被调用线程引用.interrupt();被调用线程任务要捕获InterruptedExeception。
					注：
						isInterrupted()判断是否在join调用状态。
			.sleep():
				介绍：
					线程休眠指定时间
					线程睡眠(即阻塞)到期后自动苏醒，并返回到可运行状态(不是运行状态)。
				例：
					TimeUnit.MILLISECONDS.sleep(100);//Java SE5/6-Style 
					或Thread.sleep(100);//Old-Style
				注：
					对sleep()的调用可能抛出InterruptedException异常，并且你要在run()中捕获它。
					因为异常不能跨线程传播回main(),所以你必须在本地处理所有在任务内部产生的异常。
					不能抛出吗！
				.sleep(0)作用：
					由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况。
					为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。
			.yield():
				介绍：
					设置当前线程让步。
					提示线程调度机制我的任务已经差不多完成，允许放弃cpu资源进入就绪状态重新排队，让别的线程调用cpu。
					这只是对jvm线程调度器的一个建议，没有任何机制保证它会被采纳，所以重要的控制或调用不能依赖于yield。
				例：
					Thread.yield();
			.interrupt():
				介绍：
					可以用来终止被阻塞的任务。
					该方法将设置线程的状态中断状态，但它不会中断一个正在运行的线程。
					！！！
					更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，
					此时调用该线程的interrupt()方法，那么该线程将抛出一个 InterruptedException中断异常（该线程必须事先预备好处理此异常），从而提早地终结被阻塞状态。
					如果线程没有被阻塞，这时调用 interrupt()将不起作用，直到执行到wait(),sleep(),join()时,才马上会抛出 InterruptedException。
					
					即如果一个线程已被阻塞，那么interrupt将设置这个线程的中断状态，然后线程抛出InterruptedException。
					所以在你的线程中应编写catch语句。
				例子：
					Thread.interrupt()//中断当前线程
					thread.interrupt();//中断持有的线程对象
				interrupt、interrupted和isInterrupted区别：
					https://blog.csdn.net/smiles13/article/details/81292608
			.isDaemon():
				介绍：
					判断线程是否是一个后台线程。
				例：
					Thread t=...;
					syso(t.isDaemon);
					或
					Thread.currentThread().isDaemon();//判断当前线程是否为后台线程
			.getName():
				介绍：获取当前线程名字
				例：Thread.currentThread().getName();//主线程默认名main，创建的线程名默认从Thread-0开始
			后台线程：
				介绍：
					后台线程(daemon),指在程序运行的时候在后台提供一种通用服务的线程。
					注：
						当所有非后台线程结束时，程序就终止了，同时会杀死进程中所有的后台线程。
				实现：
					在一个线程对象启动之前（即start()之前）,
					调用该对象的setDaemon（true）方法即可把一个线程设置为后台线程。
				例：
					Thread daemon=new Thread(new Task());
					daemon.setDaemon(true);//must call before start()
					daemon.start();
				注：
					1.后台线程创建的任何线程都将自动设置为后台线程。
					2.后台线程在不执行finally的情况下就会终止其run()方法。			
		注：
			程序结束：
				1.对Java程序来说，一个进程只要还有一个前台线程在运行，那么进程就不会结束。
				如果一个进程只有后台线程运行，那么该进程就会结束。
				2.使用Thread时，每个Thread都注册了自己，在它的任务退出其run()并死亡之前，垃圾回收器无法清除它。
	线程池：
		https://www.cnblogs.com/superfj/p/7544971.html
		https://www.cnblogs.com/fengsehng/p/6048610.html
		介绍：
			为了避免重复的创建线程，线程池的出现可以让线程进行复用。
			通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。
		为什么要使用线程池：
			1.避免频繁地创建和销毁线程，达到线程对象的重用。
			2.使用线程池还可以根据项目灵活地控制并发的数目。
		执行器：
			能创建线程池来管理线程，并驱动任务。
			Executor（接口）：
				介绍：
					Executor是个线程池框架，其内部使用了线程池机制。
					hcg：
						凡是Executor的实现类，其内部均要实现线程池机制。
						框架就是一套已经写好的代码，这些代码可简称为工具。
						你想使用这些工具，你就得按照框架的流程和规范。
					Executor框架包括：
						线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable等。！
						通过Executor框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。
				任务的执行：
					一旦Runnable任务传递到execute（）方法，该方法便会自动将一任务放到一个线程上执行。
					Callable任务要用Executor的submit(Callable task) 方法来执行。
				ExecutorService（接口，且继承了Executor接口）：
					介绍：
						ExecutorService提供了更丰富的实现多线程的方法，最重要的是其定义了一些生命周期的方法。
						ExecutorService的生命周期包括三种状态：
							运行、关闭、终止。
							创建后便进入运行状态。
							当调用了shutdown（）方法时，便进入关闭状态。
							调用了shutdown，且当前已经提交了的任务执行完后，便到达终止状态。
						hcg：
							可将对象的运行，进行阶段划分，就是生命周期。
					方法：
						shutdown()：
							方法在终止前允许执行以前提交的任务。即线程将在，Executor中的任务完成之后，尽快退出
						shutdownNow()：
							方法阻止等待任务启动并试图停止当前正在执行的任务。
						...
					
			Executors：
				使用Executors的工厂方法创建线程池。
				Executors提供四种线程池的创建方法。
				newCachedThreadPool() ：
					创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。
					CachedThreadPool：为每一个任务创建一个线程。
				newFixedThreadPool(int nThreads) 
					创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。
					使用了有限的线程集来执行提交的任务。
				例：
					ExecutorService exe= Executors.newFixedThreadPool(10);//创建一个拥有10个线程的线程池。
					exe.execute(new Task());		
		注：
			任何线程池中，现有线程在可能的情况下都会被自动复用。！
	共享资源：
		使用了并发后，多个线程彼此干涉的问题就产生了。
		例：两线程同时改变同一个值，同时访问一打印机等。
		同步：
			多线程的同步即限制某资源在任一个时刻只能被一个线程访问，以保证数据的完整性。
			https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/4855164
			java关键字synchronized实现同步：
				https://www.cnblogs.com/QQParadise/articles/5059824.html
				介绍：
					java中可通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。
					synchronized锁住一个对象后，别的线程如果也想拿到这个对象的锁，就必须等待这个线程执行完成释放锁。
					所以synchronized通常称为重量级锁。
					复杂版：
						Java以提供关键字synchronized的形式，为防止资源冲突提供了内置支持。
						当任务要执行被synchronized关键字保护的代码片段的时候，它将检查锁是否可用，然后获取锁,执行代码,释放锁。
						共享资源一般是以对象形式存在的内存片段，但也可以是文件、输入/输出端口，或者是打印机。
						要控制对共享资源的访问，得先把它包装进一个对象。然后把所有要访问这个资源的方法标记为synchronized。
						如果某个任务处于一个对标记为synchronized的方法的调用中，
						那么在这个线程从该方法返回之前，其他所有要调用类中任何标记为synchronized方法的线程都会被阻塞。
						即每个访问临界共享资源的方法都必须同步，否则将无法正确工作。
				案例：
					synchronized能加在方法或者代码段上。
					1.同步控制块（临界区）：
						介绍：
							只是希望防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。
							通过这种方式分离出来的代码段被称为临界区(critical section)，它也使用synchronized关键字建立。
							synchronized被用来指定某个对象，此对象的锁被用来对花括号内的代码进行同步控制。
							对象的锁拿来用，那么如果该对象内有多个临界区了：
								使用该方式或得synchronized块上的锁，那么该对象其他synchronized方法和临界区就不能被调用了。
						例：
							public  void test() {
								synchronized(this){//this为要锁住的对象，如果某线程得到锁那可其他线程只有等到锁释放才能进入临界区。
									将处理共享资源的代码（或操作）放到一个代码块中
								}
							}
						注：
							1.多个线程共享的锁对象必须是唯一的。
							例：
								锁对象的创建不能放在实现了Runnable接口的类的run（）方法中，
								否则每个线程运行到run()方法会新建一个锁对象，线程不能产生同步效果。？
							2.通过同步控制块，而不是同步方法，可以使多个任务访问对象的时间性能得到（显著）提高。
							锁对象也称为监视器！
					2.同步方法：
						public synchronized void test() {}
						注：
							1.同步方法也有锁，它的锁就是当前调用该方法的对象。
							2.静态同步方法的锁是该方法所在类的class对象。
							3.synchronized关键字不属于方法特征签名组成部分，所以可以在覆盖方法的时候加上去。
					锁对象：
						锁对象是同步代码块的关键，当线程执行到同步代码块时，首先会检查锁对象的标志位，如果标志位小0则线程发生阻塞。
						锁对象的标志位默认为1，当一个线程运行到同步代码块时，标志位会减一（这里标志位就是0），
						当线程执行完同步代码块后，标志位会加一（这里标志位就会变为1，后面的新线程才能执行同步代码块内容）。
					注：
						线程在执行同步代码时每次都会判断锁的状态，耗费资源效率低下。
				synchronized实现原理：
					synchronized块中的方法获取了对象的monitor....?

				
			java关键字volatile实现同步:
				介绍：
					volatile是Java提供的一种轻量级的同步机制。
					
					复杂版：
						1.volatile关键字还确保了应用中的可视性。如果你将一个域声明为volatile的，
						那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。
						即便使用了本地缓存，情况也是如此，volatile域会立即被写人到主存中，而读取操作就发生在主存中。
						
						2.如果多个任务在同时访问某个域，那么这个域就应该是volatile的，
						否则，这个域就应该只能经由同步来访问。
						同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护,那就不必将其设置为是volatile的。					
				volatile修饰变量：
					public static volatile int num = 0;
					当操作一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中去；
	　　　　	且这个写会操作会导致其他线程中的缓存无效。
				线程对数据的处理过程:
					处理数据时，a线程会把值从主存(堆)load到本地栈(线程栈)，完成操作后再save回去。
					但如果a还未同步到主存中；此时线程B操作数据，观察到主存数据值未变，则使用了线程已经缓存的数据，
					此时就会出错。
				注:
					针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（如另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。
					在线程安全的情况下加volatile会牺牲性能。
					当一个域的值依赖于它之前的值时，volatile就无法工作了。？
			java类Lock实现同步：
				介绍：
					Lock对象必须被显式地创建、锁定和释放。因此，它与内建的锁形式相比，代码缺乏优雅性。
					但是，对于解决某些类型的问题来说，它更加灵活。
					显示的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁，还赋予你给更细粒度的控制力。
				Lock对象优势：
					尽管try-finally所需的代码比synchronized关键字要多,但是这也代表了显式的Lock对象的优点之一。
					如果在使用synchronized关键字时，某些事物失败了，那么就会抛出一个异常。
					但是你没有机会去做任何清理工作，以维护系统使其处于良好状态。
					有了显式的Lock对象，你就可以使用finally子句将系统维护在正确的状态了。
				ReentrantLock：
					Lock接口的一个类，使用频率很高的一个锁，ReentrantLock可重入锁。
					一个线程已经获得了锁，其内部还可以多次申请该锁成功
					注：
						1.表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。
						2.ReentrantLock允许你尝试着获取但最终未获取的锁，这样如果其他人已经获取了这个锁，
						那你就可以决定离开去执行其他一些事情， 而不是等待直至这个锁被释放。
				例：
					Lock lock=new ReentrantLock();
					lock.lock();
					
					try {
						...
					} finally {
						lock.unlock();//使用了lock和unlock创建了临界资源
					}
					
					lockTest.java
			线程本地存储：
				防止在共享资源上产生冲突的第二种方式是根除对变量的共享。
				线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。、
				创建和管理线程本地存储可以使用ThreadLocal类。
				注：
					1.ThreadLocal对象通常当作静态域存储。
					2.ThreadLocal的方法保证不会出现竞争条件（即同步安全）。

			注：
				使用并发时，将域设置为private是非常重要的，否则synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突。
				
			备注：
				互斥量：
					基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。
					这意味着在给定时刻只允许一个任务访问共享资源。
					通常这是通过在代码前面加上一条锁语句来实现的，这就使得在一段时间内只有一个任务可以运行这段代码。
					因为锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量(mutex)。
				原子类:
					Java SE5引入了诸如AtomicInteger. AtomicLong. AtomicReference等特殊的原子性变量类。
					这些类被调整为可以使用在某些现代处理器上的可获得的，并且是在机器级别上的原子性。
					对于常规编程来说，它们很少会派上用场，但是在涉及性能调优时，它们就大有用武之地了。					
				
	捕获线程中异常：
		介绍:
			由于线程的本质特性，使得你不能捕获从线程中逃逸的异常。
			一旦异常逃出任务的run方法，它就会向外传播到控制台。
			在JavaSE5之前,你可以使用线程组来捕获这些异常，JavaSE5后就可以用Executor来解决这个问题，因此你就不再需要了解有关线程组的任何知识了。
		实现：
			实现UncaughtExceptionHandler接口创建一异常处理器类，
			把异常处理器类绑定到线程。
			绑定3方式:
				1.
					线程引用设置异常处理器thread.setUncaughtExceptionHandler
				2.
					修改Executor产生线程的方式，给其传递一个ThreadFactory,该工厂将在每个新创建的Thread对象上附着一个Thread.UncaughtExceptionHandler。
				3.
					Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
	终结任务：
		即把线程设置为中断状态，然后在任务中检测线程是否中断，或捕获中断异常，来结束线程。
		中断发生的唯一时刻是在任务要进入阻塞操作中，或已经在阻塞操作内部。
		结束（中断）任务方法：
			1.Thread.interrupt()
				
			2.executorService.awaitTermination()！
				当前线程阻塞，直到
					等所有已提交的任务（包括正在跑的和队列中等待的）执行完
					或者等超时时间到（那么已提交任务还会执行吗？）
					或者线程被中断，抛出InterruptedException
					然后返回true（所有任务在超时时间之前全部结束执行完毕）或false（已超时）
					shuntdown()和awaitTermination()效果差不多，方法执行之后，都要等到提交的任务全部执行完才停。
			3.executorService.shuntdownNow():
				在Executor上调用shutdownNow,那么它将发送一个interrupt调用给它启动的所有线程。
				这么做是有意义的，因为当你完成工程中的某个部分或者整个程序时，通常会希望同时关闭某个特定Executor的所有任务。
			4.future.cancel(true):
				使用Executor，有时也会希望只中断某个单一任务。
				那么通过调用submit()而不是executor()来启动任务，就可以持有该任务的上下文。
				submit()将返回一个泛型Future<?>,其中有一个未修饰的参数，因为你永远都不会在其上调用get(),持有这种Future的关键在于你可以在其上调用cancel(),并因此可以使用它来中断某个特定任务。
				当你将true传递给cancel(),那么它就会拥有在该线程上调用interrupt()以停止这个线程的权限。因此，cancel()是一种中断由Executor启动的单个线程的方式。
				例子：
					Future<?> f =exec.submit(runnable);//runnable任务要处于阻塞状态
					TimeUnit.MILLISECONDS.sleep(100);//延迟来确保任务处于阻塞
					f.cancel(true);

			注：
				1.新的concurrent类库似乎在避免对Thread对象的直接操作，转而尽量通过Executor来执行所有操作。
				2.无法中断正在试图获取synchronized锁或试图执行I/O的线程
				但可以用别的方式中断....
		检测中断：
			interrupted()：
				测试当前线程（当前线程是指运行interrupted()方法的线程）是否已经中断，且清除中断状态。
				如果连续两次调用该方法，则第二次调用将放回false，因为中断状态在第一次已经清除掉。
			isInterrupted()：测试线程（调用该方法的线程）是否已经中断，不清除中断状态。
			interrupted 是作用于当前线程，isInterrupted 是作用于调用该方法的线程对象所对应的线程。
			例：
				Thread.interrupted();
				线程对象.isInterrupted();
		中断特殊阻塞：
			
			无法中断正在试图获取synchronized锁或试图执行I/O的线程。
			
			中断试图执行I/O的线程：
				关闭任务上发生阻塞的底层资源。
				先把线程设为中断状态，
				再释放任务上发生阻塞的底层资源，来达到中断线程的目的。
				例：
					CloseResource.java
			中断互斥所阻塞的线程：		
				如果你尝试着在一个对象上调用其synchronized方法,而这个对象的锁已经被其他任务获得，那么调用任务将被挂起(阻塞)，直至这个锁可获得。
				但ReentrantLock上阻塞的任务可以被中断。
				例：
					InterruptMutex.java
					关键代码：
						private Lock lock=new ReentrantLock();
						lock.lock();//获取锁
						try {
							...
						} catch (Exception e) {
							// TODO: handle exception
							System.out.println("reentrantLock被中断或出现异常");
						}
			注：
				1.nio类提供了更人性化io中断，被阻塞的nio通道会自动响应中断。
				即设置线程为中断状态，nio就会自动响应中断。
		注：
			1.任务的结束：退出run()方法即算任务结束。 
			2.被设计用来响应interrupt()的类通常要建立一种策略，来确保它将保持一致性。
			即中断发生后，某代码后要跟try-finally子句，使得无论run()如何退出，清理都会发生。
			3.！！！

	线程协作（线程通信）：
		介绍：
			线程协作，是使多个任务一起工作去解决某个问题。
			线程的协作关键问题是任务之间的握手，可使用互斥或挂起来实现握手。
				互斥：确保只有一个任务可以响应某个信号。
				挂起：直至某些外部条件发生变化后任务才可继续。
		synchronized下：
			以下方法均要在synchronized作用域中才能使用
			wait()：
				使当前线程进入挂起状态，等待唤醒。
				注：
					1.调用sleep和yield后，对象上的锁并未被释放。
					而调用wait对象上的锁被释放，因此该对象上的synchronized方法可以在挂起期间被调用。
					2.wait有两种形式，一种能接受毫秒作为参数，一种不接受任何参数。
			notify：
				唤醒此同步锁上等待的第一个调用wait()的线程。
			notifyAll：
				唤醒此同步锁上调用wait()的所有线程。
			例：
				NotifyVsNotifyaAll.java
			注：
				1.三个方法是Object类的方法，且调用者都应该是同步控制方法或同步控制块，否则JVM抛出IllegalMonitorStateException。
				即方法的调用者必须要有能获取对象锁的能力。
		Lock与Condition：
			使用lock显示的实现了同步后，要想实现线程之间通信要使用Conditon对象。
			例：
					private Lock lock=new ReentrantLock();
					private Condition condition=lock.newCondition();
					private Condition condition2=lock.newCondition();
					condition.await();
					condition.signal();
					condition2.await();
					condition2.signal();
					一个condition对象的signal（signalAll）方法和该对象的await方法是一一对应的，
					也就是一个condition对象的signal（signalAll）方法不能唤醒其他condition对象的await方法。
			注：
				Condition类的awiat方法和Object类的wait方法等效
				Condition类的signal方法和Object类的notify方法等效
				Condition类的signalAll方法和Object类的notifyAll方法等效
		同步队列：
			同步队列在任何时刻都只允许一个任务插入或移除元素。
			所以使用同步队列解决任务协作问题更好。
			BlockingQueue接口提供了队列，其实现类LinkedBlockingQueue是一个无届队列，
			实现类ArrayBlockingQueue，具有固定的大小。
			
多线程(multi-thread):
	并发介绍：
		并发编程将程序划分为多个分离的，独立运行的任务。
		并发能解决的问题大体上可分为"速度"和"设计可管理性"两种。
		速度问题：
			如果你想要一个程序运行的更快，那么可以将其断开为多个片段，在单独的处理器上运行每个片段。
			以多核处理器的形式，使程序运行的更快。所以你得学习如何使用并发来利用这些额外的处理器。
			（1.但并发也可以提高运行在单处理器上程序的性能。
			因为如果程序是顺序执行的话，当发生任务阻塞时（通常是I/O），将导致程序无法执行。
			2.如果假设单处理器程序不会出现任务阻塞，那么在单处理器上运行的并发程序开销，将比程序所有部分均顺序执行的开销大，
			因为其中增加了上下文切换的代价。（从一个任务切换到另一个任务）
			）
	并发编程意义：
		你自己没有启动线程并不代表你可以回避编写多线程的代码。
		如，web系统是最常见的java应用系统之一，其基本的web类库、Servlet具有天生的多线程性。
		//因为web服务器经常包含多个处理器，而并发是充分利用这些处理器的理想方式。
		//web服务器通常为每个请求分配一个线程
	并发的实现：
		进程并发编程：
			多任务操作系统可通过周期性地将CPU从一个进程切换到另一个进程，来实现同时运行多个进程。
			操作系统通常会将进程互相隔离开，因此它们不会彼此干涉，使得进程编程相对容易一些。
		并发语言编程：
			某些编程语言可以将并发任务彼此隔离，其中每个函数调用不会产生任何副作用（并因此而不能干涉其他函数）。
			这些语言通常称为函数型语言，如Erlang。
		java并发编程：
			Java采取在顺序语言的基础上提供对线程的支持，采用的是线程机制。
			线程机制：
				1.线程机制是在由执行程序表示的单一进程中创建任务。
				2.java线程机制是抢占式算法的，这表示调度机制会周期性的中断线程，将上下文切换到另一个线程。
				从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。
				如何切分cpu时间，通常无需开发者考虑。
				注：
					线程调度机制会根据线程优先级、线程饥饿情况等数据，分配出下一个时间片给某个线程执行。
				3.多线程机制将这些独立任务（或叫子任务，即并发编程将程序划分为多个分离的任务。），中的每一个都将由执行线程来驱动。
				注：
					java程序是从main()开始的，main()也分配了线程
			线程机制好处：
				1.该方式的一好处在于操作系统的透明性。
				即某些操作系统不支持多任务，
				因此，除非在java中添加多线程机制，否则任务并发的Java程序均无法一直到类似的平台上，
				就会打破"编写一次，到处运行"的要求；
				2.可以使你从线程分配层次抽身出来，即代码无需知道它是运行在具体一个还是多个cpu上。
				如果程序运行的太慢，为机器添加一个cpu就能很容易的加快程序的运行速度。
			并发编程注意：
				较早的jdk并不会频繁对时间切片，jdk5以后(可能)会有更好的时间切片行为。
				最好的编程方式是编写使用线程的代码时，尽可能保守，不依赖于线程的行为。
			注：
				java的线程机制基于来自c的低级的p线程方式。
	进程:
		正在运行的程序。（运行在它自己的地址空间内的自包容的程序。）
		一个程序至少有一个进程。那一程序如何拥有多个进程了！
		
	线程:
		1.java中线程是程序执行流的最小单元。
		2.进程由多个线程构成，每个进程至少存在一个线程。
		3.线程可以利用进程所拥有的资源，
		在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位
		
		4.线程可以驱动任务。
			创建任务后，将线程附着到任务上，以使得该线程可以驱动任务。
			疑：一个程序可以切分为多个任务。那java的main主线程的任务是什么！
		多线程作用：
			同一时间进行多个任务的处理。
			1.提交各资源利用效率，处理耗时操作。
			2.避免任务阻塞，导致程序中止
			3.仿真系统
			线程好处：
				可以使你创建更加松散耦合的设计。否则你的代码各个部分就要显式地关注那些通常可以由线程处理的任务。
		线程数量限制：
			多任务系统对可用的线程数量的限制通常是较小的，可能数十或数百。
			这个数字在程序控制范围外可能会发生变化，它可能依赖于平台，如java中，依赖于java的版本。
			
		协作式多线程：
			在协作式系统中，每个任务都会自动地放弃控制，这要求程序员要有意识地在每个任务中插入某种类型的让步语句。
			协作式系统的优势是双重的，上下文切换的开销通常比抢占式系统要低廉许多，并且对可以同时执行的线程数量在理论上没有任何限制。
			当你处理大量的仿真元素时,这可以一种理想的解决方案。
			java能实现协作式系统的效果吗？
			
		多线程的上下文切换：
			指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。
	线程安全：
		https://blog.csdn.net/sophia__yu/article/details/82563110
		进程中的线程共享了进程的虚拟地址空间，因此线程间通信将变得更加简单。
		但是缺点也随之而来：缺乏数据的访问控制容易造成数据混乱（因为大家都在争抢访问公共资源）。
		我们把能够造成数据混乱的情况总结成两个比较经典的模型，他们都是描述了多个进程/线程之间在数据访问时所应该保持的关系，不至于造成数据混乱和逻辑混乱。 
		生产者和消费者模型。
		读写者模型。

	死锁：
		双方在等待对方的释放锁才能完成自己的任务。
		a，b都在工作，
		a等b完成任务释放锁给我才能完成任务。
		b等a完成任务释放锁给我才能完成任务。
	乐观锁和悲观锁：？
	线程的生命周期：
		介绍：
			Java中任何对象都有生命周期，当对象创建完成时生命周期就开始了。
		线程生命周期：
			线程生命周期阶段划分：
				新建状态（New），就绪状态（Runnable）,运行状态（Running）,阻塞状态（Blocked）,死亡状态（Terminated）。
				不同的状态表明了线程当前正在进行的活动。
			新建状态：
				创建一个线程对象后（即new后），该线程对象就处于新建状态。
				仅仅由jvm为其分配了内存，没有表现出任何线程的动态特征。
			就绪状态：
				当线程对象调用start()后，该线程就进入就绪状态（或叫可运行状态）。
				此时线程位于可运行池中，具备了可运行条件，能否运行得等待系统的调度。
			运行状态：
				如果处于就绪状态的线程获得cpu使用权，则开始执行run()中的线程执行体，该线程就处于运行状态。
				注：
					1.一个线程不可能一直处于运行状态（除非线程执行体够短一下子执行完），
					因为当线程使用完系统分配的时间后就会被剥夺占用的cpu资源，让其余线程获得执行机会。
					2.只有处于就绪状态的线程才可能转换到运行状态。
			阻塞状态：
				正在执行的线程在某些情况下会失去cpu的使用权，进入阻塞状态。
				此时线程不能进入排队队列，只有引起阻塞的原因消除后才能转入就绪状态。
				例：
					耗时的输入输出操作。
				java实现线程阻塞：？
					sleep() suspend()和resume() yield()  
					 wait() 和 notify() ：
						为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用？
				Java唤醒一个阻塞的线程:
					如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；
					如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
				任务进入阻塞状态原因：
					1)通过调用slep(milliseconds)使任务进入休眠状态。
					在这种情况下，任务在指定的时间内不会运行。
					2)你通过调用wait()使线程挂起。
					直到线程得到了notify()或notifyAll()消息(或者在JavaSE5的java.util.concurrent类库中等价的signal()或signalAll()消息)，线程才会进入就绪状态。我们将在稍后的小节中验证这-一点。
					3)任务在等待某个输入输出完成。
					4)任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。
					注：
						在较早的代码中,也可能会看到用suspend()和resume()来阻塞和唤醒线程,
						但是在现代Java中这些方法被废止了(因为可能导致死锁)。
						stop()方法也已经被废止了，因为它不释放线程获得的锁，
						并且如果线程处于不一致的状态(受损状态)，其他任务可以在这种状态下浏览并修改它们。这样所产生的问题是微妙而难以被发现的。

					
			死亡状态:
				线程的run()方法中代码正常执行完毕，或者线程抛出一个未捕获的异常或错误，线程则进入死亡状态，线程结束。
	线程的调度：
		线程调度的两种模式：
			分时调度模型：
			抢占式调度模型：（JVM默认采用）
				让可运行池中优先级高的线程优先占用cpu。
		优先级：
			介绍：
				线程的优先级将该线程的重要性传递给了调度器。
				尽管CPU处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先权最高的线程先执行。
				然而，这并不是意味着优先权较低的线程将得不到执行(也就是说，优先权不会导致死锁)。优先级较低的线程仅仅是执行的频率较低。
			例：
				看有道云
			注：
				1.优先级设置需操作系统的支持，因此多线程程序的功能实现不能依赖于线程的优先级，
				只能把优先级作为一种提高效率的手段。
				2.在绝大多数时间里，所有线程都应该以默认的优先级运行。
				试图操纵线程优先级通常是一种错误。
				3.尽管JDK有10个优先级，但它与多数操作系统都不能映射得很好。
				比如，Windows有7个优先级且不是固定的。 
				唯一可移植的方法是当调整优先级的时候，只使用Thread的MAX_ PRIORITY、 NORM_ PRIORITY和MIN_ PRIORITY三种级别。
		
	monitor对象监视器:？
		Monitor是在jvm底层实现的，底层代码是c++。Java中的每个对象都有一个监视器，来监测并发代码的重入。
		Monitor是实现Sychronized的基础。
		如果对象在非多线程编码时该监视器不发挥作用，反之如果对象在synchronized 范围内，监视器发挥作用。
		...
		怎么检测一个线程是否持有对象监视器？
什么时候使用多线程开发?
	1.耗时操作时使用多线程
	2.对于公共资源
		优先使用并发容器而非同步容器.
		优先使用volatile
使用多线程建议：
    给线程命名！
    最小化同步范围
控制任务的执行顺序：！
	如果你必须控制任务执行的顺序,那么最好的押宝就是使用同步控制,
	或者在某些情况下，压根不使用线程，但是要编写自己的协作例程，这些例程将会按照指定的顺序在互相之间传递控制权。

	