共享资源：
	使用了并发后，多个线程彼此干涉的问题就产生了。例：两线程同时改变同一个值，同时访问一打印机等。
	可以使用同步（给定时刻只有一个线程能对其进行操作）来解决临界区的问题。
	也可使用线程本地存储解决共享资源问题。
同步：
	介绍：
		1. java中可通过人为的控制和调度，实现同步效果（给定时刻只有一个线程能对其进行操作）来解决共享资源的访问问题，保证共享资源的多线程访问成为线程安全，来保证结果的准确。
		2. 同步的实现方案有：隐式锁synchronized，显示锁Lock，变量同步volatile
		附：
			什么是互斥量机制：（同步也称为互斥量机制）
				基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。
				这意味着在给定时刻只允许一个任务访问共享资源。
				通常这是通过在代码前面加上一条锁语句来实现的，这就使得在一段时间内只有一个任务可以运行这段代码。
				因为锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量(mutex)。
	隐式锁synchronized：（java关键字synchronized实现同步）
		java编程思想p677
		介绍：
			Java提供关键字synchronized，为防止资源冲突提供了内置支持。
			synchronized能加在方法或者代码段上。
			当线程要执行被synchronized关键字保护的代码片段的时候，它将检查锁是否可用，如果可用则获取锁,执行代码后释放锁。
			如果不可用进入等待阻塞状态，在获取锁后进入可运行状态等待系统分配cpu资源。
				synchronized锁住一个对象后，别的线程如果也想拿到这个对象的锁，就必须等待这个线程执行完成释放锁。
			附：
				synchronized实现原理：
					介绍：
						所有对象都自动含有一个的锁(也称为监视器)。
							任何java对象，有且只有一个对象锁(或称为对象监视器)，但它可被同一线程多次获得，不同线程不行。
						synchronized同步实质上使用的是对象锁。
							当对象任意synchronized方法被调用的时候，此对象都被加锁，
							这时该对象上的所有synchronized方法（其余线程）调用只有等到前一个方法（当前线程）调用完毕，并释放了锁之后才能被调用。
						锁对象加锁过程：
							锁对象是同步代码块的关键，锁对象的标志位默认为1。
							当线程执行到同步代码块时，首先会检查锁对象的标志位，
							如果标志位大于0，标志位会减一（这里标志位就是0），当线程执行完同步代码块后，标志位会加一（这里标志位就会变为1）同时jvm会把锁随机分配给阻塞队伍中的一个线程。
							如果标志位小0则线程发生阻塞。
							附：
								一个任务可以多次获得对象的锁。如果一个方法在同一个对象上调用了第二个方法，后者又调用了同一对象上的另-一个方法，就会发生这种情况。JVM负责跟踪对象被加锁的次数。如果一个对象被解锁(即锁被完全释放)，其计数变为0。在任务第一次给对象加锁的时候，计数变为1。每当这个相同的任务在这个对象上获得锁时，计数都会递增。显然，只有首先获得了锁的任务才能允许继续获取多个锁。每当任务离开一个synchronized方法，计数递减，当计数为零的时候，锁被完全释放，此时别的任务就可以使用此资源。
					synchronized原理实现细节：
						https://blog.csdn.net/jinjiniao1/article/details/91546512
				synchronized通常称为重量级锁。?
					https://blog.csdn.net/jinjiniao1/article/details/91546512
					....
					synchronized多线程的同步即限制某资源在任一个时刻只能被一个线程访问，以保证数据的完整性。
					线程在执行同步代码时每次都会判断锁的状态，耗费资源效率低下。
					即：
						多了判断，只能一个，所以重量级。
		例：
			synchronized能加在方法或者代码段上。
			1.同步控制块（临界区）：
				介绍：
					只是希望防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。
					通过这种方式分离出来的代码段被称为临界区(critical section)，它也使用synchronized关键字建立。
					synchronized被用来指定某个对象，此对象的锁被用来对花括号内的代码进行同步控制。
					对象的锁拿来用，那么如果该对象内有多个临界区了：
						使用该方式或得synchronized块上的锁，那么该对象其他synchronized方法和临界区就不能被调用了。！
				例：
					public  void test() {
						synchronized(this){//this为要锁住的对象，如果某线程得到锁那可其他线程只有等到锁释放才能进入临界区。
							将处理共享资源的代码（或操作）放到一个代码块中
						}
					}
				注：
					1.通过同步控制块，而不是同步方法，可以使多个任务访问对象的时间性能得到（显著）提高。
			2.同步方法：
				public synchronized void test() {}
				注：
					1.同步方法也有锁，它的锁就是当前调用该方法的对象。
					2.synchronized关键字不属于方法特征签名组成部分，所以可以在覆盖方法的时候加上去。
					例：
						./案例/同步与通信/synchronized/
			3.静态方法同步：
				静态方法是可以并发的案例：
					./案例/静态方法并发/静态方法并发案例.txt
				静态方法同步：
					针对每个类，也有一个锁(作为类的Class对象的一部分);所以synchronized static方法可以在类的范围内防止对static数据的并发访问。
				注：
					1.静态同步方法的锁是该方法所在类的class对象。
			注：
				1.多个线程共享的锁对象必须是唯一的。
					例：
						锁对象的创建不能放在实现了Runnable接口的类的run（）方法中，
						否则每个线程运行到run()方法会新建一个锁对象，线程不能产生同步效果。！
				2.锁的对象总结：
					就是锁的是那个对象。
					同步控制块（临界区）：
						synchronized(被用来指定要锁住的对象,常为this){
						}
					同步方法：
						同步方法也有锁，它的锁就是当前调用该方法的对象。
					静态同步方法：
						静态同步方法的锁是该方法所在类的class对象。
					例：
						https://www.cnblogs.com/QQParadise/articles/5059824.html	
				3.
					在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突。???
		附：
			实际使用场景：
				共享资源一般是以对象形式存在的内存片段，但也可以是文件、输入/输出端口，或者是打印机。
				要控制对共享资源的访问，得先把它包装进一个对象。然后把所有要访问这个资源的方法标记为synchronized。
				那么在这个线程从该方法返回之前，其他所有要调用类中任何标记为synchronized方法的线程都会被阻塞。
				即每个访问临界共享资源的方法都必须同步，否则将无法正确工作。
			你应该什么时候应用同步呢：
				可以运用Brian的同步规则:
				1，如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步。
				2.如果在你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法。如果只同步一个方法， 那么其他方法将会随意地忽略这个对象锁，并可以在无任何惩罚的情况下被调用。
					还是有可能出错，如果锁的对象不是同一个了！
				3.这是很重要的一点: 每个访问临界共享资源的方法都必须被同步，否则它们就不会正确地工作。
			synchronized锁内部发生异常：
				synchronized锁在发生异常的时候会自动释放锁。
					附：要想不释放则要捕获异常，不让异常抛出。

		
	变量同步volatile:（java关键字volatile实现同步）
		https://www.jianshu.com/p/157279e6efdb
		介绍：
			volatile是Java提供的一种轻量级的同步机制。
			线程对volatile变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的“可见性”。
		附：
			volatile同步思想：
				Java内存模型告诉我们，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。
				那么线程在工作内存进行操作后何时会写到主内存中。
				这个时机对普通变量是没有规定的，
				而volatile修饰的变量java虚拟机则有特殊的约定，线程对volatile变量的修改会立刻被其他线程所感知，
				即不会出现数据脏读的现象，从而保证数据的“可见性”。
			线程对数据的处理过程:
				处理数据时，a线程会把值从主存(堆)load到本地栈(线程栈)，完成操作后再save回去。
				但如果a还未同步到主存中；此时线程B操作数据，观察到主存数据值未变，则使用了线程已经缓存的数据，
				此时就会出错。

			附：
				1.volatile关键字确保了应用中的可视性。
				如果你将一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。
				即便使用了本地缓存，情况也是如此，volatile域会立即被写人到主存中，而读取操作就发生在主存中。
				
				2.如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则，这个域就应该只能经由同步来访问。
				同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护,那就不必将其设置为是volatile的。
				3.
				针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（如另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。
				在线程安全的情况下加volatile会牺牲性能。
				当一个域的值依赖于它之前的值时，volatile就无法工作了。？
		例：
			volatile修饰变量：
				public static volatile int num = 0;
				当操作一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中去；且这个写会操作会导致其他线程中的缓存无效。
		
		
	显示锁Lock：（Lock对象实现同步）
		介绍：
			Java SE5 java.util.concurrent.locks中还提供了种显式的互斥机制，Lock对象。		
			Lock对象必须被显式地创建、锁定和释放。
				因此，它与内建的锁形式相比，代码缺乏优雅性。
			但对于解决某些类型的问题来说，它更加灵活。
				显示的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁，还赋予你给更细粒度的控制力。
				例：
					在使用synchronized关键字时，某些事物失败了，那么就会抛出一个异常。如果你不处理那么你没有机会去做任何清理工作，以维护系统使其处于良好状态。
					而显式的Lock对象，你就可以使用finally进行最后的清理。
					synchronized void m() {
						有个IO资源，如果后面发生异常，那么就将无法得到释放。
						int i = 1/0; //此处抛出异常，锁将被释放。要想不被释放，可以在这里进行catch
					}
					void m() {
						Lock lock=new ReentrantLock();
						lock.lock();//使用了lock和unlock创建了临界资源
						try {
							...
						} finally {
							lock.unlock();//释放锁
							io.close();//释放IO资源
						}
					}
			Lock接口的常见实现类有：ReentrantLock，ReentrantReadWriteLock。
		ReentrantLock可重入锁：
			Lock接口的一个实现类，使用频率很高的一个锁。
			一个线程已经获得了锁，其内部还可以多次申请该锁成功
			注：
				1.表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。
				2.ReentrantLock允许你尝试着获取但最终未获取的锁，这样如果其他人已经获取了这个锁，
				那你就可以决定离开去执行其他一些事情， 而不是等待直至这个锁被释放。
			例：
				./案例/同步与通信/lockTest.java
				void m() {
					Lock lock=new ReentrantLock();
					lock.lock();
					try {
						...
					} finally {
						lock.unlock();//使用了lock和unlock创建了临界资源
					}
				}
		附：
			lock对象锁住的也是monitor吗！
				不是，应该是对lock进行加锁。
线程本地存储：（线程本地存储解决共享资源问题）
	防止在共享资源上产生冲突的第二种方式是根除对变量的共享。
	线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。
	创建和管理线程本地存储可以使用ThreadLocal类。
	注：
		1.ThreadLocal对象通常当作静态域存储。
		2.ThreadLocal的方法保证不会出现竞争条件（即同步安全）。
	原理：
		./案例/同步与通信/线程本地存储
	例：
		./案例/同步与通信/线程本地存储
附：
	原子类:
		Java SE5引入了诸如AtomicInteger. AtomicLong. AtomicReference等特殊的原子性变量类。
		这些类被调整为可以使用在某些现代处理器上的可获得的，并且是在机器级别上的原子性。
		对于常规编程来说，它们很少会派上用场，但是在涉及性能调优时，它们就大有用武之地了。				


附：
	多线程关系：
		https://blog.csdn.net/sophia__yu/article/details/82563110
		进程中的线程共享了进程的虚拟地址空间，因此线程间通信将变得更加简单。
		但是缺点也随之而来：缺乏数据的访问控制容易造成数据混乱（因为大家都在争抢访问公共资源）。
		我们把能够造成数据混乱的情况总结成两个比较经典的模型.
			他们都是描述了多个进程/线程之间在数据访问时所应该保持的关系，不至于造成数据混乱和逻辑混乱。 
		生产者和消费者模型：
			1. 生产者与消费者模型
				一个场所,两个角色,三种关系
				●
					生产者与生产者之间的关系(都在抢着访问同一资源，如果需要实现安全访
					问，需要保持互斥关系) :互斥关系
				●
					生产者与消费者之间的关系(只有生产出来,才可以消费即时序制约) :同步
					+互斥关系(互斥是因为生产者生产完消费者才可以消费)
				● 消费者与消费者之间的关系:互斥来保证数据安全操作。

		读写者模型：
			

		死锁：
			双方在等待对方的释放锁才能完成自己的任务。
			a，b都在工作，
			a等b完成任务释放锁给我才能完成任务。
			b等a完成任务释放锁给我才能完成任务。
		乐观锁和悲观锁：？

