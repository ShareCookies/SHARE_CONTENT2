线程安全1：
	https://blog.csdn.net/sophia__yu/article/details/82563110
	进程中的线程共享了进程的虚拟地址空间，因此线程间通信将变得更加简单。
	但是缺点也随之而来：缺乏数据的访问控制容易造成数据混乱（因为大家都在争抢访问公共资源）。
	我们把能够造成数据混乱的情况总结成两个比较经典的模型，他们都是描述了多个进程/线程之间在数据访问时所应该保持的关系，不至于造成数据混乱和逻辑混乱。 
	生产者和消费者模型：
		
	读写者模型：
		

	死锁：
		双方在等待对方的释放锁才能完成自己的任务。
		a，b都在工作，
		a等b完成任务释放锁给我才能完成任务。
		b等a完成任务释放锁给我才能完成任务。
	乐观锁和悲观锁：？


共享资源：
	使用了并发后，多个线程彼此干涉的问题就产生了。
	例：两线程同时改变同一个值，同时访问一打印机等。
	同步：
		多线程的同步即限制某资源在任一个时刻只能被一个线程访问，以保证数据的完整性。
		https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/4855164
		java关键字synchronized实现同步：
			https://www.cnblogs.com/QQParadise/articles/5059824.html
			介绍：
				java中可通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。
				synchronized锁住一个对象后，别的线程如果也想拿到这个对象的锁，就必须等待这个线程执行完成释放锁。
				所以synchronized通常称为重量级锁。
				复杂版：
					Java以提供关键字synchronized的形式，为防止资源冲突提供了内置支持。
					当任务要执行被synchronized关键字保护的代码片段的时候，它将检查锁是否可用，然后获取锁,执行代码,释放锁。
					共享资源一般是以对象形式存在的内存片段，但也可以是文件、输入/输出端口，或者是打印机。
					要控制对共享资源的访问，得先把它包装进一个对象。然后把所有要访问这个资源的方法标记为synchronized。
					如果某个任务处于一个对标记为synchronized的方法的调用中，
					那么在这个线程从该方法返回之前，其他所有要调用类中任何标记为synchronized方法的线程都会被阻塞。
					即每个访问临界共享资源的方法都必须同步，否则将无法正确工作。
			案例：
				synchronized能加在方法或者代码段上。
				1.同步控制块（临界区）：
					介绍：
						只是希望防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。
						通过这种方式分离出来的代码段被称为临界区(critical section)，它也使用synchronized关键字建立。
						synchronized被用来指定某个对象，此对象的锁被用来对花括号内的代码进行同步控制。
						对象的锁拿来用，那么如果该对象内有多个临界区了：
							使用该方式或得synchronized块上的锁，那么该对象其他synchronized方法和临界区就不能被调用了。
					例：
						public  void test() {
							synchronized(this){//this为要锁住的对象，如果某线程得到锁那可其他线程只有等到锁释放才能进入临界区。
								将处理共享资源的代码（或操作）放到一个代码块中
							}
						}
					注：
						1.多个线程共享的锁对象必须是唯一的。
						例：
							锁对象的创建不能放在实现了Runnable接口的类的run（）方法中，
							否则每个线程运行到run()方法会新建一个锁对象，线程不能产生同步效果。？
						2.通过同步控制块，而不是同步方法，可以使多个任务访问对象的时间性能得到（显著）提高。
						锁对象也称为监视器！
				2.同步方法：
					public synchronized void test() {}
					注：
						1.同步方法也有锁，它的锁就是当前调用该方法的对象。
						2.静态同步方法的锁是该方法所在类的class对象。
						3.synchronized关键字不属于方法特征签名组成部分，所以可以在覆盖方法的时候加上去。
				锁对象：
					锁对象是同步代码块的关键，当线程执行到同步代码块时，首先会检查锁对象的标志位，如果标志位小0则线程发生阻塞。
					锁对象的标志位默认为1，当一个线程运行到同步代码块时，标志位会减一（这里标志位就是0），
					当线程执行完同步代码块后，标志位会加一（这里标志位就会变为1，后面的新线程才能执行同步代码块内容）。
				注：
					线程在执行同步代码时每次都会判断锁的状态，耗费资源效率低下。
			synchronized实现原理：
				synchronized块中的方法获取了对象的monitor....?

			
		java关键字volatile实现同步:
			介绍：
				volatile是Java提供的一种轻量级的同步机制。
				
				复杂版：
					1.volatile关键字还确保了应用中的可视性。如果你将一个域声明为volatile的，
					那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。
					即便使用了本地缓存，情况也是如此，volatile域会立即被写人到主存中，而读取操作就发生在主存中。
					
					2.如果多个任务在同时访问某个域，那么这个域就应该是volatile的，
					否则，这个域就应该只能经由同步来访问。
					同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护,那就不必将其设置为是volatile的。					
			volatile修饰变量：
				public static volatile int num = 0;
				当操作一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中去；
　　　　	且这个写会操作会导致其他线程中的缓存无效。
			线程对数据的处理过程:
				处理数据时，a线程会把值从主存(堆)load到本地栈(线程栈)，完成操作后再save回去。
				但如果a还未同步到主存中；此时线程B操作数据，观察到主存数据值未变，则使用了线程已经缓存的数据，
				此时就会出错。
			注:
				针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（如另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。
				在线程安全的情况下加volatile会牺牲性能。
				当一个域的值依赖于它之前的值时，volatile就无法工作了。？
		java类Lock实现同步：
			介绍：
				Lock对象必须被显式地创建、锁定和释放。因此，它与内建的锁形式相比，代码缺乏优雅性。
				但是，对于解决某些类型的问题来说，它更加灵活。
				显示的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁，还赋予你给更细粒度的控制力。
			Lock对象优势：
				尽管try-finally所需的代码比synchronized关键字要多,但是这也代表了显式的Lock对象的优点之一。
				如果在使用synchronized关键字时，某些事物失败了，那么就会抛出一个异常。
				但是你没有机会去做任何清理工作，以维护系统使其处于良好状态。
				有了显式的Lock对象，你就可以使用finally子句将系统维护在正确的状态了。
			ReentrantLock：
				Lock接口的一个类，使用频率很高的一个锁，ReentrantLock可重入锁。
				一个线程已经获得了锁，其内部还可以多次申请该锁成功
				注：
					1.表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。
					2.ReentrantLock允许你尝试着获取但最终未获取的锁，这样如果其他人已经获取了这个锁，
					那你就可以决定离开去执行其他一些事情， 而不是等待直至这个锁被释放。
			例：
				Lock lock=new ReentrantLock();
				lock.lock();
				
				try {
					...
				} finally {
					lock.unlock();//使用了lock和unlock创建了临界资源
				}
				
				lockTest.java
		线程本地存储：
			防止在共享资源上产生冲突的第二种方式是根除对变量的共享。
			线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。、
			创建和管理线程本地存储可以使用ThreadLocal类。
			注：
				1.ThreadLocal对象通常当作静态域存储。
				2.ThreadLocal的方法保证不会出现竞争条件（即同步安全）。

		注：
			使用并发时，将域设置为private是非常重要的，否则synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突。
			
		备注：
			互斥量：
				基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。
				这意味着在给定时刻只允许一个任务访问共享资源。
				通常这是通过在代码前面加上一条锁语句来实现的，这就使得在一段时间内只有一个任务可以运行这段代码。
				因为锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量(mutex)。
			原子类:
				Java SE5引入了诸如AtomicInteger. AtomicLong. AtomicReference等特殊的原子性变量类。
				这些类被调整为可以使用在某些现代处理器上的可获得的，并且是在机器级别上的原子性。
				对于常规编程来说，它们很少会派上用场，但是在涉及性能调优时，它们就大有用武之地了。				


线程安全2：
	生产者和消费者模型：
		
	读写者模型：
		

	死锁：
		双方在等待对方的释放锁才能完成自己的任务。
		a，b都在工作，
		a等b完成任务释放锁给我才能完成任务。
		b等a完成任务释放锁给我才能完成任务。
	乐观锁和悲观锁：？				