终结任务：
	1. 中断可以理解为线程的一个标识位属性,它表示一个运行中的线程是否被其他线程进行了中断操作。
	其他线程通过调用该线程的interrupt()方法对其进行中断操作。
		即把线程设置为中断状态
	2. 中断异常InterruptedException：
		sleep()会抛出中断异常了，是sleep的当前线程主动检测到被中断标识，清除标识然后抛出中断异常吗。
			抛出异常后此时调用isInterrupted()方法将会返回false。
		sleep()是本地方法 所以这异常会是Java虚拟机抛出的吗，还是本地c语言实现的
	3. 中断的响应
		线程在运行：被中断线程通过检查自身是否被中断(isInterrupted()方法等)来进行响应，或捕获中断异常，来结束线程。
		线程阻塞状态：
			被中断线程会立即退出阻塞状态！，且清除中断标识
			为什么会退出了，谁实现的了
				jvm实现的？
	结束任务方法（中断）：
		1.Thread.interrupt()
		例：
			./案例/终结任务/
		？
		2.executorService.awaitTermination()！
			当前线程阻塞，直到
				等所有已提交的任务（包括正在跑的和队列中等待的）执行完
				或者等超时时间到（那么已提交任务还会执行吗？）
				或者线程被中断，抛出InterruptedException
				然后返回true（所有任务在超时时间之前全部结束执行完毕）或false（已超时）
				shuntdown()和awaitTermination()效果差不多，方法执行之后，都要等到提交的任务全部执行完才停。
		3.executorService.shuntdownNow():
			在Executor上调用shutdownNow,那么它将发送一个interrupt调用给它启动的所有线程。
			这么做是有意义的，因为当你完成工程中的某个部分或者整个程序时，通常会希望同时关闭某个特定Executor的所有任务。
		4.future.cancel(true):
			使用Executor，有时也会希望只中断某个单一任务。
			那么通过调用submit()而不是executor()来启动任务，就可以持有该任务的上下文。
			submit()将返回一个泛型Future<?>,其中有一个未修饰的参数，因为你永远都不会在其上调用get(),持有这种Future的关键在于你可以在其上调用cancel(),并因此可以使用它来中断某个特定任务。
			当你将true传递给cancel(),那么它就会拥有在该线程上调用interrupt()以停止这个线程的权限。因此，cancel()是一种中断由Executor启动的单个线程的方式。
			例子：
				Future<?> f =exec.submit(runnable);//runnable任务要处于阻塞状态
				TimeUnit.MILLISECONDS.sleep(100);//延迟来确保任务处于阻塞
				f.cancel(true);
		
		附：
			1.新的concurrent类库似乎在避免对Thread对象的直接操作，转而尽量通过Executor来执行所有操作。
			2.无法中断正在试图获取synchronized锁或试图执行I/O的线程
			但可以用别的方式中断....？
	检测中断：
		interrupted()：
			检测线程是否已经中断，且清除中断状态。
			如果连续两次调用该方法，则第二次调用将放回false，因为中断状态在第一次已经清除掉。
		isInterrupted()：
			检测线程是否已经中断。不清除中断状态。
		例：
			Thread.interrupted();
			线程对象.isInterrupted();
	中断特殊阻塞：？
		
		无法中断正在试图获取synchronized锁或试图执行I/O的线程。
		
		中断试图执行I/O的线程：
			关闭任务上发生阻塞的底层资源。
			先把线程设为中断状态，
			再释放任务上发生阻塞的底层资源，来达到中断线程的目的。
			例：
				CloseResource.java
		中断互斥所阻塞的线程：		
			如果你尝试着在一个对象上调用其synchronized方法,而这个对象的锁已经被其他任务获得，那么调用任务将被挂起(阻塞)，直至这个锁可获得。
			但ReentrantLock上阻塞的任务可以被中断。
			例：
				InterruptMutex.java
				关键代码：
					private Lock lock=new ReentrantLock();
					lock.lock();//获取锁
					try {
						...
					} catch (Exception e) {
						// TODO: handle exception
						System.out.println("reentrantLock被中断或出现异常");
					}
		注：
			1.nio类提供了更人性化io中断，被阻塞的nio通道会自动响应中断。
			即设置线程为中断状态，nio就会自动响应中断。
	附：
		1.任务的结束：退出run()方法即算任务结束。 
		2.被设计用来响应interrupt()的类通常要建立一种策略，来确保它将保持一致性。
		即中断发生后，某代码后要跟try-finally子句，使得无论run()如何退出，清理都会发生。
	附：
		过期的suspend()、resume()和stop()，线程的暂停、恢复和终止。
		不建议使用的原因主要有：
			以suspend()方法为例，在调用后，线程不会释放已经占有的资 源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。
			同样，stop()方法在终结 一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会， 因此会导致程序可能工作在不确定状态下。
		暂停和恢复操作可以用等待/通知机制来替代。
	？
		正常的中断，但不释放资源那么会被回收吗