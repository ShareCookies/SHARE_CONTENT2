ReentrantLock重入锁
介绍：
	Lock接口的一个实现类，使用频率很高的一个锁。
	在显示锁特性基础上，重入锁额外拥有两特性：
	1. 可重入
		顾名思义就是支持重进入的锁，它表示该锁能够支持同一个线程对资源的重复加锁。	
			即：线程获取锁之后，如果再次调用lock()方法，则该线程不会被自己所阻塞。
		附：
			1. synchronized关键字也支持可重入
			2. 可重入的意义在于何处：
				可重入降低了编程复杂性，如迭代，或方法调方法，等每个方法里都写了锁等场景。
			3. 可重入的实现：
				ReentrantLock源码分析.java goto：可重入实现
	2. 公平性
		介绍：
			重入锁还支持获取锁时的公平和非公平性选择。
			如果一个锁是公平的，先对锁进行获取的请求先被满足。反之，是不公平的。
				即：公平锁获取顺序就应该符合请求的绝对时间顺序，也就是FIFO
		例：
			new ReentrantLock(false);
			ReentrantLock默认构造函数是非公平锁。
			通过构造函数，能够控制锁是否是公平的。
		附：
			2. 公平与非公平获取锁的实现：
				ReentrantLock源码分析.java goto：公平与非公平获取锁的实现
			3. 公平与非公平获取锁的区别测试案例：
				pdf251
				附：
					优的具体原因，从源码分析：
						因为非公平会在lock时进行一次cas快速尝试，所以同一个线程往往会更优先cas成功。
			4. 公平锁优缺点：
				事实上，公平的锁机制往往没有非公平的效率高，但是，并不是任何场景都是以TPS作为 唯一的指标，
				公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。
			
例：可重入锁使用案例
	详：
		./例/ReentrantLockTest
	void m() {
		Lock lock=new ReentrantLock();
		lock.lock();
		try {
			...
		} finally {
			lock.unlock();//使用了lock和unlock创建了临界资源
		}
	}
附：
	使用ReentrantLock的时候一定要手动释放锁，并且加锁次数和释放次数要一样。
		多释放锁则会报IllegalMonitorStateException异常。
		少释放则会使对应线程一直持有锁，导致线程一直存活，且其余一直在等待队列。最终可能导致应用阻塞挂掉
		
		原理：
			ReentrantLock源码分析.java goto：为什么锁要最终释放



ReentrantLock实现思路:
	1. 加锁
		怎么加锁
			1. 快速cas改变状态，获取锁lock
			2. 失败则1.快速cas2.判断是否是同一线程tryAcquire-》nonfairTryAcquire
			2.1是则锁记录值增加
			2.2否则(最终)调用统一同步器方法：
				1. 构造节点放入同步队列addWaiter(Node.EXCLUSIVE)
				2. 循环获取锁状态acquireQueued，是否在队列头后面，在则cas获取锁，不在则挂起			
		为什么可重入
		公平和非公平
			tryAcquire-》fairTryAcquire
			公平和非公平区别：
			1. 非公平在lock时会尝试下cas。公平不会
			2. 进入tryAcquire后，则区别是
			在cas尝试时公平多了，当前节点是否有前驱节点的判断
			3. 后续都一样
	2. 解锁
		主要就是做了锁记录的递减。