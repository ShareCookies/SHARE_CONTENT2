5.3 重入锁
介绍：
	Lock接口的一个实现类，使用频率很高的一个锁。
	ReentrantLock(重入锁)拥有两特性：
	1. 可重入
		顾名思义就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。	
			即线程获取锁之后，如果再次调用lock()方法，则该线程不会被自己所阻塞。
		附：
			1. synchronized关键字也支持可重入
			2. 可重入的意义在于何处：
				可重入降低了编程复杂性，如迭代，或方法调方法，等每个方法里都写了锁等场景。
			3. 可重入的实现：
				ReentrantLock源码分析.java goto：可重入实现
	2. 公平性选择
		重入锁还支持获取锁时的公平和非公平性选择。
		如果一个锁是公平的，先对锁进行获取的请求先被满足。反之，是不公平的。
			即的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO
		附：
			ReentrantLock默认构造函数是非公平锁。
				通过构造函数，能够控制锁是否是公平的。
			
			公平与非公平获取锁的实现：
				ReentrantLock源码分析.java goto：公平与非公平获取锁的实现
			公平与非公平获取锁的区别测试案例：
				pdf251
			
			公平锁优缺点：
				事实上，公平的锁机制往往没有非公平的效率高，但是，并不是任何场景都是以TPS作为 唯一的指标，
				公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。
例：可重入锁使用案例
	utils/com.china.hcg.thread.study.lock.ReentrantLockTest
	void m() {
		Lock lock=new ReentrantLock();
		lock.lock();
		try {
			...
		} finally {
			lock.unlock();//使用了lock和unlock创建了临界资源
		}
	}
附：
	使用ReentrantLock的时候一定要手动释放锁，并且加锁次数和释放次数要一样。
		多释放锁则会报IllegalMonitorStateException异常。
		少释放则会使对应线程一直持有锁，导致线程一直存活，且其余一直在等待队列。最终可能导致应用阻塞挂掉
		
		原理：
			ReentrantLock源码分析.java goto：为什么锁要最终释放



