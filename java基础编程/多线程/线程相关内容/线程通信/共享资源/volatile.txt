volatile：
	变量通信缺陷：
		虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还是拥有一份拷贝，
		所以程序在执行过程中，一个线程看到的变量并不一定是最新的。 					
			？？？
				对于对象不是存的引用类型吗，这也会拷贝
	变量通信解决方案：
		关键字volatile可以用来修饰成员变量，它能保证数据的“可见性”。
		即任何线程对该变量的访问均需要 从共享内存中获取，
		而对它的改变必须同步刷新回共享内存。

		
	使用Volatile的原则：
		应用volatile变量的三个原则：

		（1）写入变量不依赖此变量的值，或者只有一个线程修改此变量
			例：
				所以volatile不能保证n++的正确。
				例：
					https://www.cnblogs.com/gaojunguangblog/p/4949114.html
				？
					原子操作此时就可配合volatile使用吧

		（2）变量的状态不需要与其它变量共同参与不变约束

		（3）访问变量不需要加锁
		附：
			避免重复应用volatile：
				如果一个域完全由synchronized方法或语句块来防护,那就不必将变量设置为volatile的。
				同步也会导致向主存中刷新。？
	volatile的使用案例：
		...
		https://blog.csdn.net/jinfeiteng2008/article/details/53423858
附：
	volatil原理：
		volatile的实现原理涉及2方面，1 jvm内存栈的处理 2 系统硬件层面的处理
		jvm线程对数据的处理过程：
			线程对数据的处理过程:
				java 的内存模型中每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。
				当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。
					？太大了也会拷过来吗
				即：
					处理数据时，a线程会把值从主存(堆)load到本地栈(线程栈)，完成操作后线程退出前任一时刻再save回去。

			volatile对jvm内存的影响：
				Java内存模型告诉我们，各个线程会将共享变量从主内存(堆)中拷贝到工作内存(线程栈)，然后执行引擎会基于工作内存中的数据进行操作处理。
				那么线程在工作内存进行操作后何时会写到主内存中，这个时机对普通变量是没有规定的，
				而volatile修饰的变量java虚拟机则有特殊的约定，线程对volatile变量的修改可以被其他线程所感知，保证了数据的“可见性”。
				即：
					volatile仅保证写完会立马放入内存。	
					操作前(读时)会从主存读取最新值。
					
		在硬件层面上Intel处理器是如何实现volatile的：
			让我们在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时，CPU会做什么事情。
			Java代码如下：
				instance = new Singleton(); // instance是volatile变量 
			转变成汇编代码，如下：
				0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp);
				有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架 构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情[1]。 
					1）将当前处理器缓存行的数据写回到系统内存。 
					2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。
					附：
						为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。
						如果对声明了volatile的 变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据 写回到系统内存。
						但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操 作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一 致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当 处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状 态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。
			
		？
			会有这种情况吗：同时都在++了，然后a先save到共享内存中了，b会整样了？。
			我猜写回前回判断，且只允许一个判断。
