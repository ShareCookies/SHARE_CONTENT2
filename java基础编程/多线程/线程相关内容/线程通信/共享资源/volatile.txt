volatile：
	变量通信：(变量通信缺陷)
		Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个 变量的拷贝
			（虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还是 可以拥有一份拷贝，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性）
		所以程序在执行过程中，一个线程看到的变量并不一定是最新的。
		
	 					
		？
			对于对象不是存的引用类型吗，这也会拷贝
		?
			拷贝的什么时候会跟新了，永远不更新吗
	volatile：(变量通信解决方案)
		关键字volatile可以用来修饰成员变量，它能保证数据的“可见性”。
		即任何线程对该变量的访问均需要 从共享内存中获取，
		而对它的改变必须同步刷新回共享内存。
		
		附：
			volatile 变量仅提供了线程的可见性，并不能保证线程安全性和原子性。
			
			附：
			锁提供了两种主要特性：
				互斥（mutual exclusion） 和可见性（visibility）。
				互斥：（安全性和原子性）
					即一次只允许一个线程持有某个特定的锁，这样一次就只有一个线程能够使用该共享数据。
				可见性：
					可见性确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的.
					如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。
			
			附：
			因此避免重复应用volatile：
				如果一个域完全由synchronized方法或语句块来防护,那就不必将变量设置为volatile的。
				同步也会导致向主存中刷新。


	例：
		//定义一个表示程序是否运行的成员变量
		boolean on=true;
		
		那么另一个线程可能 对它执行关闭动作（on=false），
		这里涉及多个线程对变量的访问，因此需要将其定义成为 volatile boolean on＝true，
		这样其他线程对它进行改变时，可以让所有线程感知到变化，因为所 有对on变量的访问和修改都需要以共享内存为准。
附：		
	Volatile的使用原则：
		应用volatile变量的三个原则：
		（1）写入变量不依赖此变量的值，或者只有一个线程修改此变量
			例：
				volatile不能保证n++的正确。
				https://www.cnblogs.com/gaojunguangblog/p/4949114.html
				分析：
					时间1：a线程读到7 b线程读到7
					时间2：a改为8 b改为8
					时间3：目的操作一次新增1，那这里操作了2次却只加1
		（2）变量的状态不需要与其它变量共同参与不变约束
			？是指不能这样吧 volatile b = a+1;
			因为a的值也是要读取的，但a可能在改，那么b就不与a+1形成不变约束了。
		总结：
			可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。
		（3）访问变量不需要加锁


？
	https://blog.csdn.net/jinfeiteng2008/article/details/53423858
附：
	volatil原理：？
		volatile的实现原理涉及2方面，1 jvm内存栈的处理 2 系统硬件层面的处理
		jvm线程对数据的处理过程：
			线程对数据的处理过程:
				java 的内存模型中每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。
				当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。
					？太大了也会拷过来吗
				即：
					处理数据时，a线程会把值从主存(堆)load到本地栈(线程栈)，完成操作后线程退出前任一时刻再save回去。

			volatile对jvm内存的影响：
				Java内存模型告诉我们，各个线程会将共享变量从主内存(堆)中拷贝到工作内存(线程栈)，然后执行引擎会基于工作内存中的数据进行操作处理。
				那么线程在工作内存进行操作后何时会写到主内存中，这个时机对普通变量是没有规定的，
				而volatile修饰的变量java虚拟机则有特殊的约定，线程对volatile变量的修改可以被其他线程所感知，保证了数据的“可见性”。
				即：
					volatile仅保证写完会立马放入内存。	
					操作前(读时)会从主存读取最新值。
					
		在硬件层面上Intel处理器是如何实现volatile的：
			让我们在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时，CPU会做什么事情。
			Java代码如下：
				instance = new Singleton(); // instance是volatile变量 
			转变成汇编代码，如下：
				0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp);
				有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架 构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情[1]。 
					1）将当前处理器缓存行的数据写回到系统内存。 
					2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。
					附：
						为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。
						如果对声明了volatile的 变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据 写回到系统内存。
						但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操 作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一 致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当 处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状 态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。
			
		？
			会有这种情况吗：同时都在++了，然后a先save到共享内存中了，b会整样了？。
			我猜写回前回判断，且只允许一个判断。
