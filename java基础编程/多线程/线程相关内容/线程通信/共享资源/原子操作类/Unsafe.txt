Compare and Swap：（CAS）
	https://www.jianshu.com/p/d4551df6e6b8
	介绍：
		1. CAS操作是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，
		而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。
		2. CAS实现需要3个值，一个当前内存值V、预期值A(旧值)、即将更新的值B，
		当且仅当内存值V和预期值A相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。
		
	附：
		循环CAS实现的基本思路就是循环进行CAS操作直到成功为止；
	
	Unsafe提供了3种CAS方法，分别是对int,long和Object的CAS操作：
		/**
		* 如果当前数值是expected，则原子的将Java变量更新成update
		* @return 如果更新成功则返回true 
		*/
		public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object update);

		public final native boolean compareAndSwapInt(Object o, long offset, int expected, int update);

		public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);
		cas本地方法实现思路是：
			方法会读取传入对象o在内存中偏移量为offset位置的值与期望值expected作比较。
			相等就把update值赋值给offset位置的值，方法返回true。
			不相等，就取消赋值，方法返回false。
				CAS的思想即比较并交换。用于保证并发时的无锁并发的安全性。	
			附.
				JVM中的CAS操作是利用了处理器提供的CMPXCHG指令实现的；
				CMPXCHG—比较并交换，此指令可以配合LOCK前缀使用，此时指令将以原子方式执行。
				
附：		
	java悲观乐观锁
		悲观锁: 	
			假定会发生并发冲突，即共享资源会被某个线程更改。所以当某个线程获取共享资源时，会阻止别的线程获取共享资源。
			也称独占锁或者互斥锁，例如java中的synchronized同步锁。
		乐观锁: 
			假设不会发生并发冲突,只有在最后更新共享资源的时候会判断一下在此期间有没有别的线程修改了这个共享资源。如果发生冲突就重试，直到没有冲突，更新成功。
			CAS就是一种乐观锁实现方式。
		悲观锁会阻塞其他线程。乐观锁不会阻塞其他线程，如果发生冲突，采用死循环的方式一直重试，直到更新成功。
			
附：
	Java中的Unsafe提供的其他功能？
		https://www.jianshu.com/p/db8dce09232d
		1. Java中的Unsafe类为我们提供了类似C++手动管理内存等能力，
		类中提供的3个本地方法allocateMemory、reallocateMemory、freeMemory分别用于分配内存，扩充内存和释放内存，与C语言中的3个方法对应。

		2. 可以定位对象某字段的内存位置，也可以修改对象的字段值，即使它是私有的；
		3. 
		挂起与恢复:将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。
		整个并发框架中对线程的挂起操作被封装在 LockSupport类中，LockSupport类中有各种版本park方法，但最终都调用了Unsafe.park()方法。

