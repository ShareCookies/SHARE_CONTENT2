synchronized实现原理：
	介绍：
		当线程要执行被synchronized关键字保护的代码片段的时候，它将都将检查对应对象的锁是否可用，
		如果可用则获取锁,执行代码后释放锁，
		如果不可用进入等待阻塞等状态，等待唤醒并分配锁，在获取锁后进入可运行状态等待系统分配cpu资源。
	
	1. 对象的锁：
		1. 锁的是那个对象：
			Java中的每一个对象都可以作为锁，synchronized不同的用法锁的对象也不同，
			具体表现为以下3种形式：
				对于普通同步方法，锁是当前实例对象。 ·
				对于静态同步方法，锁是当前类的Class对象。 ·
				对于同步方法块，锁是Synchonized括号里配置的对象。
				例：
					https://www.cnblogs.com/QQParadise/articles/5059824.html		
		2. 对象的锁到底存在哪里:
			简易来说锁存在对象的对象头里。
			但不同类型的锁，具体存放是有区别的，具体看锁对象加锁过程。
	2. 锁对象加锁过程：
		介绍：
			synchronized会导致竞争不到锁的线程进入阻塞状态，所以说它是java中一个重量级的同步操作，被称为重量级锁。
			为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁？，他们都属于乐观锁。
			所以synchronized，有些情况下它就并不那么重了。
			附：
				明确java线程切换的代价，是理解java中各种锁的优缺点的基础之一。
		锁是有不同类型的：
			无锁状态、偏向锁、轻量锁、重量锁。
			附：
				为线程上锁时，默认上的就是偏向锁。

			Java SE 1.6中锁一共有4种状态：
				级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。
				注：
				1. 这几个状态会随着竞争情况逐渐升级。
				2. 锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。
					附：这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。			
		不同类型加锁过程有不同：
			./锁实现原理(活动图).png
				https://www.processon.com/view/link/5b11f18ee4b001a14d262587
			无锁状态：
				就是没锁状态。
			偏向锁:
				goto:偏向、轻量、重量锁.txt#偏向锁
				???
					偏向锁cas操作不是一定失败吗？
					那cas意义在于何处，直接进入全局安全点进行偏向锁的判断撤销不就好了。
					就是cas(期望：null，现场2id，内存偏移量)
			轻量级锁:
				goto:偏向、轻量、重量锁.txt#轻量级锁
				
			重量锁：
				goto:偏向、轻量、重量锁.txt#重量锁
		
Java源码锁的(java本地方法)具体实现：
	？

附:
自旋锁
	何为自旋锁:
		自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。
	为何需要自旋锁:
		线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒显然对CPU来说苦不堪言。
		其实很多时候，锁状态只持续很短一段时间，为了这段短暂的光阴，频繁去阻塞和唤醒线程肯定不值得。因此自旋锁应运而生。
	自旋锁应用场景：
		自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。
锁消除
	何为锁消除：
		锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。
锁粗化
	何为锁租化：
		锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。
	为何需要锁租化：
		在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是 为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。
	锁租化比喻思考：
		举个例子，买门票进动物园。老师带一群小朋友去参观，验票员如果知道他们是个集体，就可以把他们看成一个整体（锁租化），一次性验票过，而不需要一个个找他们验票。








		
废：		
	从JVM规范中可以看到Synchonized在JVM里的实现原理。
	JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。
	代码块同步是使用monitorenter 和monitorexit指令实现的，
	而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。			
