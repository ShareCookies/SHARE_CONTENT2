前景：
	共享变量怎么通信：
		一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。
		前者是生产者，后者就是消费者，这种模 式隔离了“做什么”（what）和“怎么做”（How），在功能层面上实现了解耦，体系结构上具备了良 好的伸缩性。
		
	Java语言中可，让消费者线程不断地循环检查变量是否符合预期...实现类似的功能,但纯变量通信是却存在如下问题: 
		1）难以确保及时性。
			在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时 发现条件已经变化，也就是及时性难以保证。
		2）难以降低开销。
			如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现 条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。
	但是Java通过内置的等待/通知机制能够很好地解决 这个矛盾并实现所需的功能
等待/通知:
	介绍：
		等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类 java.lang.Object上。
		等待：
			wait()
				等待使线程等待在某一个对象上。
				只有等待另外线程的通知或被中断才会返回.
				注:
					1. 等待会释放所持有的对象的锁。故需要先获取到对象的锁才能调用等待
					2. 等待会使当前线程从运行态(RUNNING)进入等待状态(WAITING)。
					3.  中断返回会怎样，还是有机会运行还是直接退出线程了.
						答：
							等待状态，收到中断了，线程会从等待状态恢复，然后收到中断异常。
							如果此时有对中断异常捕获了，那么就可以继续往下走了。
						例：
							WaitNotifyForInterrupt.java
				例：
					WaitNotify.java
			wait(long)
				超时等待一段时间， 这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回
			wait(long, int)?
				对于超时时间更细粒度的控制，可以达到纳秒
		通知:
			notify()
				通知一个在对象上等待的线程.
				注:
					1. 
					notify()或notifyAll()方法调用后，等待线程不会立刻从等待状态中返回。
					需要调用notify()或 notifAll()的线程运行完然后释放对应的锁后，等待线程才返回。
					？
						应该是已经返回了，但是在阻塞状态 等待获取锁吧 ，待测
					2. 在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。	
				例：
					WaitNotify.java
			notifyAll()
				通知所有等待在该对象上的线程
				注:
					notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列？中，
					而notifyAll() 方法则是将等待队列中所有的线程全部移到同步队列.
					被移动的线程状态由WAITING变为 BLOCKED。
					然后等notify的线程释放锁后，它们开始竞争，只有获得锁的线程才能进入就绪状态；其余没获得锁进入BLOCKED阻塞

					例1：
						WaitNotify.java
						然后通过jps和jstack 命令就可看到等待WaitThread2是阻塞状态
					例2：
						如果本身就有线程在这个对象上阻塞的，是不是也参与竞争锁。
						答：是的。
						例：
							WaitNotifyForBlockedThereadCompeteMonitor.java
					
				
		附：
			1.使用wait()、notify()和notifyAll()时需要先对调用对象加锁。
			如果在没有拥有锁的情况下，调用等待通知方法会报java.lang.IllegalMonitorStateException异常。
			例：
				WaitNotifyForNotHasMonitor.java
等待/通知的经典范式：
	pdf197