阻塞式队列：
	https://www.cnblogs.com/aspirant/p/8657801.html
	介绍：
		什么是阻塞队列，即从队列中新增或获取数据时可能会被阻塞的队列。
		附：这里的阻塞主要是指：
			1. 满或空时会被阻塞：
				新增时如果队列满那么阻塞（新增线程）直到可插入，获取时空则阻塞直到有数据获取。
			2. 阻塞队列为什么是线程安全的:
				操作里加了lock对象来实现并发安全。
				lock对象下获取不到数据，就阻塞不释放吗？那别的线程也进不来啊，怎么继续最佳元素？即如何实现阻塞效果了？
	
BlockingQueue接口的核心方法：
	./BlockingQueue接口api.png
	附：
	　　1. 放入数据
	　　　　1. offer(anObject):
				表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.（本方法不阻塞当前执行方法的线程）；　　　　　　 
		 　2. offer(E o, long timeout, TimeUnit unit)：
				可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。
	　　　	3. put(anObject):
				把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.
	　　2. 获取数据
	　　　　1. poll(time):
				取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null;
	　　　　2. poll(long timeout, TimeUnit unit)：
				从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。
	　　　　3. take():
				取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入; 
	　　　　4. drainTo():
				一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。
JDK提供的阻塞队列：
	1. ArrayBlockingQueue
		介绍：
			基于数组实现的有界阻塞队列，在内部维护了一个定长数组 来当作队列。
			一个常用的阻塞队列。
		源码分析：
			ArrayBlockingQueue原理.txt
		附：
			读写无法同时并行：
				ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；
				按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。
				Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 
			默认情况下非公平性访问队列：
				ArrayBlockingQueue使用的是可重入锁实现的。
				默认情况下不保证线程公平的访问队列。
			如何使用数组当作队列：
				除了一个定长数组外，
				ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。

　　2. LinkedBlockingQueue
		介绍：
			一个由链表结构组成的有界阻塞队列。
			此队列的默认和最大长度为 Integer.MAX_VALUE。
			顺序：
				此队列按照先进先出的原则对元素进行排序。
		源码分析：
			LinkedBlockingQueue原理.txt
			附：
				读写锁如何分离：
					就是维护2个显示锁来分离读写方法。
　	4. PriorityBlockingQueue
		一个支持优先级排序的无界阻塞队列。
		优先级排序：
			1. 默认情况下元素采取自然顺序升序排列。
			2. 也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。
			3. 需要注意的是不能保证同优先级元素的顺序。
　	3. DelayQueue
		介绍：
			一个支持延时获取元素的无界阻塞队列。
			队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。 只有在延迟期满时才能从队列中提取元素。
		实现Delayed接口：
			pdf300
		附：
			DelayQueue应用场景：
				缓存系统的设计：
					可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。
				定时任务调度：
					使用DelayQueue保存当天将会执行的任务和执行时间，一旦从 DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。
　　	附：
			延时阻塞队列实现：
				pdf301
　　5. SynchronousQueue(同步阻塞队列)
	　 	
		介绍：
			SynchronousQueue是一个不存储元素的阻塞队列。
			每一个put操作必须等待一个take操作， 否则不能继续添加元素。
			
		附：
			默认情况下线程采用非公平性策略访问队列。
			使用以下构造方法 可以创建公平性访问的SynchronousQueue，如果设置为true，则等待的线程会采用先进先出的顺序访问队列。
		附：
			队列本身并不存储任何元素，非常适合传递性场景。
			类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。
			
			优略势：？SynchronousQueue的吞吐量高于 LinkedBlockingQueue和ArrayBlockingQueue。
				相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），
				如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。
	6. LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 ·
		介绍：
			LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。
			相对于其他阻 塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。


		（1）transfer方法 
			如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法 时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。
			如果没有消费者在等 待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返 回。
			
			transfer方法的关键代码：
				...
		（2）tryTransfer方法 
			tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。
			如果没有消费者等 待接收元素，则返回false。
			和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法 立即返回，而transfer方法是必须等到消费者消费了才返回。
			
			tryTransfer（E e，long timeout，TimeUnit unit）:
				试图把生产者传入 的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超 时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。				
		
	7. LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。
	
		LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。
		
		1. 所谓双向队列指的是可以 从队列的两端插入和移出元素。
		2. 双向队列因为多了一个操作队列的入口，在多线程同时入队 时，也就减少了一半的竞争。?
		3. 相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、 addLast、offerFirst、offerLast、peekFirst和peekLast等方法。
		
		注：
			1. 另外，插入方法add等同于addLast，移除方法remove等效于 removeFirst。
			2.？但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First 和Last后缀的方法更清楚。 
		附：
			在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。
			？另外，双向阻塞队列可以 运用在“工作窃取”模式中。