，而Java通过线程实现并发。 系统的基本调度单元就是线程，而Java的线程与系统的线程又可对应上！，所以Java线程也是系统的最小调度单位。
Java多线程编程主要步骤为  编写任务(callable 和 futuretask、runnable)，创建线程(把任务传递给线程)，启动线程(线程开始执行任务)。
# 线程体系知识的串联：

## 	介绍：

​		进程是运行在内存中的程序，是内存、端口等分配的最小单位。
​		线程是操作系统调度的最小单元，线程可用来实现并发执行任务(并发即同时执行多个任务)。

## 	线程的创建：

​		线程可以驱动任务，任务可通过Runnable接口、Callable接口来描述,然后通过thread来启动.

## 	线程的运行：
​		java程序从main线程运行，然后在main线程中进行其他线程的开辟。
​		main线程结束运行并不会使程序结束，而是所有用户线程结束应用才会结束，守护线程并不影响应用是否结束。(线程类型又分为用户线程和守护线程)
​		线程结束：
​			运行完线程中代码，线程就会结束，
​			*线程生命周期又划分为：
​				新建，
​					仅new还未start()，所以在jmap线程栈打印中是看不到的吧？
​				运行(可运行、运行中)，
​				阻塞，
​				等待，
​					wait notice
​				超时等待
​					wait(long)
​					sleep

## 	并发中的线程：

​		线程并发后互相间协作方式又主要有：
​			线程调度：
​				中断、sleep、thread.join()、
​			线程通信：
​				等待 通知、
​				资源共享：
​					synchronized隐式锁
​						偏向锁 轻量
​							原理 对象头存储线程id
​						重量锁
​							原理 通过monitorenter指令获取monitor
​					volatile
​						仅能保证变量的可见性
​					线程本地存储
​						消除对变量的共享
​						就是把变量存在线程上，不推荐使用，因为线程上threadMap是弱键 所以存储数据很可能被回收掉
​					显示锁
​						主要有：可重入锁、可重入读写锁。
​						而显示锁的实现则是依赖了同步器，
​						队列同步器：
​							同步器是java为显示锁开发者提供的工具，依赖该工具可以快速的开发显示锁。
​							同步器主要提供：锁获取等待队列、同步状态获取与释放方法。
​							获取到同步状态即获取到了锁。why？
​						可重入读写锁实现：
​							可重入读写锁虽然持有2个锁 读锁与写锁，但其实它们2个都是应用同一个同步器来实现的。
​							写锁的排它和读锁的共享 则是用同步器的共享式同步状态获取和独占式同步状态获取来实现。
​				并发容器
​					阻塞队列、并发链表队列、并发hashmap
​					像阻塞队列里的锁就是用显示锁来实现的
​		线程并发的优化：
​			线程池:持有几个线程实例并复用它们。
​			通常通过线程池执行器(ThreadPoolExecutor)来实例化一个线程池.
​				其主要参数，核心线程、最大线程、空闲线程存活时间、空闲线程存活单位、任务队列、线程池工厂、拒接策略
​			注：如果局部线程池使用完一定要关闭。