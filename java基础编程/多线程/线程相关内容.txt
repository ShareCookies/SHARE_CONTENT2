线程相关内容介绍:
	java采用线程机制来实现并发。
	线程机制：
		1.线程机制是在单一进程中创建多个线程来执行任务。
			一个任务中由一个线程来驱动执行。
		java程序是从主线程开始运行的。
			即java程序是从main()开始的，main()被分配了个线程，称为主线程。
			在主线程中可创建线程，称为子线程。
	附：
		1. java程序进程由多个线程构成，每个进程至少存在一个线程。所以java中线程是程序执行流的最小调度单元。
		2. 线程可以利用进程所拥有的资源。
			进程由线程+内存数据存储空间构成，线程由极小的栈空间+...组成，线程间共享进程的存储空间(堆等)。
	附：
		多线程作用：(并发好处)
			同一时间进行多个任务的处理。
			1.提交各资源利用效率，处理耗时操作。
			2.避免任务阻塞，导致程序中止
			3.仿真系统
			松耦合设计：
				可以使你创建更加松散耦合的设计。
				否则你的代码各个部分就要显式地关注那些通常可以由线程处理的任务。
		线程数量限制：！!
			多任务系统对可用的线程数量的限制通常是较小的，可能数十或数百。
			这个数字在程序控制范围外可能会发生变化，它可能依赖于平台，如java中，依赖于java的版本。
	附：名词解释：	
			协作式多线程：
				在协作式系统中，每个任务都会自动地放弃控制，这要求程序员要有意识地在每个任务中插入某种类型的让步语句。
				协作式系统的优势是双重的，上下文切换的开销通常比抢占式系统要低廉许多，并且对可以同时执行的线程数量在理论上没有任何限制。
				当你处理大量的仿真元素时,这可以一种理想的解决方案。
				java能实现协作式系统的效果吗！
				
			多线程的上下文切换：
				指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。
	附：
	程序结束：
		1.对Java程序来说，一个进程只要还有一个用户线程在运行，那么进程就不会结束。
		如果一个进程只有后台线程运行，那么该进程就会结束。
			注：一个线程未进入死亡状态，垃圾回收器是无法清除它。
线程的生命周期：
	介绍：
		Java中任何对象都有生命周期，当对象创建完成时生命周期就开始了。
	线程生命周期：
		介绍：
			线程生命周期阶段能划分为：新建状态（New），就绪状态（Runnable）,运行状态（Running）,阻塞状态（Blocked）,死亡状态（Terminated）。
			不同的状态表明了线程当前正在进行的活动。
		新建状态（New）：
			创建一个线程对象后（即new后），该线程对象就处于新建状态。
			仅仅由jvm为其分配了内存，没有表现出任何线程的动态特征。
		就绪状态（Runnable）：
			当线程对象调用start()后，该线程就进入就绪状态（或叫可运行状态）。
			此时线程位于可运行池中，具备了可运行条件，能否运行得等待系统的调度。
		运行状态（Running）：
			如果处于就绪状态的线程获得cpu使用权，则开始执行run()中的线程执行体，该线程就处于运行状态。
			注：
				1.一个线程不可能一直处于运行状态（除非线程执行体够短一下子执行完），
				因为当线程使用完系统分配的时间后就会被剥夺占用的cpu资源，让其余线程获得执行机会。
				2.只有处于就绪状态的线程才可能转换到运行状态。
		阻塞状态（Blocked）：
			在线程运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态。
			有两种原因：1.java代码控制 2.jvm控制 3.操作系统自动控制的。
			例：
				例1.java代码控制
					java代码实现线程阻塞
					比如调用sleep()、wait()等之后线程就处于了阻塞状态。
					
					阻塞线程：
						Thread.sleep():	
							是一个静态方法。
							使一个线程从运行态进入阻塞状态（睡眠阻塞），不释放锁，指定时间后自动苏醒并返回到可运行状态。						
						object.wait():
							使一个线程从运行态进入阻塞状态（等待阻塞），并且释放所持有的对象的锁。
							这个时候需要其他机制（线程）将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。
							唤醒：
								
								notify():
									唤醒一个处于等待状态的线程.
									注:在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
								notifyAll():
									唤醒所有处于等待状态的线程。
									注:该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；！
									那没获得锁的是继续阻塞吗！
								例：
									NotifyVsNotifyaAll.java
								注：
									唤醒的线程不会立刻执行run方法，会进入排队队列(就绪状态)再次等待CPU分配资源然后进入运行状态;
							附：
								1.三个方法是Object类的方法，且调用者都应该是同步控制方法或同步控制块，否则JVM抛出IllegalMonitorStateException。
									即方法的调用者必须要有能获取对象锁的能力。
						Thread.join()：
							...
					附：
						LockSupport提供了park和unpark进行线程的挂起和恢复操作：
							https://blog.csdn.net/opensure/article/details/53349698?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control
					附：
						在较早的代码中,也可能会看到用suspend()和resume()来阻塞和唤醒线程,但是在现代Java中这些方法被废止了(因为可能导致死锁)。
						stop()方法也已经被废止了，因为它不释放线程获得的锁，
						并且如果线程处于不一致的状态(受损状态)，其他任务可以在这种状态下浏览并修改它们。这样所产生的问题是微妙而难以被发现的。
					

				
				例2.jvm控制
					准备执行同步方法或同步代码块时获取不到锁进入了等锁池。
						即：
						任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。
						直到线程获取到了想要的锁资源（那是谁把锁分给它了？等待过程线程是处于阻塞队列中？），进入Runnable状态；
					
					
					...:
						https://zhidao.baidu.com/question/370475099.html
						https://www.cnblogs.com/duanxz/p/3733179.html
						1.jvm来分配的，分配规则可能是随机可能按一定的规则来，看jvm的心情。2.处于一个对象锁的等待池中，此时整体上来讲也是blocked状态（也可叫waiting状态）
				例3.操作系统
					1.耗时的输入输出操作。
					...
					//正在执行的线程在某些情况下会失去cpu的使用权，进入阻塞状态。
					//错：此时线程不能进入排队队列，只有引起阻塞的原因消除后才能转入就绪状态。
					唤醒：
						如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
						
					2.任务在等待某个输入输出完成。
					附：
						是只针对线程的吗？
							应该是有系统决定的，可能线程可能进程吧。						
			WAITING？TIMED_WAITING ？		
		死亡状态（Terminated）:
			线程的run()方法中代码正常执行完毕，或者线程抛出一个未捕获的异常或错误，线程则进入死亡状态，线程结束。

线程调度：
	介绍：
		线程调度是指jvm按照特定机制为多个线程分配CPU的使用权。
			附：为什么要分配：
				例：计算机只有一个CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU的使用权才能执行指令。
				所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得CPU的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待CPU，JAVA虚拟机的一项任务就是负责线程的调度，
	线程调度模型：
		线程调度的两种模式：
			分时调度模型：
				所有线程轮流使用 CPU 的使用权，每个线程平均分配占用 CPU 的时间。
			抢占式调度模型：（JVM默认采用）
				让可运行池中优先级高的线程优先占用cpu。
			./案例/（线程调度器）MoreBasicThread.java
		优先级：
			介绍：
				线程的优先级将该线程的重要性传递给了调度器。
				尽管CPU处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先权最高的线程先执行。
				然而，这并不是意味着优先权较低的线程将得不到执行(也就是说，优先权不会导致死锁)。优先级较低的线程仅仅是执行的频率较低。
			例：
				./案例/SimplePriorities.java
			注：
				1.优先级设置需操作系统的支持，因此多线程程序的功能实现不能依赖于线程的优先级，
				只能把优先级作为一种提高效率的手段。
				2.在绝大多数时间里，所有线程都应该以默认的优先级运行。
				试图操纵线程优先级通常是一种错误。
				3.尽管JDK有10个优先级，但它与多数操作系统都不能映射得很好。
				比如，Windows有7个优先级且不是固定的。 
				唯一可移植的方法是当调整优先级的时候，只使用Thread的MAX_ PRIORITY、 NORM_ PRIORITY和MIN_ PRIORITY三种级别。
	线程调度相关的方法：
		wait()、sleep()、notify()、notityAll()
		goto: ./线程相关内容.txt > 线程的生命周期 > 阻塞状态 > java代码控制
守护线程与用户线程:
	在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。
	用户线程：用户线程即创建的普通线程
	守护线程：指程序运行的时候在后台提供通用服务的线程。
		注：
			1. 只要当前JVM实例中尚存在任何一个用户线程没有结束，守护线程就全部工作；只有当最后用户线程结束时，守护线程随着JVM一同结束工作。
				？
					守护线程依赖于创建它的线程，而用户线程则不依赖。
					是全部结束守护线程才结束吗。
			2. 守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。
				自己设置：
					例：
						./案例/Daemon/
						Thread daemon=new Thread(new Task());
						daemon.setDaemon(true);//must call before start()
						daemon.start();
					注：
						1. thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。
						即你不能把正在运行的常规线程设置为守护线程。
						2. 在Daemon线程中产生的新线程也是Daemon的。
				jvm提供：
					在JVM中，像垃圾收集器线程就是守护线程。
	附：
		1. 守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作的中间发生中断。
		2. Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。
