线程相关内容介绍:
	1.java中线程是程序执行流的最小单元。
	2.进程由多个线程构成，每个进程至少存在一个线程。
	3.线程可以利用进程所拥有的资源，
	在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位
	
	4.线程可以驱动任务。
		创建任务后，将线程附着到任务上，以使得该线程可以驱动任务。
		疑：一个程序可以切分为多个任务。那java的main主线程的任务是什么！
	多线程作用：
		同一时间进行多个任务的处理。
		1.提交各资源利用效率，处理耗时操作。
		2.避免任务阻塞，导致程序中止
		3.仿真系统
		线程好处：
			可以使你创建更加松散耦合的设计。否则你的代码各个部分就要显式地关注那些通常可以由线程处理的任务。
	线程数量限制：
		多任务系统对可用的线程数量的限制通常是较小的，可能数十或数百。
		这个数字在程序控制范围外可能会发生变化，它可能依赖于平台，如java中，依赖于java的版本。
		
	协作式多线程：
		在协作式系统中，每个任务都会自动地放弃控制，这要求程序员要有意识地在每个任务中插入某种类型的让步语句。
		协作式系统的优势是双重的，上下文切换的开销通常比抢占式系统要低廉许多，并且对可以同时执行的线程数量在理论上没有任何限制。
		当你处理大量的仿真元素时,这可以一种理想的解决方案。
		java能实现协作式系统的效果吗？
		
	多线程的上下文切换：
		指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。
线程的生命周期：
	介绍：
		Java中任何对象都有生命周期，当对象创建完成时生命周期就开始了。
	线程生命周期：
		介绍：
			线程生命周期阶段能划分为：新建状态（New），就绪状态（Runnable）,运行状态（Running）,阻塞状态（Blocked）,死亡状态（Terminated）。
			不同的状态表明了线程当前正在进行的活动。
		新建状态（New）：
			创建一个线程对象后（即new后），该线程对象就处于新建状态。
			仅仅由jvm为其分配了内存，没有表现出任何线程的动态特征。
		就绪状态（Runnable）：
			当线程对象调用start()后，该线程就进入就绪状态（或叫可运行状态）。
			此时线程位于可运行池中，具备了可运行条件，能否运行得等待系统的调度。
		运行状态（Running）：
			如果处于就绪状态的线程获得cpu使用权，则开始执行run()中的线程执行体，该线程就处于运行状态。
			注：
				1.一个线程不可能一直处于运行状态（除非线程执行体够短一下子执行完），
				因为当线程使用完系统分配的时间后就会被剥夺占用的cpu资源，让其余线程获得执行机会。
				2.只有处于就绪状态的线程才可能转换到运行状态。
		阻塞状态（Blocked）：
			在线程运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态。
			有两种原因：1.java代码控制 2.操作系统自动控制的。
			例：
				例1.java代码控制
					java代码实现线程阻塞
					比如调用sleep()、wait()等之后线程就处于了阻塞状态。
					
					唤醒：
						唤醒的线程不会立刻执行run方法，会进入排队队列，再次等待CPU分配资源进入运行状态;
						1)通过调用sleep(milliseconds)使任务进入休眠状态。
							在这种情况下，任务在指定的时间内不会运行。
						2)你通过调用wait()使线程挂起。
							这个时候需要其他机制（线程）将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。
							线程才会进入就绪状态。
					附：
						在较早的代码中,也可能会看到用suspend()和resume()来阻塞和唤醒线程,但是在现代Java中这些方法被废止了(因为可能导致死锁)。
						stop()方法也已经被废止了，因为它不释放线程获得的锁，
						并且如果线程处于不一致的状态(受损状态)，其他任务可以在这种状态下浏览并修改它们。这样所产生的问题是微妙而难以被发现的。
					Object.wait():
						拥有锁的情况下(在synchronized里)，从运行态进入阻塞态，释放锁
					Object.notify() | Object.notifyAll():
					
					被唤醒的线程从阻塞态进入就绪态。?

						notify():
							唤醒一个处于等待状态的线程.
							注:在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
						notifyAll():
							唤醒所有处于等待状态的线程。
							注:该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；！
					Thread.sleep():		
						线程休眠(从运行态（拥有锁）进入阻塞态（什么类型阻塞？TIMED_WAITING）)指定时间后自动苏醒（不释放锁），并返回到可运行状态(不是运行状态)。
					Thread.yield():
						拥有锁的情况下，从运行态进入就绪态，不释放锁
					Thread.join()：
						是由一个线程调用另一个线程，调用线程等待被调用线程终止(即主线程由运行态进入阻塞态)。
				例2.操作系统
					耗时的输入输出操作。
					...
					//正在执行的线程在某些情况下会失去cpu的使用权，进入阻塞状态。
					//错：此时线程不能进入排队队列，只有引起阻塞的原因消除后才能转入就绪状态。
					唤醒：
						如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
					3)任务在等待某个输入输出完成。
				例3.jvm控制
					任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。
					直到线程获取到了想要的锁资源（那是谁把锁分给它了？等待过程线程是处于阻塞队列中？），进入Runnable状态；			
					
					
					...:
						https://zhidao.baidu.com/question/370475099.html
						https://www.cnblogs.com/duanxz/p/3733179.html
						1.jvm来分配的，分配规则可能是随机可能按一定的规则来，看jvm的心情。2.处于一个对象锁的等待池中，此时整体上来讲也是blocked状态（也可叫waiting状态）
						
			WAITING？TIMED_WAITING ？		
		死亡状态（Terminated）:
			线程的run()方法中代码正常执行完毕，或者线程抛出一个未捕获的异常或错误，线程则进入死亡状态，线程结束。
线程的调度：
	线程调度的两种模式：
		分时调度模型：
		抢占式调度模型：（JVM默认采用）
			让可运行池中优先级高的线程优先占用cpu。
		./案例/（线程调度器）MoreBasicThread.java
	优先级：
		介绍：
			线程的优先级将该线程的重要性传递给了调度器。
			尽管CPU处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先权最高的线程先执行。
			然而，这并不是意味着优先权较低的线程将得不到执行(也就是说，优先权不会导致死锁)。优先级较低的线程仅仅是执行的频率较低。
		例：
			./案例/SimplePriorities.java
		注：
			1.优先级设置需操作系统的支持，因此多线程程序的功能实现不能依赖于线程的优先级，
			只能把优先级作为一种提高效率的手段。
			2.在绝大多数时间里，所有线程都应该以默认的优先级运行。
			试图操纵线程优先级通常是一种错误。
			3.尽管JDK有10个优先级，但它与多数操作系统都不能映射得很好。
			比如，Windows有7个优先级且不是固定的。 
			唯一可移植的方法是当调整优先级的时候，只使用Thread的MAX_ PRIORITY、 NORM_ PRIORITY和MIN_ PRIORITY三种级别。