线程相关内容介绍:
	1.java中线程是程序执行流的最小单元。
	2.进程由多个线程构成，每个进程至少存在一个线程。
	3.线程可以利用进程所拥有的资源，
	在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位
	
	4.线程可以驱动任务。
		创建任务后，将线程附着到任务上，以使得该线程可以驱动任务。
		疑：一个程序可以切分为多个任务。那java的main主线程的任务是什么！
	多线程作用：
		同一时间进行多个任务的处理。
		1.提交各资源利用效率，处理耗时操作。
		2.避免任务阻塞，导致程序中止
		3.仿真系统
		线程好处：
			可以使你创建更加松散耦合的设计。否则你的代码各个部分就要显式地关注那些通常可以由线程处理的任务。
	线程数量限制：
		多任务系统对可用的线程数量的限制通常是较小的，可能数十或数百。
		这个数字在程序控制范围外可能会发生变化，它可能依赖于平台，如java中，依赖于java的版本。
		
	协作式多线程：
		在协作式系统中，每个任务都会自动地放弃控制，这要求程序员要有意识地在每个任务中插入某种类型的让步语句。
		协作式系统的优势是双重的，上下文切换的开销通常比抢占式系统要低廉许多，并且对可以同时执行的线程数量在理论上没有任何限制。
		当你处理大量的仿真元素时,这可以一种理想的解决方案。
		java能实现协作式系统的效果吗？
		
	多线程的上下文切换：
		指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。
线程的生命周期：
	介绍：
		Java中任何对象都有生命周期，当对象创建完成时生命周期就开始了。
	线程生命周期：
		线程生命周期阶段划分：
			新建状态（New），就绪状态（Runnable）,运行状态（Running）,阻塞状态（Blocked）,死亡状态（Terminated）。
			不同的状态表明了线程当前正在进行的活动。
		新建状态：
			创建一个线程对象后（即new后），该线程对象就处于新建状态。
			仅仅由jvm为其分配了内存，没有表现出任何线程的动态特征。
		就绪状态：
			当线程对象调用start()后，该线程就进入就绪状态（或叫可运行状态）。
			此时线程位于可运行池中，具备了可运行条件，能否运行得等待系统的调度。
		运行状态：
			如果处于就绪状态的线程获得cpu使用权，则开始执行run()中的线程执行体，该线程就处于运行状态。
			注：
				1.一个线程不可能一直处于运行状态（除非线程执行体够短一下子执行完），
				因为当线程使用完系统分配的时间后就会被剥夺占用的cpu资源，让其余线程获得执行机会。
				2.只有处于就绪状态的线程才可能转换到运行状态。
		阻塞状态：
			正在执行的线程在某些情况下会失去cpu的使用权，进入阻塞状态。
			此时线程不能进入排队队列，只有引起阻塞的原因消除后才能转入就绪状态。
			例：
				耗时的输入输出操作。
			java实现线程阻塞：？
				sleep() suspend()和resume() yield()  
				 wait() 和 notify() ：
					为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用？
			Java唤醒一个阻塞的线程:
				如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；
				如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
			任务进入阻塞状态原因：
				1)通过调用slep(milliseconds)使任务进入休眠状态。
				在这种情况下，任务在指定的时间内不会运行。
				2)你通过调用wait()使线程挂起。
				直到线程得到了notify()或notifyAll()消息(或者在JavaSE5的java.util.concurrent类库中等价的signal()或signalAll()消息)，线程才会进入就绪状态。我们将在稍后的小节中验证这-一点。
				3)任务在等待某个输入输出完成。
				4)任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。
				注：
					在较早的代码中,也可能会看到用suspend()和resume()来阻塞和唤醒线程,
					但是在现代Java中这些方法被废止了(因为可能导致死锁)。
					stop()方法也已经被废止了，因为它不释放线程获得的锁，
					并且如果线程处于不一致的状态(受损状态)，其他任务可以在这种状态下浏览并修改它们。这样所产生的问题是微妙而难以被发现的。

				
		死亡状态:
			线程的run()方法中代码正常执行完毕，或者线程抛出一个未捕获的异常或错误，线程则进入死亡状态，线程结束。
线程的调度：
	线程调度的两种模式：
		分时调度模型：
		抢占式调度模型：（JVM默认采用）
			让可运行池中优先级高的线程优先占用cpu。
		./案例/（线程调度器）MoreBasicThread.java
	优先级：
		介绍：
			线程的优先级将该线程的重要性传递给了调度器。
			尽管CPU处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先权最高的线程先执行。
			然而，这并不是意味着优先权较低的线程将得不到执行(也就是说，优先权不会导致死锁)。优先级较低的线程仅仅是执行的频率较低。
		例：
			./案例/SimplePriorities.java
		注：
			1.优先级设置需操作系统的支持，因此多线程程序的功能实现不能依赖于线程的优先级，
			只能把优先级作为一种提高效率的手段。
			2.在绝大多数时间里，所有线程都应该以默认的优先级运行。
			试图操纵线程优先级通常是一种错误。
			3.尽管JDK有10个优先级，但它与多数操作系统都不能映射得很好。
			比如，Windows有7个优先级且不是固定的。 
			唯一可移植的方法是当调整优先级的时候，只使用Thread的MAX_ PRIORITY、 NORM_ PRIORITY和MIN_ PRIORITY三种级别。