https://www.cnblogs.com/superfj/p/7544971.html
https://blog.csdn.net/weixin_40304387/article/details/80508236
https://www.cnblogs.com/fengsehng/p/6048610.html
介绍：
	为什么要有线程池：
		多线程的异步执行方式，虽然能够最大限度发挥多核计算机的计算能力。但是如果不加控制，反而会对系统造成负担。
			大量的线程会占用内存资源并且可能会导致Out of Memory。
		线程的创建本身也耗费资源。
			大量的线程回收也会给GC带来很大的压力。
	什么是线程池：
		线程池的出现让线程可进行复用。
			线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。
	
Executor框架（执行器框架，我称为线程池框架）：
	Java 5引入了Executor框架，来简化并发编程的操作。
	Executor框架的内容包括：
		线程池规范接口：
			Executor接口
		Executor框架提供的线程池实现类：（通过该类可以创建线程池）
			ThreadPoolExecutor类
		线程池工具类：
			Executors，工厂方法类，通过该类可以快速创建线程池。
		等
	
	Executor（接口）：
		介绍：（建议看源码注释来理解。）
			线程池规范接口（解耦接口）。
			让用户可以仅通过execute(Runnable command)就可让线程池执行所提交的Runnable任务，
			使用户从线程的创建、线程池的复杂调用（使用）等中脱身出来。
			附：
				通常Executor的实现类，其内部都实现线程池机制。
				所以一旦Runnable任务传递到execute()方法，该方法便会自动将一任务放到一个线程上执行。
				goto：ThreadPoolExecutor
			附：
				比较Executor和new Thread()
				new Thread的弊端如下：
					a. 每次new Thread新建对象性能差。
					b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。
					c. 缺乏更多功能，如定时执行、定期执行、线程中断。
					相比new Thread，Java提供的四种线程池的好处在于：
					a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。
					b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。
					c. 提供定时执行、定期执行、单线程、并发数控制等功能。
	ExecutorService（接口，继承了Executor接口）：
		介绍：
			ExecutorService一个比Executor使用更广泛的子类接口，提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况的方法。
			ExecutorService的生命周期包括三种状态：？
				运行、关闭、终止。
				创建后便进入运行状态。
				当调用了shutdown（）方法时，便进入关闭状态。
				调用了shutdown，且当前已经提交了的任务执行完后，便到达终止状态。
				hcg：
					可将对象的运行，进行阶段划分，就是生命周期。
			
		方法：
			submit(Callable task):
				Callable异步任务可用ExecutorService的submit(Callable task) 方法来执行并跟踪。
			shutdown()：
				方法在终止前允许执行以前提交的任务。即线程将在，Executor中的任务完成之后，尽快退出
			shutdownNow()：
				方法阻止等待任务启动并试图停止当前正在执行的任务。
			<T> Future<T> submit(Callable<T> task);
			<T> Future<T> submit(Runnable task, T result);
			...
	Executors（工厂方法类）：
		介绍：
			Executors静态工厂方法类提供了一系列工厂方法用于快速创建线程池，
			内部其实还是使用了ThreadPoolExecutor来创建线程池。
		Executors提供的四种常见线程池的创建方法：
			1、public static ExecutorService newFiexedThreadPool(int Threads) 
				创建固定数目线程的线程池。
			2、public static ExecutorService newCachedThreadPool()：
				创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果没有可用的线程，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。
			3、public static ExecutorService newSingleThreadExecutor()：
				创建一个单线程化的Executor。
			4、public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
				创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。
			例：
				ExecutorService exe= Executors.newFixedThreadPool(10);//创建一个拥有10个线程的线程池。
				exe.execute(new Task());
			例2：
				./案例/线程池/
		附：
			阿里巴巴开发手册：
				【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 
				说明：Executors 返回的线程池对象的弊端如下： 1）FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 2）CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。
	ThreadPoolExecutor：（ExecutorService的实现类）
		介绍：
			Executor接口的实现类，通过该类可以快速的创建一个线程池。
			用户可以通过类的execute(Runnable command)就可让线程池执行所提交的Runnable任务。
		构造方法参数介绍：
			corePoolSize：线程池中所保存的核心线程数，包括空闲线程。
			maximumPoolSize：池中允许的最大线程数。
			keepAliveTime：线程池中的空闲线程所能持续的最长时间。
			unit：持续时间的单位。
			workQueue：任务执行前保存任务的队列，仅保存由execute方法提交的Runnable任务。
		例：
			自定义线程池：
				通过ThreadPoolExecutor类可以快速创建自定义的线程池。
				
				例：
					./案例/线程池/自定义线程池executor.txt
		附：
			1.任何线程池中，现有线程在可能的情况下都会被自动复用。
			2.阿里为什么不允许使用Executors：
				https://www.cnblogs.com/ants/p/11343657.html
				1.当线程中有问题出现时，用自定义的线程池可以便于根据线程名查找异常在哪，而Executors创建的线程池不行。
				2.Executors创建的线程池都各有各的限制和问题
		
			执行器框架原理：
				ThreadPoolExecutor实现了一个线程池。
				其内部维护着一个容器存放线程（BlockingQueue<Runnable> workQueue）。
				用户可通过execute(Runnable)等方法让线程池中的一个线程执行任务。
附：
为什么使用线程池：
	线程池的作用是重用已有线程，

	public void test(){
		//那么如果我是在一个方法里，创建了线程池
		//且只执行一个任务
		//那么我觉得线程池是没什么意义的，因为我认为线程池创建的时候是一次性预先创建所需的线程的！
		// 注1：如果是执行大量任务，还是有意义的，可以复用线程。
		// 注2：如何这个方法会并发了，那么你不久一次性要创建多个线程了，要考虑到这个情况。
		// 所以推荐，在类属性上等就创建好线程池
	}
线程池与@Async相比！