https://www.cnblogs.com/superfj/p/7544971.html
https://blog.csdn.net/weixin_40304387/article/details/80508236
https://www.cnblogs.com/fengsehng/p/6048610.html
前言：
	多线程的异步执行方式，虽然能够最大限度发挥多核计算机的计算能力。
	但是如果不加控制，反而会对系统造成负担。
		大量的线程会占用内存资源并且可能会导致Out of Memory。
		即便没有这样的情况，大量的线程回收也会给GC带来很大的压力。
	为了避免重复的创建线程，线程池的出现让线程可进行复用。
Executor框架（执行器框架）：
	Java 5引入了Executor框架，来简化并发编程的操作。
	Executor框架的内容包括：线程池机制，Executor接口，ExecutorService接口，Executors，CompletionService等。
	附：
		执行器框架原理：
			框架内部维护着一个线程池，这个线程池中维护者一定数量的线程。
			所以执行器框架能够直接通过方法驱动任务，还是通过线程来着，只是中间省略线程相关步骤。
		线程池：
			当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。
			线程池的出现可以让线程进行复用，避免了重复的创建线程。

	Executor（接口）：
		介绍：（建议看源码注释来理解。）
			解耦接口，用户可以仅通过execute()来执行所提交的Runnable任务，使用户从线程的创建等中脱身出来。
			附：
				通常Executor的实现类，其内部都实现线程池机制。
				所以一旦Runnable任务传递到execute()方法，该方法便会自动将一任务放到一个线程上执行。

			附：
				比较Executor和new Thread()
				new Thread的弊端如下：
					a. 每次new Thread新建对象性能差。
					b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。
					c. 缺乏更多功能，如定时执行、定期执行、线程中断。
					相比new Thread，Java提供的四种线程池的好处在于：
					a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。
					b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。
					c. 提供定时执行、定期执行、单线程、并发数控制等功能。
	ExecutorService（接口，继承了Executor接口）：
		介绍：
			ExecutorService一个比Executor使用更广泛的子类接口，提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况的方法。
			ExecutorService的生命周期包括三种状态：
				运行、关闭、终止。
				创建后便进入运行状态。
				当调用了shutdown（）方法时，便进入关闭状态。
				调用了shutdown，且当前已经提交了的任务执行完后，便到达终止状态。
				hcg：
					可将对象的运行，进行阶段划分，就是生命周期。
			
		方法：
			submit(Callable task):
				Callable异步任务可用ExecutorService的submit(Callable task) 方法来执行并跟踪。
			shutdown()：
				方法在终止前允许执行以前提交的任务。即线程将在，Executor中的任务完成之后，尽快退出
			shutdownNow()：
				方法阻止等待任务启动并试图停止当前正在执行的任务。
			<T> Future<T> submit(Callable<T> task);
			<T> Future<T> submit(Runnable task, T result);
			...
	Executors（工厂方法类）：
		介绍：
			Executors类提供了一系列工厂方法用于创建线程池。
			其工厂方法返回的excutor都实现了ExecutorService接口。
		Executors提供的四种常见线程池的创建方法：
			1、public static ExecutorService newFiexedThreadPool(int Threads) 
				创建固定数目线程的线程池。
			2、public static ExecutorService newCachedThreadPool()：
				创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果没有可用的线程，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。
			3、public static ExecutorService newSingleThreadExecutor()：
				创建一个单线程化的Executor。
			4、public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
				创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。
			例：
				ExecutorService exe= Executors.newFixedThreadPool(10);//创建一个拥有10个线程的线程池。
				exe.execute(new Task());
			例2：
				./案例/线程池/
		附：
			阿里巴巴开发手册：
				【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 
				说明：Executors 返回的线程池对象的弊端如下： 1）FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 2）CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。
	自定义线程池：
		通过ThreadPoolExecutor类可以快速创建自定义的线程池。
		构造方法参数介绍：
			corePoolSize：线程池中所保存的核心线程数，包括空闲线程。
			maximumPoolSize：池中允许的最大线程数。
			keepAliveTime：线程池中的空闲线程所能持续的最长时间。
			unit：持续时间的单位。
			workQueue：任务执行前保存任务的队列，仅保存由execute方法提交的Runnable任务。
		例：
			./案例/线程池/自定义线程池executor.txt
	注：
		任何线程池中，现有线程在可能的情况下都会被自动复用。！
		ThreadPoolExecutor是什么了？
			https://www.cnblogs.com/ants/p/11343657.html
附：
为什么使用线程池：
	线程池的作用是重用已有线程，

	public void test(){
		//那么如果我是在一个方法里，创建了线程池
		//且只执行一个任务
		//那么我觉得线程池是没什么意义的，因为我认为线程池创建的时候是一次性预先创建所需的线程的！
		// 注1：如果是执行大量任务，还是有意义的，可以复用线程。
		// 注2：如何这个方法会并发了，那么你不久一次性要创建多个线程了，要考虑到这个情况。
		// 所以推荐，在类属性上等就创建好线程池
	}
线程池与@Async相比？