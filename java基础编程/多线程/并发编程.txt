并发编程：(多线程)
	https://blog.csdn.net/qq_34365173/article/details/105133794
	线程之间需要进行通信，通信有数据共享和线程协作两种方式。
	共享资源：
		摘要：
			java线程间共享了堆资源，并发后如果多个线程同时访问同一变量，将产生彼此干涉的问题。
			解决方案：
				1. 使用线程同步来问题。(内置锁对象，lock锁对象,volatile变量同步)
				2. 也使用线程本地存储解决共享资源问题。(线程本地存储)
		具体：
			./共享资源.txt
	线程协作（线程通信）：
		
		介绍：
			线程协作，是使多个任务一起工作去解决某个问题。
			
			协作方式：
				比如说最经典的生产者-消费者模型：
					
				

			?线程的协作关键问题是任务之间的握手，可使用互斥或挂起来实现握手。
				互斥：确保只有一个任务可以响应某个信号。
				挂起：直至某些外部条件发生变化后任务才可继续。
		等待/通知模式：
			synchronized：
				在使用Lock之前，我们使用的最多的同步方式应该是synchronized关键字来实现同步方式了。配合Object的wait()、notify()系列方法可以实现等待/通知模式。
			
			Lock与Condition：
				Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。
				使用lock显示的实现了同步后，要想实现线程之间通信要使用Conditon对象。
				例：
					https://www.cnblogs.com/gemine/p/9039012.html
					1. condition对象是依赖于lock对象的。
						意思就是说condition对象需要通过lock对象进行创建出来(调用Lock对象的newCondition()方法)。
					2. 一个condition对象的signal 方法和该对象的await方法是一一对应的，
						也就是一个condition对象的signal（signalAll）方法不能唤醒其他condition对象的await方法。
					private Lock lock=new ReentrantLock();
					private Condition condition=lock.newCondition();
					private Condition condition2=lock.newCondition();
					condition.await();
					condition.signal();
					condition2.await();
					condition2.signal();
			附：
				应用场景：磁盘读取指令的数据未返回，搭配同步队列应用等。

		同步队列：
			同步队列在任何时刻都只允许一个任务插入或移除元素。所以使用同步队列解决任务协作问题更好。
			./同步队列.txt
		线程协作方式：（线程协作模型）（多线程关系）
			模型实现会应用到等待/通知模式，和同步队列。
			生产者-消费者模型：
				当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。
					因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。
				同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。
				这种互相通信的过程就是线程间的协作。
				例：
					https://www.cnblogs.com/dolphin0520/p/3920385.html
			读写者模型：
				为了维持生产者与消费者模型中提到的关系，来解决数据安全访问操作,因此提
				出了同步与互斥，同步就是为了解决时序问题，互斥就是为了解决唯一访问性问题
				解决线程的安全问题实际就是映射模型中的关系来解决

附：
	多线程关系：
		https://blog.csdn.net/sophia__yu/article/details/82563110
		进程中的线程共享了进程的虚拟地址空间，因此线程间通信将变得更加简单。
		但是缺点也随之而来：缺乏数据的访问控制容易造成数据混乱（因为大家都在争抢访问公共资源）。
		我们把能够造成数据混乱的情况总结成两个比较经典的模型.
			他们都是描述了多个进程/线程之间在数据访问时所应该保持的关系，不至于造成数据混乱和逻辑混乱。 
		生产者和消费者模型：
			1. 生产者与消费者模型
				一个场所,两个角色,
				三种关系
					1. 生产者与生产者之间的关系(都在抢着访问同一资源，如果需要实现安全访问，需要保持互斥关系) :互斥关系
					2. 生产者与消费者之间的关系(只有生产出来,才可以消费即时序制约) :同步+互斥关系(互斥是因为生产者生产完消费者才可以消费)
					3. 消费者与消费者之间的关系:互斥来保证数据安全操作。
		
		死锁：
			双方在等待对方的释放锁才能完成自己的任务。
			a，b都在工作，
			a等b完成任务释放锁给我才能完成任务。
			b等a完成任务释放锁给我才能完成任务。
		乐观锁和悲观锁：？
			悲观锁：阻塞队列
			乐观锁：非阻塞队列