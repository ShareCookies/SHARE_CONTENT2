为什么要通信：
	多个线程相互配合完成工作，能实现更强大的功能，能进一步的利用现有资源提高效能。
共享资源：
	共享资源：
		java线程间共享了堆资源，即支持多个线程访问同一个对象或者对象的成员变量。
	共享资源缺陷：
		java线程间共享了堆资源,使用了并发后，多个线程彼此干涉的问题就产生了。
			例：两线程同时改变同一个值，同时访问一打印机等。
		解决方案：
			1. 可以使用同步来解决临界区的问题：
				线程同步：
					即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作.
					1. 隐式锁synchronized。
					2. 显示锁Lock对象。
			附：
				volatile：
					./volatile.txt
				ThreadLocal：
					也可使用线程本地存储解决共享资源问题。
					./ThreadLocal.txt
	synchronized:
		./synchronized.txt


	附：
		原子类:
			Java SE5引入了诸如AtomicInteger. AtomicLong. AtomicReference等特殊的原子性变量类。
			这些类被调整为可以使用在某些现代处理器上的可获得的，并且是在机器级别上的原子性。
			对于常规编程来说，它们很少会派上用场，但是在涉及性能调优时，它们就大有用武之地了。	

			原子操作实现原理：
				...
		
		CountDownLatch
			CountDownLatch 是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。
等待/通知:
	线程之间如何互相调用进行写作。
	./等待、通知机制.txt
