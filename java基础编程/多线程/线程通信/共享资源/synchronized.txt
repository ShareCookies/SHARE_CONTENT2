synchronized：
	介绍：
		使用关键字synchronized修饰方法或加在代码段上，就能保证方法或者代码块以同步方式执行.
			附：因为是Java为防止资源冲突提供的内置支持，使用起来非常简单。
		附：
			java同步指：
				即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作.
			同步实现思路：
				当一个线程试图访问同步代码块时，它首先必须得到锁(没得到则阻塞)，退出或抛出异常时必须释放锁。
	使用案例：
		synchronized能加在方法或者代码段上。
		1.同步控制块（临界区）：
			介绍：
				该方式用于防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。
				通过这种方式分离出来的代码段被称为临界区(critical section)。
				注：
					1. 临界区synchronized要指定锁住那个对象。该对象的锁就会被用来实现对指定代码段的同步控制。
					2. 对象的锁拿来用，那么如果该对象内有多个临界区了：
						使用该方式获得指定对象的锁，那么该对象其他synchronized方法和临界区就不能同时被调用了。
						例：
							...!
			例：
				public  void test() {
					synchronized(this){//this为要锁住的对象.//如果某线程得到this对象锁，其他线程只有等到锁释放才能进入临界区。
						将处理共享资源的代码（或操作）放到一个代码块中
					}
				}
			注：
				1.通过同步控制块，而不是同步方法，可以使多个任务访问对象的时间性能得到（显著）提高。
		2.同步方法：
			public synchronized void test() {}
			注：
				1.同步方法也有锁，它的锁就是当前调用该方法的对象。
				2.synchronized关键字不属于方法特征签名组成部分，所以可以在覆盖方法的时候加上去。
				例：
					../案例/同步与通信/synchronized/
		3.静态方法同步：
			类也有对象(class)，所以其也有锁。
			注：
				1.静态同步方法的锁是该方法所在类的class对象。
			附：
				静态同步方法可以在类的范围内防止对static数据的并发访问。
			废：
				静态方法是可以并发的案例：
					../案例/静态方法并发/静态方法并发案例.txt
				方法调用原理：
					？
	注：
		持有synchronized锁期间，发生异常的时候，锁会自动释锁。
			附：要想不释放则要捕获异常，不让异常抛出。
	附：
		1.多个线程共享的锁对象必须要同一个：
			例：
				锁对象的创建不能放在实现了Runnable接口的类的run（）方法中，
				否则每个线程运行到run()方法会新建一个锁对象，线程不能产生同步效果。
		？
			在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突。
			？没啊，我将方法设为public，其他任务访问还是要求有锁才能进来啊。
	附：
		文件、打印机：
			共享资源一般是以对象形式存在的内存片段，但也可以是文件、输入/输出端口，或者是打印机。
			要控制对共享资源的访问，得先把它包装进一个对象。然后把所有要访问这个资源的方法标记为synchronized。
			那么在这个线程从该方法返回之前，其他所有要调用类中任何标记为synchronized方法的线程都会被阻塞。
			即每个访问临界共享资源的方法都必须同步，否则将无法正确工作。
		你应该什么时候应用同步呢：
			可以运用Brian的同步规则:
			1，如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步。
			2.如果在你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法。如果只同步一个方法， 那么其他方法将会随意地忽略这个对象锁，并可以在无任何惩罚的情况下被调用。
				还是有可能出错，如果锁的对象不是同一个了！
			3.这是很重要的一点: 每个访问临界共享资源的方法都必须被同步，否则它们就不会正确地工作。

synchronized实现原理：
	介绍：
		当线程要执行被synchronized关键字保护的代码片段的时候，它将都将检查对应对象的锁是否可用，
		如果可用则获取锁,执行代码后释放锁，
		如果不可用进入等待阻塞等状态，等待jvm唤醒并分配锁，在获取锁后进入可运行状态等待系统分配cpu资源。
	
	1. 对象的锁到底存在哪里：
		1. 锁存在对象的对象头里。
		2. 锁的是那个对象：
			Java中的每一个对象都可以作为锁，synchronized不同的用法锁的对象也不同，
			具体表现为以下3种形式：
				对于普通同步方法，锁是当前实例对象。 ·
				对于静态同步方法，锁是当前类的Class对象。 ·
				对于同步方法块，锁是Synchonized括号里配置的对象。
				例：
					https://www.cnblogs.com/QQParadise/articles/5059824.html	
	2. 锁对象加锁过程：
		锁是有不同类型的：
			无锁状态、偏向锁、轻量锁、重量锁
		不同类型加锁过程有不同：
			无锁状态：
				？
			偏向锁:
				goto:偏向锁和轻量级锁
				偏向锁把线程id存对象头中,同线程可进入，不同则异常升级为轻量级锁。
			轻量级锁:
				goto:偏向锁和轻量级锁
				....
			重量锁：
				任何对象都有 一个monitor对象(监视器)与之关联，当且一个monitor被持有后，它将处于锁定状态。
				这时该对象上的所有synchronized方法（其余线程）调用只有等到前一个方法（当前线程）调用完毕，并释放了锁之后才能被调用。
				附：
					任何java对象，有且只有一个对象锁(或称为对象监视器)，但它可被同一线程多次获得，不同线程不行。
				monitor对象加锁过程：？
					锁对象的标志位默认为1，当线程执行到同步代码块时，首先会检查锁对象的标志位，
					如果标志位大于0，标志位会减一（这里标志位就是0），当线程执行完同步代码块后，标志位会加一（这里标志位就会变为1）同时jvm会把锁随机分配给阻塞队伍中的一个线程。
					如果标志位小0则线程发生阻塞。
					附：
						任何java对象有且只有一个对象锁(或称为对象监视器)，但它可被同一线程多次获得
							如果一个方法在同一个对象上调用了第二个方法，后者又调用了同一对象上的另一个方法，就会发生这种情况。
						JVM负责跟踪对象被加锁的次数。
						如果一个对象被解锁(即锁被完全释放)，其计数变为0。
						在任务第一次给对象加锁的时候，计数变为1。每当这个相同的任务在这个对象上获得锁时，计数都会递增。显然，只有首先获得了锁的任务才能允许继续获取多个锁。每当任务离开一个synchronized方法，计数递减，当计数为零的时候，锁被完全释放，此时别的任务就可以使用此资源。
						？
							所以是加还是减了，前后有矛盾，应该进入是加，判断大于0则不让别的进入
				monitor对象又是什么了？monitor存在哪里了？
		附：
		不同类型加锁jvm具体是如何用代码实现了？
		
			从JVM规范中可以看到Synchonized在JVM里的实现原理。
			JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。
			代码块同步是使用monitorenter 和monitorexit指令实现的，
			而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。			
			monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结 束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。
			
			线程执行到monitorenter 指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。
			?
				线程执行到monitorenter 指令时，怎么决定使用那个类型锁了？
	
Java对象的内存布局:
	在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。
	附：
		实例变量：
			存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。
		填充数据：
			由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。
	

	Java对象头：pdf27
		Java对象头则是实现synchronized的锁对象的基础。
		synchronized用的锁相关信息是存在Java对象头里的。
		java对象头有两种类型：
			1. 对象是非数组类型，则用2字宽存储对象头。
				Mark Word (32 bits) Klass Word (32 bits)
			2. 对象是数组类型，则虚拟机用3个字宽 （Word）存储对象头
				Mark Word(32bits) Klass Word(32bits) array length(32bits)
			附：在32位虚拟机中，1字宽 等于4字节，即32bit。
		对象头的组成：
		Mark Word：
			1. 32位JVM 的Mark Word的默认存储结构如表2-3所示：
				...pdf27
				Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。
			2. 在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。
				./附件/不同标记位下的MarkWord.png
				或...pdf27
			lock：
				2位的锁状态标记位。
				该标记的值不同，整个mark word表示的含义不同。
				附：
					lock标记，能够使Mark Word用尽可能少的二进制位表示尽可能多的信息。
			age：
				4位的Java对象年龄。
				在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因。？
			identity_hashcode：25位的对象标识Hash码。
				采用延迟加载技术。调用方法System.identityHashCode()计算，并会将结果写到该对象头中。
				当对象被锁定时，该值会移动到管程Monitor中。
				？
					偏向锁状态和轻量锁装态hashcode了
			thread：
				持有偏向锁的线程ID。
			ptr_to_lock_record：
				指向栈中锁记录的指针。

			ptr_to_heavyweight_monitor：
				指向monitor对象（也称为管程或监视器锁）的起始地址，每个对象都存在着一个monitor与之关联。
				附：
					对象与其monitor之间的关系有存在多种实现方式，如monitor对象可以与对象一起创建销毁或当前线程试图获取对象锁时自动生，但当一个monitor被某个线程持有后，它便处于锁定状态。
			...
			附：
				mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位，64位JVM为64位。
		附：
		class pointer
			这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。
			该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。
			附：指针的压缩！
				如果应用的对象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内存。为了节约内存可以使用选项+UseCompressedOops开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位：

				每个Class的属性指针（即静态变量）
				每个对象的属性指针（即对象变量）
				普通对象数组的每个元素指针
				当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等。

		array length
			如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度。
			附：
				这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。
				64位JVM如果开启+UseCompressedOops选项，该区域长度也将由64位压缩至32位。
偏向锁和轻量级锁:
	synchronized很多人都会称呼它为重量级锁。
	但是，随着Java SE 1.6对synchronized进行了各种优化之后，有些情况下它就并不那么重了。
	Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。
	所以Java SE 1.6中锁一共有4种状态：
		级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，
		这几个状态会随着竞争情况逐渐升级。
		锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。
			这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。
	
	
	偏向锁:
		HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同 一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

		偏向锁的初始化：
			图2-1中的线 程1演示了偏向锁初始化的流程:
				...pdf30
			当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出 同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。
			如果测试成功，表示线程已经获得了锁。
			如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则 使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
				？
					尝试使用CAS将对象头的偏向锁指向当前线程。
			?
				为线程上锁时，默认上的就是偏向锁
		偏向锁的撤销：
			偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。
			偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正 在执行的字节码）。
			它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着， 如果线程不处于活动状态，则将对象头设置成无锁状态；
			如果线程仍然活着，拥有偏向锁的栈 会被执行?，遍历偏向对象的锁记录?，栈中的锁记录和对象头的Mark Word要么重新偏向于其他 线程，要么恢复到无锁或者标记对象不适合作为偏向锁，
			最后唤醒暂停的线程。
			？
				这里的暂停指什么
			图2-1中 线程2演示了偏向锁撤销的流程：
				...pdf30
		附：
			关闭偏向锁：
				偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如 有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。
				如果你确定应用程 序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:- UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。
		？？？
			偏向锁什么时候会升级了:
				https://blog.csdn.net/weixin_28786193/article/details/115149874?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link
				锁会偏向于第一个执行它的线程，如果该锁后续没有其他线程访问过，那我们就不需要加锁直接执行即可。
				如果后续发现了有其它线程正在获取该锁，那么会根据之前获得锁的线程的状态来决定要么将锁重新偏向新的线程，
				要么撤销偏向锁升级为轻量级锁?。
				
				假如此时有另外一个线程线程 B 尝试获取该锁，去检查锁标志位发现未指向自己，然后 CAS 将 Mark Word 的 thread ID 指向自己，发现失败了，因为 thread ID 已经指向了线程 A ，那么此时就会去执行撤销偏向锁的操作了，会在一个全局安全点(没有字节码在执行)去暂停拥有偏向锁的线程(线程 A)，然后检查线程 A 的状态，那么此时线程 A 就有 2 种情况了。

				第一种情况
					线程 A 已经终止状态，那么将 Mark Word 的线程 ID 置位空后，CAS 将线程 ID 偏向线程 B 然后就又回到上述又是偏向锁线程的运行状态了
				第二种情况
					线程 A 处于活动状态，那么就会将偏向锁升级为轻量级锁，然后唤醒线程 A 执行完后续操作，线程 B 自旋获取轻量级锁。
					
				？
					升到轻量后，会立马升到重量吗


	轻量级锁:
		（1）轻量级锁加锁：
			线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。
			然后线程尝试使用 CAS将对象头中的Mark Word替换为指向锁记录的指针。
			如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
			？
				a已经获取到锁后，b锁此时来，复制对象头，此时a持有锁 那么b是会复制成功了？ 还是失败进入阻塞了？
				如果是阻塞，那么大量在阻塞了，和重量锁区别？
		（2）轻量级锁解锁：
			轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，
			如果成功，则表示没有竞争发生。
			如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。
				附：
					怎么判断是否失败了。
					如何释放失败了，替换回去不就好了吗。
					这两个都是系统的事，不这么实现，就没法升级锁，避免无用自旋
				？？？
					为什么叫轻量锁？
						是因为加锁速度快吗，即同步块执行快？
					与重量锁的差别主要在那，轻量级锁获取锁时不是也进行一些判断和操作？
						
					重量锁为什么重量了？
			附：轻量锁的升级
				即执行完代码后，释放轻量级锁，发现失败，就将所有指向该锁的线程升级为重量锁，
				无锁的线程阻塞，有锁的既然执行完代码了，那么释放锁，并唤醒阻塞线程，
				被唤醒的线程重现争夺锁访问同步块。
				附：为什么要升级和为什么升级了不下降：
					因为自旋会消耗CPU，为了避免无用的自旋，一旦锁升级 成重量级锁，就不会再恢复到轻量级锁状态。
					当锁处于重量级锁状态下，其他线程试图获取锁时， 都会被阻塞住，
					当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。
				？
					释放轻量锁时，有发现有人在自循环就会失败，然后就升级为重量锁，那就是有竞争就升级，那和偏向锁差别在哪？
			图2-2是 两个线程同时争夺锁，导致锁膨胀的流程图：
				...pdf32
锁的优缺点对比：
	pdf33
