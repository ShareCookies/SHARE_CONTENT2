偏向锁:
	HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同 一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。
	
	偏向锁是四种状态中最乐观的一种锁:
		即认为几乎从始至终只有一个线程请求某一把锁。
		附：
		所以优化也是主要从是否关闭偏向锁吗？？？
			https://blog.csdn.net/tone12345/article/details/110849240
			当时为什么要引入偏向锁：
				偏向锁是 HotSpot 虚拟机使用的一项优化技术，能够减少无竞争锁定时的开销。
				偏向锁的目的是假定 monitor 一直由某个特定线程持有，直到另一个线程尝试获取它，这样就可以避免获取 monitor 时执行 cas 的原子操作。
				monitor 首次锁定时偏向该线程，这样就可以避免同一对象的后续同步操作步骤需要原子指令。从历史上看，偏向锁使得 JVM 的性能得到了显著改善。


			为什么要废弃偏向锁：
				但是过去看到的性能提升，在现在看来已经不那么明显了。
				受益于偏向锁的应用程序，往往是使用了早期 Java 集合 API的程序（JDK 1.1），这些 API（Hasttable 和 Vector） 每次访问时都进行同步。
				JDK 1.2 引入了针对单线程场景的非同步集合（HashMap 和 ArrayList）
				JDK 1.5 针对多线程场景推出了性能更高的并发数据结构。
				这意味着如果代码更新为使用较新的类，由于不必要同步而禁用偏向锁的应用程序，可能会看到很大的性能提高。
				此外，围绕线程池队列和工作线程构建的应用程序，性能通常在禁用偏向锁的情况下变得更好。？

				偏向锁为同步系统引入了许多复杂的代码，并且对 HotSpot 的其他组件产生了影响。这种复杂性已经成为理解代码的障碍，也阻碍了对同步系统进行重构。因此，我们希望禁用、废弃并最终删除偏向锁。

	偏向锁的获得和撤销流程图：
		https://blog.csdn.net/sophia__yu/article/details/84104542
		偏向锁的获得和撤销流程图2.png
		（偏向锁竞争，全局安全点 线程1存活那一部分我认为不准确，goto：偏向锁什么时候会升级了）
		
		废：
			图2-1中的线程1演示了偏向锁初始化的流程。
			？
				cas为什么会替换失败，它是如何判断失败的了
				
			图2-1中 线程2演示了偏向锁撤销的流程。
	附：
	偏向锁的初始化：
		1. 线程第一次进入同步代码块前，线程会将对象头(偏向id)保存到栈帧。
			？？
				栈帧存储了干啥用
			废？
				当一个线程访问同步块并获取锁时，
				会在对象头和栈帧中的锁记录里存储锁偏向的线程ID。
		2. 	线程进入同步代码块，测试对象头的MarkWord里是否存储着指向当前线程id的偏向锁。
			如果测试成功，表示线程已经获得了锁。
				无需cas加锁，直接操作同步代码块。
			如果测试失败，则需要再测试一下MarkWord中偏向锁的标识是否设置成1（表示当前是偏向锁）。
				如果不是，则使用CAS竞争锁；
					？？竞争什么，轻量吗
				？？(下面的思路对吗)
				如果是，则尝试使用CAS(期望值：null，更新值：线程2的id)将对象头的偏向锁指向当前线程。
				失败则进入偏向锁的撤销。
				附：思考
				？
					这一步不会多此一举吗
					例对象头线程1 此时是线程2cas(期望值：线程2的id，更新值：线程2的id)，肯定会失败啊
						还是直接cas(期望值：null，更新值：线程2的id)
					所以接着进行撤销吗
				？
					如果对象头是null了，cas期望值是什么，null吗
	偏向锁的撤销：
		附：
			偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。
		
		1. 偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。
		2. 首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着， 
		如果线程不处于活动状态，则将对象头设置成无锁状态；
		如果线程仍然活着，
			goto：偏向锁什么时候会升级了
			废？
				拥有偏向锁的栈 会被执行?，遍历偏向对象的锁记录?，
				栈中的锁记录和对象头的Mark Word要么重新偏向于其他 线程，
				要么恢复到无锁或者标记对象不适合作为偏向锁，
				？没看懂
				
				？所以存活会分这两种情况吗：
					设置为无锁后，Mark Vord偏向线程2 (依然是偏向锁)
						？为什么可以偏向2了，jvm如何判断1是没问题的了
					或者无锁后，直接升级为轻量级锁(线程1和线程2竞争)

	偏向锁什么时候会升级了:
		https://blog.csdn.net/weixin_28786193/article/details/115149874?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link
		偏向锁加后不会解锁，后续发现了有其它线程正在获取该锁，那么会根据之前获得锁的线程的状态来决定要么将锁重新偏向新的线程，要么撤销偏向锁升级为轻量级锁?。
		
		假如此时有另外一个线程线程 B 尝试获取该锁，去检查锁标志位发现未指向自己，然后 CAS 将 Mark Word 的 thread ID 指向自己，发现失败了，因为 thread ID 已经指向了线程 A ，那么此时就会去执行撤销偏向锁的操作了，会在一个全局安全点(没有字节码在执行)去暂停拥有偏向锁的线程(线程 A)，然后检查线程 A 的状态，那么此时线程 A 就有 2 种情况了。

		第一种情况
			线程 A 已经终止状态，那么将 Mark Word 的线程 ID 置位空后，CAS 将线程 ID 偏向线程 B 然后就又回到上述又是偏向锁线程的运行状态了
		第二种情况
			线程 A 处于活动状态，那么就会将偏向锁升级为轻量级锁，然后唤醒线程 A 执行完后续操作，线程 B 自旋获取轻量级锁。
			
		？
			升到轻量后，会立马升到重量吗
	
	附：
		关闭偏向锁：
			偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如 有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。
			如果你确定应用程 序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:- UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。

		偏向锁头部Epoch字段值：
			表示此对象偏向锁的撤销次数。当默认撤销次数是40以上，表示此对象不再适用于偏向锁，当下次线程再次获取此对象时，直接变为轻量级锁。


轻量级锁:
	轻量级锁目的：
		多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。
		针对这种情况，JVM采用轻量级锁来避免线程的阻塞与唤醒。


	（1）轻量级锁加锁：
		线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间（是为了撤销），并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。
		然后线程尝试使用 CAS将对象头中的Mark Word替换为指向锁记录的指针。
		如果成功，当前线程获得锁，
		如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
		？
			a已经获取到锁后，b锁此时来，复制对象头，此时a持有锁 那么b是会复制成功了。
			是的b会成功，然后进行cas b线程会失败，然后进入cas自旋。
	（2）轻量级锁解锁：
		轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，
		如果成功，则表示没有竞争发生。
		如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。
			附：
			为什么释放会失败了：
				线程2将Mark Word已经更改为指向重量级锁的指针了，所以这里的线程1CAS会失败。
				？
					既然会升级，那为什么要自旋了

			？？？
				为什么叫轻量锁？
					是因为加锁速度快吗，即同步块执行快？
				与重量锁的差别主要在那，轻量级锁获取锁时不是也进行一些判断和操作？
					
				重量锁为什么重量了？
		附：轻量锁的升级
			即执行完代码后，释放轻量级锁，发现失败，就将所有指向该锁的线程升级为重量锁，
			无锁的线程阻塞，有锁的既然执行完代码了，那么释放锁，并唤醒阻塞线程，
			被唤醒的线程重现争夺锁访问同步块。
			附：为什么要升级和为什么升级了不下降：
				因为自旋会消耗CPU，为了避免无用的自旋，一旦锁升级 成重量级锁，就不会再恢复到轻量级锁状态。
				当锁处于重量级锁状态下，其他线程试图获取锁时， 都会被阻塞住，
				当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。
			附：
				释放轻量锁时，有发现有人在自循环就会失败，然后就升级为重量锁，那就是有竞争就升级，那和偏向锁差别在哪：
					偏向锁线程，后续重入都不用在cas操作，儿轻量锁每次进入都要cas加锁
		图2-2是 两个线程同时争夺锁，导致锁膨胀的流程图：
			...pdf32
			./轻量锁竞争.png
			
重量锁：
	为什么称为重量锁：
		在锁竞争激烈的情况下，Synchronized同步锁在性能上就表现得非常糟糕，它也常被大家称为重量级锁。
		goto： 重量锁原理.txt#内核态和用户态
	重量锁原理：
		goto：重量锁原理.txt#重量锁原理