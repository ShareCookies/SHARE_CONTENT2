显示锁Lock：（Lock对象实现同步）
		背景：
			内置锁这么好用，为什么还需多出一个显式锁呢。
			因为有些事情内置锁是做不了的，比如：
				我们想给锁加个等待时间超时时间，超时还未获得锁就放弃，不至于无限等下去；
				我们想以可中断的方式获取锁，这样外部线程给我们发一个中断信号就能唤起等待锁的线程；
				我们想为锁维持多个等待队列，比如一个生产者队列，一个消费者队列，以便提高锁的效率。
			显式锁正是为了解决这些灵活需求而生。
		介绍：
			Java SE5 java.util.concurrent.locks中还提供了种显式的互斥机制，Lock对象。		
			Lock对象必须被显式地创建、锁定和释放。
				因此，它与内建的锁形式相比，代码缺乏优雅性。
				但对于解决某些类型的问题来说，它更加灵活。
			Lock接口的常见实现类有：ReentrantLock，ReentrantReadWriteLock。
			附：
				显式锁虽然灵活，但是需要显式的申请和释放，并且释放一定要放到finally块中，否则可能会因为异常导致锁永远无法释放。这是显式锁最明显的缺点。
				综上，当需要同步时请优先考虑更安全的更易用的隐式锁。
		ReentrantLock可重入锁：
			Lock接口的一个实现类，使用频率很高的一个锁。
			可重入锁解释：就是其字面意思，一个线程已经获得了锁，其内部还可以多次申请该锁成功。
				表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞
				附：
					可重入的意义在于何处：
						https://blog.csdn.net/w8y56f/article/details/89554060
						可重入降低了编程复杂性，如迭代，或方法调方法每个方法都需要锁等场景。
					使用ReentrantLock的时候一定要手动释放锁，并且加锁次数和释放次数要一样。
					Synchronized也是可重入锁。
			例：
				1.
					./案例/同步与通信/lockTest.java
					void m() {
						Lock lock=new ReentrantLock();
						lock.lock();
						try {
							...
						} finally {
							lock.unlock();//使用了lock和unlock创建了临界资源
						}
					}
				2.可定时：
					RenentrantLock.tryLock(long timeout, TimeUnit unit)提供了一种以定时结束等待的方式，如果线程在指定的时间内没有获得锁，该方法就会返回false并结束线程等待。
					// 可定时，超过指定时间为得到锁就放弃
					try {
						lock.tryLock(10, TimeUnit.SECONDS);
						try {
							// your code
						}finally {
							lock.unlock();
						}
					} catch (InterruptedException e1) {
						// exception handling
					}
				3.可中断：
					你一定见过InterruptedException，很多跟多线程相关的方法会抛出该异常，这个异常并不是一个缺陷导致的负担，而是一种必须，或者说是一件好事。可中断性给我们提供了一种让线程提前结束的方式（而不是非得等到线程执行结束），这对于要取消耗时的任务非常有用。
					对于内置锁，线程拿不到内置锁就会一直等待，除了获取锁没有其他办法能够让其结束等待。RenentrantLock.lockInterruptibly()给我们提供了一种可以中断结束等待的方式。
					// 可中断，等待获取锁的过程中线程线程可被中断
					try {
						lock.lockInterruptibly();
						try {
							// your code
						}finally {
							lock.unlock();
						}
					} catch (InterruptedException e) {
						// exception handling
					}					
				4.条件队列(condition queue)：？
					线程在获取锁之后，可能会由于等待某个条件发生而进入等待状态（内置锁通过Object.wait()方法，显式锁通过Condition.await()方法），进入等待状态的线程会挂起并自动释放锁，这些线程会被放入到条件队列当中。synchronized对应的只有一个条件队列，而ReentrantLock可以有多个条件队列，多个队列有什么好处呢？请往下看。
					https://www.cnblogs.com/CarpenterLee/p/7896361.html
				5.条件谓词：？
					线程在获取锁之后，有时候还需要等待某个条件满足才能做事情，比如生产者需要等到“缓存不满”才能往队列里放入消息，而消费者需要等到“缓存非空”才能从队列里取出消息。这些条件被称作条件谓词，线程需要先获取锁，然后判断条件谓词是否满足，如果不满足就不往下执行，相应的线程就会放弃执行权并自动释放锁。使用同一把锁的不同的线程可能有不同的条件谓词，如果只有一个条件队列，当某个条件谓词满足时就无法判断该唤醒条件队列里的哪一个线程；但是如果每个条件谓词都有一个单独的条件队列，当某个条件满足时我们就知道应该唤醒对应队列上的线程（内置锁通过Object.notify()或者Object.notifyAll()方法唤醒，显式锁通过Condition.signal()或者Condition.signalAll()方法唤醒）。这就是多个条件队列的好处。
		附：
			lock对象锁住的也是monitor吗！
				不是，应该是对lock进行加锁。
				这里有空去研究下源码再说
		ReentrantReadWriteLock：(可重入读写锁)
			https://www.cnblogs.com/xiaoxi/p/9140541.html
			现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写的操作了。
			针对这种场景，JAVA的并发包提供了读写锁ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁....
		废弃：
			显示的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁，还赋予你给更细粒度的控制力。
				例：
					在使用synchronized关键字时，某些事物失败了，那么就会抛出一个异常。如果你不处理那么你没有机会去做任何清理工作，以维护系统使其处于良好状态。
					而显式的Lock对象，你就可以使用finally进行最后的清理。
					synchronized void m() {
						有个IO资源，如果后面发生异常，那么就将无法得到释放。
						int i = 1/0; //此处抛出异常，锁将被释放。要想不被释放，可以在这里进行catch
					}
					void m() {
						Lock lock=new ReentrantLock();
						lock.lock();//使用了lock和unlock创建了临界资源
						try {
							...
						} finally {
							lock.unlock();//释放锁
							io.close();//释放IO资源
						}
					}