5.3 重入锁
介绍：
	Lock接口的一个实现类，使用频率很高的一个锁。
	重入锁ReentrantLock，顾名思义就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。	
		即线程获取锁之后，如果再次调用lock()方法，则该线程不会被自己所阻塞。
		附：
			synchronized关键字也支持可重入
		
	除此之外，该锁还支持获取锁时的公平和非公平性选择。
		1.锁是公平的，先对锁进行获取的请求先被满足。反之，是不公平的。
		也可以说锁获取是顺序的，也就是FIFO。
		2.ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。
			默认非公平锁
		公平锁优缺点：
			事实上，公平的锁机制往往没有非公平的效率高，但是，并不是任何场景都是以TPS作为 唯一的指标，
			公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。
	附：
		可重入的意义在于何处：
			https://blog.csdn.net/w8y56f/article/details/89554060
			可重入降低了编程复杂性，如迭代，或方法调方法每个方法都需要锁等场景。
		？
			使用ReentrantLock的时候一定要手动释放锁，并且加锁次数和释放次数要一样。
		
可重入的实现：
	1）是否是同一线程
		锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。 
	2）锁的最终释放。
		线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到 该锁。
		锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁 被释放时，计数自减，当计数等于0时表示锁已经成功释放。
	
	
	ReentrantLock的nonfairTryAcquire方法 
		final boolean nonfairTryAcquire(int acquires) {
			final Thread current = Thread.currentThread(); 
			int c = getState(); 
			if (c == 0) {
				if (compareAndSetState(0, acquires)) { 
					setExclusiveOwnerThread(current); return true;
				}
			} 
			//该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来 决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回 true，表示获取同步状态成功。
			else if (current == getExclusiveOwnerThread()) { 
				int nextc = c + acquires; 
				if (nextc < 0) throw new Error("Maximum lock count exceeded"); 
				setState(nextc); 
				return true; 
			}
			return false; 
		}
		//int acquires？
	ReentrantLock的tryRelease方法
		protected final boolean tryRelease(int releases) { 
			int c = getState() - releases; 
			if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); 
			boolean free = false; 
			//可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功
			if (c == 0) { free = true; setExclusiveOwnerThread(null); }
			setState(c);
			return free; 
		}
		// int releases？
公平与非公平获取锁的区别
	公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO
	
	
	ReentrantLock的tryAcquire方法：(公平)
		protected final boolean tryAcquire(int acquires) {
			final Thread current = Thread.currentThread();
			int c = getState(); 
			if (c == 0) {
				// 与非公平锁对比判断条件多了 hasQueuedPredecessors()方法，
				// 即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，
				// 因此需要等待前驱线程获取并释 放锁之后才能继续获取锁。
					？那前驱线程会怎么和什么时候被唤醒了
				if (!hasQueuedPredecessors() 
				&& compareAndSetState(0, acquires)) { 
					setExclusiveOwnerThread(current);
					return true; 
				} 
			}
			else if (current == getExclusiveOwnerThread()) {
				int nextc = c + acquires; 
				if (nextc < 0) throw new Error("Maximum lock count exceeded"); 
				setState(nextc);
				return true; 
			}
			return false; 
		}
	公平与非公平获取锁的区别测试案例：
		pdf251
		
可重入锁使用案例：
	1.
		./案例/同步与通信/lockTest.java
		void m() {
			Lock lock=new ReentrantLock();
			lock.lock();
			try {
				...
			} finally {
				lock.unlock();//使用了lock和unlock创建了临界资源
			}
		}
