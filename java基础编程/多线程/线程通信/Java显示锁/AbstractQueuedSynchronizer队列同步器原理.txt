队列同步器的实现分析
	下来将从实现角度分析同步器是如何完成线程同步的，主要包括：
	同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态
	等同步器的核心数据结构与模板方法。
	
	
1.同步队列 
	介绍：
		同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理。
		当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node），
		然后将其加入同步队列，同时会阻塞当前线程。
		当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。 
		
	同步队列中的节点:
		同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点，节点的属性类型与名称以及描述如表5-5所示。
		
		?
			int waitStatus
			同步队列和等待队列
			Node next
			Node nextWaiter
	设置尾节点
		试想一下，当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，
		而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node update)，
		它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。
			即只有真实尾节点与当前认为的尾节点同，才能成功插入到同步队列尾部
	设置首节点
		设置首节点是通过获取同步状态成功的线程来完成的，
		由于只有一个线程能够成功获取到同步状态，
		因此设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。
		
2.独占式同步状态获取与释放
	 通过调用同步器的acquire(int arg)方法可以获取同步状态，
	 附：
		该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同 步队列中移出。
	 public final void acquire(int arg) {
		//代码主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等 待的相关工作
			//主要逻辑是：
			//1. 首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法需保证线程安全的获取同步状态，
				//自定义的tryAcquire方法一般就是快速让当前线程持有锁，失败后就进入后面的步骤，进入同步队列...
			//2. 如果同步状态获取失败，则构造同步节点（独占式 Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）
			//3. 并通过addWaiter(Node node) 方法将该节点加入到同步队列的尾部，
			//最后调用acquireQueued(Node node,int arg)方法，
			//该节点以“死循环”的方式获取同步状态。
			//如果获取不到则阻塞节点中的线程，而被阻塞线程的 唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。
		if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
		selfInterrupt(); 
	}
	同步器的addWaiter和enq方法 
		private Node addWaiter(Node mode) {
			Node node = new Node(Thread.currentThread(), mode);
			// 快速尝试在尾部添加 
			Node pred = tail;
			if (pred != null) {
				node.prev = pred; 
				if (compareAndSetTail(pred, node)) {
					pred.next = node;
					return node; 
				}
			}
			enq(node); return node;
		}
		...
    /**
     * Acquires in exclusive uninterruptible mode for thread already in
     * queue. Used by condition wait methods as well as acquire.
     *
     * @param node the node
     * @param arg the acquire argument
     * @return {@code true} if interrupted while waiting
     */
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
			//以“死循环”的方式获取同步状态
            for (;;) {
				//Returns previous node, or throws NullPointerException if null.
				//返回节点的前置节点
                final Node p = node.predecessor();
				// 如果前置节点是头节点则继续尝试获取锁对象
					//这里为什么仅当跟在头节点后时才尝试获取了，因为在当头节点走了，你才有获取锁成功希望， 如果你离头节点远那都没有必要去尝试获取
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
				//离太远是要暂停的判断吗？
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
	...
	pdf235
3.共享式同步状态获取与释放
	共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。
		可用于文件的读写等
	通过调用同步器的acquireShared(int arg)方法可以共享式地获取同步状态。
	同步器的acquireShared和doAcquireShared方法：
		...
		pdf238
4.独占式超时获取同步状态
	通过调用同步器的doAcquireNanos(int arg,long nanosTimeout)方法可以超时获取同步状 态，
	即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。
	pdf239
	
例：
	自定义同步组件——TwinsLock
	pdf243