共享变量怎么通信：
	一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。
	前者是生产者，后者就是消费者，这种模 式隔离了“做什么”（what）和“怎么做”（How），在功能层面上实现了解耦，体系结构上具备了良 好的伸缩性。
	
	Java语言中可，让消费者线程不断地循环检查变量是否符合预期...实现类似的功能,但纯变量通信是却存在如下问题: 
	1）难以确保及时性。
		在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时 发现条件已经变化，也就是及时性难以保证。
	2）难以降低开销。
		如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现 条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。
	但是Java通过内置的等待/通知机制能够很好地解决 这个矛盾并实现所需的功能
等待/通知:
	等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类 java.lang.Object上。
	等待/通知：
		等待(object.wait())使一个线程从运行态进入等待阻塞，并且释放所持有的对象的锁。
		这个时候需要其他机制（线程）将处于等待状态的线程唤醒，比如调用notify或者notifyAll()方法。

	等待/通知的相关方法:
	notify()
		通知一个在对象上等待的线程.
		注:
			1. 在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。				
	notifyAll()
		通知所有等待在该对象上的线程
	通知注:
		1.
			使用wait()、notify()和notifyAll()时需要先对调用对象加锁。
			如果在没有拥有锁的情况下，调用等待通知方法会报java.lang.IllegalMonitorStateException异常。
		2. 
			notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或 notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。
		3.
			notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列？中，
			而notifyAll() 方法则是将等待队列中所有的线程全部移到同步队列，
			被移动的线程状态由WAITING变为 BLOCKED。
			然后等notify的线程释放锁后，它们开始竞争，只有获得锁的线程才能进入就绪状态；！
			即：
				notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或 notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。
				其余没获得锁进入BLOCKED阻塞
			例：
				WaitNotify.java
				然后通过jps和jstack 命令就可看到等待WaitThread2是阻塞状态
			附：
				如果本身就有线程在这个对象上阻塞的，是不是也参与竞争锁。
				答：是的。
				例：
					WaitNotifyForBlockedThereadCompeteMonitor.java
		4.
			就绪状态的线程不会立刻执行run方法，会进入排队队列(就绪状态)再次等待CPU分配资源然后进入运行状态;
	wait()
		调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回.
		
		注:
			1. 调用wait()方法后，会释放对象的锁。
			2. 中断返回会怎样，还是机会运行还是直接退出线程了.
			答：
				等待状态，收到中断了，线程会从等待状态恢复，然后收到中断异常。
				如果此时对中断异常捕获了，那么就可以继续往下走了。

		附：
			调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。
	wait(long)
		超时等待一段时间， 这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回
	wait(long, int)
		对于超时时间更细粒度的控制，可以达到纳秒

等待/通知的经典范式：
	pdf197