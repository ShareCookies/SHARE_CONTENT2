共享资源：
	java线程间共享了堆资源,使用了并发后，多个线程彼此干涉的问题就产生了。
		例：两线程同时改变同一个值，同时访问一打印机等。
	解决方案：
		1. 可以使用同步来解决临界区的问题。
			附：
				线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作.
		2. 也可使用线程本地存储解决共享资源问题。
同步：
	介绍：
		1. java中可通过人为的控制和调度，实现同步效果（给定时刻只有一个线程能对其进行操作）来解决共享资源的访问问题，保证共享资源的多线程访问成为线程安全，来保证结果的准确。
		2. 同步的实现方案有：隐式锁synchronized，显示锁Lock，变量同步volatile
		附：
			什么是互斥量机制：（同步也称为互斥量机制）
				基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。
				这意味着在给定时刻只允许一个任务访问共享资源。
				通常这是通过在代码前面加上一条锁语句来实现的，这就使得在一段时间内只有一个任务可以运行这段代码。
				因为锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量(mutex)。
	隐式锁synchronized(内置锁)：（java关键字synchronized实现同步）
		java编程思想p677
		介绍：
			Java提供关键字synchronized，为防止资源冲突提供了内置支持。
			使用synchronized修饰方法或加在代码段上，就能保证方法或者代码块以同步方式执行,使用起来非常近简单.
			附：
				synchronized实现原理：
					简洁版：
						当线程要执行被synchronized关键字保护的代码片段的时候，它将检查锁是否可用，如果可用则获取锁,执行代码后释放锁。
						如果不可用进入等待阻塞状态，等待jvm分配锁，在获取锁后进入可运行状态等待系统分配cpu资源。
							synchronized锁住一个对象后，别的线程如果也想拿到这个对象的锁，就必须等待这个线程执行完成释放锁。
					介绍：
						所有对象都自动含有一个的锁(也称为监视器)。
							任何java对象，有且只有一个对象锁(或称为对象监视器)，但它可被同一线程多次获得，不同线程不行。
						synchronized同步实质上使用的是对象锁。
							当对象任意synchronized方法被调用的时候，此对象都被加锁，
							这时该对象上的所有synchronized方法（其余线程）调用只有等到前一个方法（当前线程）调用完毕，并释放了锁之后才能被调用。
						锁对象加锁过程：
							锁对象是同步代码块的关键，锁对象的标志位默认为1。
							当线程执行到同步代码块时，首先会检查锁对象的标志位，
							如果标志位大于0，标志位会减一（这里标志位就是0），当线程执行完同步代码块后，标志位会加一（这里标志位就会变为1）同时jvm会把锁随机分配给阻塞队伍中的一个线程。
							如果标志位小0则线程发生阻塞。
							附：
								一个任务可以多次获得对象的锁。
								如果一个方法在同一个对象上调用了第二个方法，后者又调用了同一对象上的另一个方法，就会发生这种情况。
								JVM负责跟踪对象被加锁的次数。如果一个对象被解锁(即锁被完全释放)，其计数变为0。在任务第一次给对象加锁的时候，计数变为1。每当这个相同的任务在这个对象上获得锁时，计数都会递增。显然，只有首先获得了锁的任务才能允许继续获取多个锁。每当任务离开一个synchronized方法，计数递减，当计数为零的时候，锁被完全释放，此时别的任务就可以使用此资源。
					synchronized原理实现细节：
						https://blog.csdn.net/jinjiniao1/article/details/91546512
				synchronized通常称为重量级锁。?
					https://blog.csdn.net/jinjiniao1/article/details/91546512
					....
					synchronized多线程的同步即限制某资源在任一个时刻只能被一个线程访问，以保证数据的完整性。
					线程在执行同步代码时每次都会判断锁的状态，耗费资源效率低下。
					即：
						多了判断，只能一个，所以重量级。
		例：
			synchronized能加在方法或者代码段上。
			1.同步控制块（临界区）：
				介绍：
					只是希望防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。
					通过这种方式分离出来的代码段被称为临界区(critical section)，它也使用synchronized关键字建立。
					synchronized被用来指定某个对象，此对象的锁被用来对花括号内的代码进行同步控制。
					对象的锁拿来用，那么如果该对象内有多个临界区了：
						使用该方式或得synchronized块上的锁，那么该对象其他synchronized方法和临界区就不能被调用了。！
				例：
					public  void test() {
						synchronized(this){//this为要锁住的对象，如果某线程得到锁那可其他线程只有等到锁释放才能进入临界区。
							将处理共享资源的代码（或操作）放到一个代码块中
						}
					}
				注：
					1.通过同步控制块，而不是同步方法，可以使多个任务访问对象的时间性能得到（显著）提高。
			2.同步方法：
				public synchronized void test() {}
				注：
					1.同步方法也有锁，它的锁就是当前调用该方法的对象。
					2.synchronized关键字不属于方法特征签名组成部分，所以可以在覆盖方法的时候加上去。
					例：
						./案例/同步与通信/synchronized/
			3.静态方法同步：
				静态方法是可以并发的案例：
					./案例/静态方法并发/静态方法并发案例.txt
				静态方法同步：
					针对每个类，也有一个锁(作为类的Class对象的一部分);所以synchronized static方法可以在类的范围内防止对static数据的并发访问。
				注：
					1.静态同步方法的锁是该方法所在类的class对象。
			注：
				1.多个线程共享的锁对象必须是唯一的。
					例：
						锁对象的创建不能放在实现了Runnable接口的类的run（）方法中，
						否则每个线程运行到run()方法会新建一个锁对象，线程不能产生同步效果。！
				2.锁的对象总结：
					就是锁的是那个对象。
					同步控制块（临界区）：
						synchronized(被用来指定要锁住的对象,常为this){
						}
					同步方法：
						同步方法也有锁，它的锁就是当前调用该方法的对象。
					静态同步方法：
						静态同步方法的锁是该方法所在类的class对象。
					例：
						https://www.cnblogs.com/QQParadise/articles/5059824.html	
				3.
					在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突。???
		附：
			实际使用场景：
				共享资源一般是以对象形式存在的内存片段，但也可以是文件、输入/输出端口，或者是打印机。
				要控制对共享资源的访问，得先把它包装进一个对象。然后把所有要访问这个资源的方法标记为synchronized。
				那么在这个线程从该方法返回之前，其他所有要调用类中任何标记为synchronized方法的线程都会被阻塞。
				即每个访问临界共享资源的方法都必须同步，否则将无法正确工作。
			你应该什么时候应用同步呢：
				可以运用Brian的同步规则:
				1，如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步。
				2.如果在你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法。如果只同步一个方法， 那么其他方法将会随意地忽略这个对象锁，并可以在无任何惩罚的情况下被调用。
					还是有可能出错，如果锁的对象不是同一个了！
				3.这是很重要的一点: 每个访问临界共享资源的方法都必须被同步，否则它们就不会正确地工作。
			synchronized锁内部发生异常：
				synchronized锁在发生异常的时候会自动释放锁。
					附：要想不释放则要捕获异常，不让异常抛出。
	volatile:
		volatile修饰变量，仅可保证变量的可见性。
	显示锁Lock：（Lock对象实现同步）
		背景：
			内置锁这么好用，为什么还需多出一个显式锁呢。
			因为有些事情内置锁是做不了的，比如：
				我们想给锁加个等待时间超时时间，超时还未获得锁就放弃，不至于无限等下去；
				我们想以可中断的方式获取锁，这样外部线程给我们发一个中断信号就能唤起等待锁的线程；
				我们想为锁维持多个等待队列，比如一个生产者队列，一个消费者队列，以便提高锁的效率。
			显式锁正是为了解决这些灵活需求而生。
		介绍：
			Java SE5 java.util.concurrent.locks中还提供了种显式的互斥机制，Lock对象。		
			Lock对象必须被显式地创建、锁定和释放。
				因此，它与内建的锁形式相比，代码缺乏优雅性。
				但对于解决某些类型的问题来说，它更加灵活。
			Lock接口的常见实现类有：ReentrantLock，ReentrantReadWriteLock。
			附：
				显式锁虽然灵活，但是需要显式的申请和释放，并且释放一定要放到finally块中，否则可能会因为异常导致锁永远无法释放。这是显式锁最明显的缺点。
				综上，当需要同步时请优先考虑更安全的更易用的隐式锁。
		ReentrantLock可重入锁：
			Lock接口的一个实现类，使用频率很高的一个锁。
			可重入锁解释：就是其字面意思，一个线程已经获得了锁，其内部还可以多次申请该锁成功。
				表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞
				附：
					可重入的意义在于何处：
						https://blog.csdn.net/w8y56f/article/details/89554060
						可重入降低了编程复杂性，如迭代，或方法调方法每个方法都需要锁等场景。
					使用ReentrantLock的时候一定要手动释放锁，并且加锁次数和释放次数要一样。
					Synchronized也是可重入锁。
			例：
				1.
					./案例/同步与通信/lockTest.java
					void m() {
						Lock lock=new ReentrantLock();
						lock.lock();
						try {
							...
						} finally {
							lock.unlock();//使用了lock和unlock创建了临界资源
						}
					}
				2.可定时：
					RenentrantLock.tryLock(long timeout, TimeUnit unit)提供了一种以定时结束等待的方式，如果线程在指定的时间内没有获得锁，该方法就会返回false并结束线程等待。
					// 可定时，超过指定时间为得到锁就放弃
					try {
						lock.tryLock(10, TimeUnit.SECONDS);
						try {
							// your code
						}finally {
							lock.unlock();
						}
					} catch (InterruptedException e1) {
						// exception handling
					}
				3.可中断：
					你一定见过InterruptedException，很多跟多线程相关的方法会抛出该异常，这个异常并不是一个缺陷导致的负担，而是一种必须，或者说是一件好事。可中断性给我们提供了一种让线程提前结束的方式（而不是非得等到线程执行结束），这对于要取消耗时的任务非常有用。
					对于内置锁，线程拿不到内置锁就会一直等待，除了获取锁没有其他办法能够让其结束等待。RenentrantLock.lockInterruptibly()给我们提供了一种可以中断结束等待的方式。
					// 可中断，等待获取锁的过程中线程线程可被中断
					try {
						lock.lockInterruptibly();
						try {
							// your code
						}finally {
							lock.unlock();
						}
					} catch (InterruptedException e) {
						// exception handling
					}					
				4.条件队列(condition queue)：？
					线程在获取锁之后，可能会由于等待某个条件发生而进入等待状态（内置锁通过Object.wait()方法，显式锁通过Condition.await()方法），进入等待状态的线程会挂起并自动释放锁，这些线程会被放入到条件队列当中。synchronized对应的只有一个条件队列，而ReentrantLock可以有多个条件队列，多个队列有什么好处呢？请往下看。
					https://www.cnblogs.com/CarpenterLee/p/7896361.html
				5.条件谓词：？
					线程在获取锁之后，有时候还需要等待某个条件满足才能做事情，比如生产者需要等到“缓存不满”才能往队列里放入消息，而消费者需要等到“缓存非空”才能从队列里取出消息。这些条件被称作条件谓词，线程需要先获取锁，然后判断条件谓词是否满足，如果不满足就不往下执行，相应的线程就会放弃执行权并自动释放锁。使用同一把锁的不同的线程可能有不同的条件谓词，如果只有一个条件队列，当某个条件谓词满足时就无法判断该唤醒条件队列里的哪一个线程；但是如果每个条件谓词都有一个单独的条件队列，当某个条件满足时我们就知道应该唤醒对应队列上的线程（内置锁通过Object.notify()或者Object.notifyAll()方法唤醒，显式锁通过Condition.signal()或者Condition.signalAll()方法唤醒）。这就是多个条件队列的好处。
		附：
			lock对象锁住的也是monitor吗！
				不是，应该是对lock进行加锁。
				这里有空去研究下源码再说
		ReentrantReadWriteLock：(可重入读写锁)
			https://www.cnblogs.com/xiaoxi/p/9140541.html
			现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写的操作了。
			针对这种场景，JAVA的并发包提供了读写锁ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁....
		废弃：
			显示的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁，还赋予你给更细粒度的控制力。
				例：
					在使用synchronized关键字时，某些事物失败了，那么就会抛出一个异常。如果你不处理那么你没有机会去做任何清理工作，以维护系统使其处于良好状态。
					而显式的Lock对象，你就可以使用finally进行最后的清理。
					synchronized void m() {
						有个IO资源，如果后面发生异常，那么就将无法得到释放。
						int i = 1/0; //此处抛出异常，锁将被释放。要想不被释放，可以在这里进行catch
					}
					void m() {
						Lock lock=new ReentrantLock();
						lock.lock();//使用了lock和unlock创建了临界资源
						try {
							...
						} finally {
							lock.unlock();//释放锁
							io.close();//释放IO资源
						}
					}
线程本地存储：（线程本地存储解决共享资源问题）
	防止在共享资源上产生冲突的第二种方式是根除对变量的共享。
	线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。
	使用ThreadLocal类创建和管理线程本地存储。
	
	
	
	注：
		1.ThreadLocal对象通常当作静态域存储。
		2.ThreadLocal的方法保证不会出现竞争条件（即同步安全）。
	原理：
		概要：
			ThreadLocal为每个线程维护一个本地变量。采用空间换时间，它用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。
			ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本。
		./案例/同步与通信/线程本地存储
	例：
		./案例/同步与通信/线程本地存储
附：
	原子类:
		Java SE5引入了诸如AtomicInteger. AtomicLong. AtomicReference等特殊的原子性变量类。
		这些类被调整为可以使用在某些现代处理器上的可获得的，并且是在机器级别上的原子性。
		对于常规编程来说，它们很少会派上用场，但是在涉及性能调优时，它们就大有用武之地了。				
	volatile和ThreadLocal？
		https://www.cnblogs.com/zhangblearn/p/9826753.html
	CountDownLatch
		CountDownLatch 是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。
		
