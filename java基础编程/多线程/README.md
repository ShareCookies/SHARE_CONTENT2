# Java并发编程：
## [什么并发(了解什么是线程、为什么要有线程)](https://github.com/yuyumyself/SHARE_CONTENT2/blob/master/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E5%8F%91.txt)

./什么是并发.txt



## [java实现并发编程的三种方式(了解如何创建线程)](https://github.com/yuyumyself/SHARE_CONTENT2/blob/master/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F.txt)

./java实现并发编程的三种方式.txt

## [线程的相关内容(了解线程的一些概念。)](https://github.com/ShareCookies/SHARE_CONTENT2/blob/master/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9.txt)

- 线程的生命周期:（./线程相关内容/线程的生命周期.txt）
- 守护线程与用户线程（./线程相关内容/守护线程与用户线程.txt）
- 线程调度(控制线程的cpu使用权)
  - 中断(./线程相关内容/线程调度/终结任务(中断).txt)
  - sleep(./线程相关内容/线程调度/sleep.txt)
  - 优先级(./线程相关内容/线程调度/线程调度(优先级).txt)
- 线程通信(或叫线程协作，线程之间互相进行协作)
  - 等待/通知(wait、notify),Thread.join (./线程相关内容/线程通信/)
  - 共享资源(同步、显示锁、线程本地存储、volatile)(./线程相关内容/线程通信/共享资源/)
  - (并发容器)(./线程相关内容/线程通信/并发容器/)
  - 

## [线程池(了解线程的复用。)](https://github.com/yuyumyself/SHARE_CONTENT2/blob/master/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0.txt)

附：线程关系： ./并发编程.txt



# 线程体系知识的串联：

## 	介绍：

​		进程是运行在内存中的程序，是内存端口等分配的最小单位。
​		线程是操作系统调度的最小单元，线程是用来实现并发执行任务的。

## 	线程的创建：

​		线程可以驱动任务，任务可通过Runnable接口、Callable接口来描述,然后通过thread来启动.

## 	线程的运行：

​		java程序从main线程运行，然后在main线程中进行其他线程的开辟。
​		main线程结束运行并不会使程序结束，而是所有用户线程结束应用才会结束，守护线程并不影响应用是否结束。(线程类型又分为用户线程和守护线程)
​		线程结束：
​			运行完线程中代码，线程就会结束，
​			*线程生命周期又划分为：
​				新建，
​					仅new还未start()，所以在jmap线程栈打印中是看不到的吧？
​				运行(可运行、运行中)，
​				阻塞，
​				等待，
​					wait notice
​				超时等待
​					wait(long)
​					sleep

## 	并发中的线程：

​		线程并发后互相间协作方式又主要有：
​			线程调度：
​				中断、sleep、thread.join()、
​			线程通信：
​				等待 通知、
​				资源共享：
​					synchronized隐式锁 
​						偏向锁 轻量
​							原理 对象头存储线程id
​						重量锁
​							原理 通过monitorenter指令获取monitor
​					volatile
​						仅能保证变量的可见性
​					线程本地存储
​						消除对变量的共享
​						就是把变量存在线程上，不推荐使用，因为线程上threadMap是弱键 所以存储数据很可能被回收掉
​					显示锁
​						主要有：可重入锁、可重入读写锁。
​						而显示锁的实现则是依赖了同步器，
​						队列同步器：
​							同步器是java为显示锁开发者提供的工具，依赖该工具可以快速的开发显示锁。
​							同步器主要提供：锁获取等待队列、同步状态获取与释放方法。
​							获取到同步状态即获取到了锁。why？
​						可重入读写锁实现：
​							可重入读写锁虽然持有2个锁 读锁与写锁，但其实它们2个都是应用同一个同步器来实现的。
​							写锁的排它和读锁的共享 则是用同步器的共享式同步状态获取和独占式同步状态获取来实现。
​				并发容器
​					阻塞队列、并发链表队列、并发hashmap
​					像阻塞队列里的锁就是用显示锁来实现的
​		线程并发的优化：
​			线程池:持有几个线程实例并复用它们。
​			通常通过线程池执行器(ThreadPoolExecutor)来实例化一个线程池.
​				其主要参数，核心线程、最大线程、空闲线程存活时间、空闲线程存活单位、任务队列、线程池工厂、拒接策略
​			注：如果局部线程池使用完一定要关闭。

## 诊断：线程并发后发生问题如何诊断

\Bugs\后端\服务器\线上服务CPU飙高怎么排查.txt