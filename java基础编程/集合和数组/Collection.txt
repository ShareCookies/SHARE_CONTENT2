Collection接口：
	Set接口：
		介绍：
			Set接口是Collection接口的一个子接口，它表示数学意义上的集合概念(不允许重复项集合概念)。
			特性：
				1.Set中不包含重复的元素
				
			Set 接口常见的两种实现：
				HashSet 和TreeSet。
		HashSet：
			对象不可重复、无序。
			原理：
				基于HashMap开发，插入时是直接放入到hashMap的key上。
			附：
				对象存入HashSet建议重写hashCode()和equals()方法，hashMap判断是否重复是通过这两个方法。
		TreeSet:
			对象不能重复但有自然顺序（例从小到大顺序）。
			原理：
				通常是基于TreeMap实现，插入到map的key上。
			
			附：
				对象存入TreeSet要实现Comparable接口。
					TreeSet判断元素是否重复 、以及确定元素的顺序 靠的都是这个方法；
					@override
					public int compareTO(Object o){//当前一个类与另一个类的比较。
						//当前对象的某个判断比另一个对象的小返回-1，大返回1，等于即返回0会被treeset拒绝接收。
							//从大到小排可以乘-1或另一个类与当前类比较。可进行多重比较排序如：颜色不同按颜色排，同按重量排 
					}
		附：
			为优化 HashSet 空间的使用，您可以调优初始容量和负载因子。
			TreeSet 不包含调优选项，因为树总是平衡的，保证了插入、删除、查询的性能为log(n)。
			就是hashmap和treeamp了
	List:接口
		介绍：
			List 接口继承了 Collection 接口，表示一个允许重复项的有序集合概念，称为列表或序列。

			特性：
				1.元素允许重复项
				2.有序集合
					按插入的先后顺序排序
		List 接口常见的两种实现：
			ArrayList 和 LinkedList。
		ArrayList
			介绍：					
				ArrayList基于数组开发。ArrayList内部依赖的是一个对象数组Object[], 其众多方法均围绕该对象数组展开。
					数组在使用上较为麻烦，ArrayList在数组的基础上进行了二次开发，从使用角度克服了数组的诸多缺点，但本质上还是依靠数组机制来完成。
				优点：
					索引数据快而删除插入数据慢：
						附：
							数组在内存中的位置是相邻成片的。
							ArrayList使用数组方式存储数据，数组元素数大于实际存储的数据（便于增加和插入元素）。
						1. 删除会牵涉到数组的移动，所以速度慢。
						2. 当数组不够存储时，插入元素就要涉及数组元素移动等内存操作（因为要先声明个更大数组，然后复制旧数组，在插入），所以插入数据慢。
						3. 因为数组在内存中的位置是相邻成片的， 所以索引数据快。
						
					附：
						适用场景：
							数据录入后，较为稳定，删除和插入操作较少，大多为定位查询操作
							数据增加的频率间隔较长，不会持续性连续增加
							适合队列等对元素的先后顺序极为敏感的数据结构。
						与数组对比：
							优点：
								在编码便捷性上大大优于数组，少写不少控制代码。
							缺点：
								与数组对比，插入和删除容易造成大幅波动，在元素数量超出范围的时候，也有大量的数组元素拷贝的操作发生，对系统性能有较大影响。
				
				ArrayList的泛型控制（generic type）:
					由于ArrayList很灵活，内部可以放置各种数据类型，导致外部程序，从ArrayList中取出一个元素，还必须谨慎对其判断， 有的时候外部需要大量的各种类型的代码来针对不同的对象进行对应操作，成本高昂。 有的程序员忘记书写了一些代码，经常会导致ClassCastException, 所以后来，人们不得不限制了ArrayList中的元素的类型，要求其内部只能有一种元素。
					实例： List<String> list= new ArrayList<String>();
							（当然你要是没用泛型也可用instanceof 实例关键字来判断list中放的是什么类型;
								if（obj instanceof Interger） Interger i=(Interger)obj;
							）
		LinkedList ：
			介绍：
				以链表为基础实现，底层使用了双向循环链表。
				优点：
					索引数据慢而删除插入数据快：
						双向链表存储能将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构。
						这种链式存储方式与数组的连续存储方式相比，内存的利用率更高，插入数据时只需要记录（修改）本项的前后项即可，所以插入速度较快。
						按序号索引数据时需要进行前向或后向遍历，所以查找较慢。
	
					附：
						链表：
							链表介绍：链表是一种数据结构
							一个链表节点组成：上一个节点地址+下个节点地址+当前节点值
					附：
						适用场景：
							数据录入后，较为不稳定，有着频繁删除和插入操作，随机定位查询相对较少。
							适合队列等对元素的先后顺序极为敏感的数据结构。
		附：List提供的常见操作：？
			List 接口提供了 4 种对列表元素进行定位（索引）访问方法。
				注:
					1.
					这些操作可能在和某些实现（例如 LinkedList 类）的索引值成比例的时间内执行。
					因此，如果调用方不知道实现，那么在列表元素上迭代通常优于用索引遍历列表。
					2.
					List 接口提供了特殊的迭代器，称为 ListIterator。
					除了允许 Iterator 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。
					还提供了一个方法来获取从列表中指定位置开始的列表迭代器。

			List 接口提供了两种搜索指定对象的方法。
				从性能的观点来看，应该小心使用这些方法。在很多实现中，它们将执行高开销的线性搜索。

			List 接口提供了两种在列表的任意位置高效插入和移除多个元素的方法。

			list常用算法：
				List list = new LinkedList();
				Collections.reverse(list);//逆序
				Collections.sort(list);//排序
				Collections.binarySearch(list,"111");//折半查找
