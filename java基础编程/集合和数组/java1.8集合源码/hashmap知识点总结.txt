HashMap是怎么解决哈希冲突的
	为什么会有hash冲突：
		hash值一样但不是同一个对象，此时就会hash冲突，此时就要通过链表或红黑树来存放冲突对象了。
	1. 通过链表。
		JDK1.7的是数组+链表
	2. 通过红黑树。
		JDK1.8的是数组+链表 或者 数组+红黑树
		两种方案分表什么时候使用了：
			数组+链表：
				默认冲突解决方案
			数组+红黑树：
				当链表长度大于8且hashtable的长度大于64
				就会把该链表转化为红黑树来存放元素。
				附：
					如果小于64，就通过扩容的方式来解决。						
	红黑树化操作思路:
		？

扩容：
	为什么要扩容：
		随着HashMap中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响HashMap的速度，为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。
	扩容零界点：？？？
		该临界点在当HashMap中元素的数量等于table数组长度*加载因子
	扩容好处：
		1. 扩容后链表长度变短，读写效率自然提高。
		2. 另外，扩容相对于转换为红黑树的好处在于可以保证数据结构更简单。
	扩容略势：
		扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。
		所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。
		?
			预知10000个元素，那么初始容量10000吗

	扩容操作思路:
		...

HashMap如何判断key是否为同一个对象：(HashSet同理因为调用hashmap)
	判断过程：
		1. 先调用对象的hashcode方法，获取对象hash值，判断hash值是否相同，
		如果不同则一定不是同个对象。
		同也不一定是同个对象，进行第二步。
		2.1
		对象hash值相同
		调用=判断是否是同一个对象
		2.2 
		或调用equals判断是否雷同

	附：为什么要这么比较：
	
		hash是什么：
			？1. hash值默认是java根据对象信息、内存地址等一系列信息生成的一个值。
			
			2. 所以hash值不同它们一定不是同一个对象，因为同一个对象的这些信息一定相同。
			附：简易理解
				一对象2个int，所以hash值可能出现4+4等与3+5的情况。
		equals方法：
			该方法用来确认对象是否是同一个对象，可重写，默认就是==。
			hashcode 方法判断不同 equals一定不同
			hashcode 方法判断同   equals可以不同
			附：
				hashcode 方法判断同 不一定是同一对象
				equals或==同就可以认为是同一对象
		例：
			两个对象的 hashCode() 相同，equals() 不一定 true。
				String str1 = "通话";
				String str2 = "重地";
				System. out. println(String. format("str1：%d | str2：%d",  str1. hashCode(),str2. hashCode()));
				System. out. println(str1. equals(str2));
				执行的结果：
				str1：1179395 | str2：1179395
				false
				代码解读：
					String对象重写了hashcode方法。
					虽然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false。


