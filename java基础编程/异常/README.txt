https://blog.csdn.net/java_cxrs/article/details/91661623
介绍：
	Java通过面向对象的思想处理异常，在Java中，每个异常都是一个对象。
	Java把各种不同的异常进行分类，并提供了良好的接口，Error和Exception。
		附：每个异常都是Throwable子类
	当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用该方法的方法可以捕获到这个异常并可以对其进行处理。
	附：
		当程序出现异常后，
		要么程序崩溃无法运行了，
		要么程序还能继续运行，要么自己处理异常，要么给别人处理。
			给别人处理：
				也许你不清楚该如何处理异常，此时你要停下来,把这个问题提交到一个更高级别的环境中（即抛出异常）,
				看看是不是有别人或在别的地方,能够处理这个问题。

异常的分类：
	java里异常分为Error和Exception，异常救错误不救

	Error：
		Error是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。
		此类异常无法被捕获，所以发生此类错误时，JVM将终止线程。
		例：
			NoClassDefFoundError，比如说当jvm耗完可用内存时，将出现OutOfMemoryError等
		
	Exception：
		表程序可以捕获并且可以处理的异常。
		该类型异常可分为两类。
		RuntimeException运行时异常：(不受检异常)（可自定义该类型异常）
			RuntimeException类及其子类异常。
			表示程序在运行期间可能出现的错误。	
				比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。
			此类异常属于不可查异常，编译器不会检查此类异常。只要程序设计得没有问题通常就不会发生，在程序中可以选择捕获处理，也可以不处理（包括可无需throw）。

		非运行时异常：(受检异常)
			Exception中除RuntimeException及其子类之外的异常。
			编译器会检查此类异常，所以编程时你必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。
				比如说IOException。
			注：
				受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。
				受检异常处理，除非后续程序均与抛出异常的地方，无关联，才可以捕获，不然建议抛出，否则很可能你捕获了，但后续程序需要对应的数据却获取不到，导致其他异常出现。
		附：
			异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：
				- 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）
				- 对可以恢复的情况使用受检异常，对编程错误使用运行时异常
				- 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）
				- 优先使用标准的异常
				- 每个方法抛出的异常都要有文档
				- 保持异常的原子性
				- 不要在catch中忽略掉捕获到的异常
异常的操作：（抛出异常于捕获异常）
	首先a方法中要有异常被抛出，然后调用a方法的b方法中对该异常又两种处理方式：捕获异常或继续抛出。
	注：
		1.如果异常一直往外抛，没有方法对其处理，那么最后会被抛给jvm，然后jvm打印异常信息并停止当前线程。
		2.异常未被处理的地方（未捕获就算未处理），其后续代码时不会执行的。
		3.子类重写父类方法，不能抛出必父类更多的异常，只能少抛或一样。
	抛出异常的方式：
		throw
			throw用在方法内，用来抛出一个异常对象，这个异常对象将被传递到调用者处。
			例：
				throw new NullPointerException("别名参数不允许为空");
		throws
			运用于方法声明之上，用于表示当前方法不处理异常，而是提醒该方法的调用者来处理异常
			public void test throws FileNotFoundException{
			}

	捕获异常的方式：
		try{}catch()...{}finally{}
		介绍：
			try {
				// 包裹住会抛出异常的代码。
					// 
			} catch(IOException e){
				// 1. 如果抛出的异常与IOException相同则会被该catch捕获
				e.printStackTrace();//2.打印异常信息
				// try中有return。catch这里也会执行。
			} catch(Exception e){
				// try可以与多个catch配合来捕获多个类型的异常。
				// Exception e 可以捕获所有异常
			} fanally{
				//finally无论什么情况都执行。通常将释放外部资源的代码写在finally块中。
					//即使try中有return。这里的代码只要JVM不关闭都能执行，除非直接摧毁整个程序。
			}
			注：
				1.try,catch,finally	
				作用域空间是相互独立，互不可问的。
					在这三个作用访问内定义的变量外界访问不到,但是外界定义（函数作用域）的变量其可以访问的到
				2.
				try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后：
					答：会执行，在方法返回调用者前执行。
					注：
						不要在finally中改变return的返回值，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。
						显然，在finally中返回或者修改返回值会对程序造成很大的困扰，Java中也可以通过提升编译器的语法检查级别来产生警告或错误
			附：
				try语句可以嵌套：
					try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。

自定义运行时异常：
	除了JDK定义好的异常类外，在开发过程中根据业务的异常情况自定义运行时异常类，然后抛出。
	例：
		... extends RuntimeException{
			 
		}
	符：
		1.所有标准异常类都有两个构造器:1.一个是默认构造器;2.另一个是接受字符串作为参数,以便能把相关信息放入异常对象的构造器。
		2.自定义的异常类抛出目的是，终止自己程序后续的执行，并给别的程序一个说明。
		一般自己不会捕获自己定义并抛出的异常，如果自己抛自己捕获就是自娱自乐的意义。

	      