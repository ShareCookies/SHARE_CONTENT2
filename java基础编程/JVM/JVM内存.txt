1.JVM内存
	https://www.cnblogs.com/dolphin0520/p/3613043.html
	介绍：
		Java程序是交由JVM执行的，所以Java内存区域就是指JVM内存区域。
		根据《Java虚拟机规范(Java SE 7 版)》的规定，运行时数据区通常包括这几个部分：
			堆(heap)、栈(stack)、方法区(method area)、 本地方法栈(Native Method Stack)、程序计数器(Program Counter Register)
			附：
				在JVM规范中虽然规定了程序在执行期间运行时数据区应该包括这几部分，但是至于具体如何实现并没有做出规定，不同的虚拟机厂商可以有不同的实现方式。
			例图：
				./imgs/jvm内存区域.webp
	堆 ：(是gc的主要区域)
		介绍：
			在JVM中只有一个堆，堆是被所有线程共享的。
			堆空间主要用于存储对象实例（new出来的对象）和数组（数组也是对象）
				附：方法栈放的只是引用
			注：
				因此这部分空间也是Java垃圾收集器管理的主要区域。
				在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。
				详：
					./GC.txt
				
			附:
				在C语言中，堆这部分空间是唯一一个程序员可以管理的内存区域。程序员可以通过malloc函数和free函数在堆上申请和释放空间

	栈：
		概要：
			栈（Java Vitual Machine Stack），Java栈是Java方法执行的内存模型。
			每个线程都会有一个自己的Java栈，互不干扰。
				因此栈是线程私有的，线程的生命周期和栈也一致。
		介绍：
			例图：
				./Java栈的模型.jpg
			1. Java栈中存放的是一个个的栈帧。
			2. 每个栈帧对应一个被调用的方法。
				当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。
					附：
						因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。
					附：
						讲到这里，大家就应该会明白为什么 在 使用 递归方法的时候容易导致栈内存溢出的现象了
					附：
						栈区的空间不用程序员去管理了，这部分空间的分配和释放都是由系统自动实施的。 
						对于所有的程序设计语言来说，栈这部分空间对程序员来说是不透明的。
			3. 在栈帧中包括：
				1. 局部变量表(Local Variables)、
					1. 方法中的局部变量。
						附：
						局部变量：
							凡是定义在方法中的都是局部变量，方法外的是全局变量。
							局部变量具体指：
								方法中声明的变量以及函数形参。
							局部变量作用域：
								因为是先加载函数才能进行局部变量的定义。因此变量有自己的作用域，一旦离开作用域，变量就会被释放。	
					2. 对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。
						例：
							基本数据类型的变量。
								例：int a = 1;//这里的a和1都存放在栈中
							一个对象的引用。
								例：String b = "abc";//这里只有b存放在栈中，而"abc"则存放在堆中					
					附：
						局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。！
				3. 指向运行时常量池的引用(Reference to runtime constant pool)
					指向当前方法所属的类的运行时常量池的引用。
					因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。
					
				2. 操作数栈(Operand Stack)？
					想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。
					因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。
					？
						栈最典型的一个应用就是用来对表达式求值。
                    ？？？操作数栈类似计算器
				4. 方法返回地址(Return Address)
					当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。
					？
						不应该就是上个栈帧吗 所以返回地址是指？
						返回地址指返回到上个栈的某个位置
				5. 和一些额外的附加信息。

	本地方法栈：
　　	本地方法栈与Java栈的作用和原理非常相似。
		区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。
		附：
			在JVM规范中，并没有对本地方法栈的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。
			在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。


	方法区
		介绍：
			方法区存储了已经被JVM加载的类信息(包括类的名称、方法信息、字段信息)、静态变量池、常量池、JIT编译器编译后的代码(编译后的.class字节码？)等数据；
			方法区也是被线程共享的内存区域。
			附：
				例：
					String str = new String("hello");
					上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区的。
			字面量:
				程序中的字面量（literal），如直接书写的100、"hello"等都是放在常量池中，常量池是方法区的一部分。		
			？
				运行时常量池：
					在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。
					当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。


				https://blog.csdn.net/tomcat6666712/article/details/88795322?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.control
				
				符号引用
				直接引用

	
	程序计数器：
		概要：程序计数器用来指示jvm要执行的指令。
		介绍：
			程序计数器（Program Counter Register），也有称作为PC寄存器。
			想必学过汇编语言的朋友对程序计数器这个概念并不陌生，在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。
			虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示执行哪条指令的。
				附：
					线程私有,线程之间不相互影响,独立存取;
					程序计数器随线程生随线程灭
			由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。
			？
				多核cpu了
			在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。
			？
				jvm怎么找到对应native方法了
			附：
				由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。


附：
	java进程的内存占用：
		java进程的内存占用大概是 堆内存+堆外内存（DirectBufferSize）+JVM的一些占用
	附：
		直接内存
			java程序运行时非虚拟机数据区的部分。

			在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。
			OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。
			？
			是指我们设置的xmx设置还是
	附：
		3.栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。
附：
	补充1：较新版本的Java（从Java 6的某个更新开始）中，由于JIT编译器的发展和"逃逸分析"技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。
	补充2：运行时常量池相当于Class文件，常量池具有动态性，Java语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String类的intern()方法就是这样的。