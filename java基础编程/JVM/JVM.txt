https://blog.csdn.net/qq_41701956/article/details/81664921
JVM:(JavaVirtualMachine)
	HotSpot VM:
		https://www.cnblogs.com/charlesblc/p/5993804.html
		HotSpot VM 是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。

		HotSpot VM既继承了Sun之前两款商用虚拟机的优点（准确式内存管理），也有许多自己新的技术优势，
			HotSpot VM的热点代码：
				HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。
				如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。
				通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，
				即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。
		在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码，并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。
		附：
			在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。
			Oracle公司宣布在不久的将来（大约应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。
			整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务，
			使用HotSpot的JIT编译器与混合的运行时系统。

	jvm监控工具：(jvisualvm)
		jdk自带监控程序jvisualvm在JDK_HOME/bin下。
		jvisualvm远程监控
			配置
				需要进行远程jvm查看时，需要在启动项目中配置以下内容。

				-Djava.rmi.server.hostname=... -Dcom.sun.management.jmxremote.port=8080 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false
			连接
				在打开的工具中输入上一步骤中配置的hostname及port进行连接。			

JVM加载class文件的原理机制：
	由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。
	当Java源程序的类经过JVM加载、连接（验证、准备和解析）和初始化后，就可被java程序使用。
	类的加载:
		类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。
		
		类加载器：
			Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。
			类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。
			父委托机制（PDM）：
				从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM），PDM更好的保证了Java平台的安全性。
				在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。
				类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。
			关于几个类加载器说明：
				Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
				Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
				System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。
	类的连接:		
		加载完成后，Class对象还不完整，所以此时的类还不可用。
		当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。
		
		附：
			解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。
	类的初始化:
		最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。
	
GC：（Garbage Collector 垃圾收集）
	介绍：
		GC作用：
			回收堆中没有利用价值的内存。
			没有利用价值的内存指的是：没有被其他对象引用到的对象，或者说是引用数为0的对象。	
		为什么要有GC：
			内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。
			Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理，防止大部分的内存泄露，提高内存的使用效率。
	垃圾回收器：
		./垃圾回收器.txt

	附：
		与垃圾回收相关的JVM参数：
			-Xms / -Xmx — 堆的初始大小 / 堆的最大大小
			-Xmn — 堆中年轻代的大小
			-XX:-DisableExplicitGC — 让System.gc()不产生任何作用
			-XX:+PrintGCDetails — 打印GC的细节
			-XX:+PrintGCDateStamps — 打印GC操作的时间戳
			-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小
			-XX:NewRatio — 可以设置老生代和新生代的比例
			-XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布
			-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值
			-XX:TargetSurvivorRatio：设置幸存区的目标使用率
	？
		（不太理解，activity都要被结束了，那么activity里头的引用对象不是应该也要被终结吗？为啥还要null下了）http://blog.csdn.net/dongsheng186/article/details/46563831	




25、Java 中会存在内存泄漏吗，请简单描述。
	答：
		理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；
		*然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。
		例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。
	例	
		下面例子中的代码也会导致内存泄露。
		import java.util.Arrays;
		import java.util.EmptyStackException;

		public class MyStack<T> {
			private T[] elements;
			private int size = 0;

			private static final int INIT_CAPACITY = 16;

			public MyStack() {
				elements = (T[]) new Object[INIT_CAPACITY];
			}

			public void push(T elem) {
				ensureCapacity();
				elements[size++] = elem;
			}

			public T pop() {
				if(size == 0) 
					throw new EmptyStackException();
				return elements[--size];
			}

			private void ensureCapacity() {
				if(elements.length == size) {
					elements = Arrays.copyOf(elements, 2 * size + 1);
				}
			}
		}
		上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。
		然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。
		在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。
		
		为什么会引起内存泄漏了：
			https://www.cnblogs.com/kissazi2/p/3618464.html
			因为数组其实还是引用着对象，要把对应的位置赋为null数组才没有引用对象，
			不然你只能期望等这整个栈失去引用（将被GC回收时），栈内的elements数组一起被GC回收。
			这种问题很隐蔽，通常只要类自己管理内存（如类中有一个Array或List型的结构），那么我们就应该警惕内存泄露的问题。
？
	对象不可达时,其io资源会被自动回收吗
	弱引用，软引用及虚引用对GC的影响
	jvm执行代码的原理了？如一个实例的方法，为什么可以被多个线程调用了