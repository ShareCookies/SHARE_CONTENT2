JVM:
	HotSpot VM:
		https://www.cnblogs.com/charlesblc/p/5993804.html
1.JVM内存
	https://www.cnblogs.com/dolphin0520/p/3613043.html
	Java程序是交由JVM执行的，所以Java内存区域就是指JVM内存区域。
	根据《Java虚拟机规范》的规定，运行时数据区通常包括这几个部分：
		堆(heap)、栈(stack)、方法区(method area)、 本地方法栈(Native Method Stack)、程序计数器(Program Counter Register)
		附：
			在JVM规范中虽然规定了程序在执行期间运行时数据区应该包括这几部分，但是至于具体如何实现并没有做出规定，不同的虚拟机厂商可以有不同的实现方式。
	栈：
		线程关系：
			栈空间为线程私有。
			
		栈空间保存：
			基本数据类型的变量。
				例：int a = 1;//这里的a和1都存放在栈中
			一个对象的引用。
				例：String b = "abc";//这里只有b存放在栈中，而"abc"则存放在堆中
			局部变量。
				局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量）。
				附
					因为是先加载函数才能进行局部变量的定义。
					变量有自己的作用域，一旦离开作用域，变量就会被释放。
	本地方法栈：
　　	本地方法栈与Java栈的作用和原理非常相似。
		区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。
		在JVM规范中，并没有对本地方法栈的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。
		
	堆 ：(是gc的主要区域) 
		与线程关系：
			线程共享
		。
		堆空间保存：
			堆空间主要用于存储对象实例（new出来的对象）和数组（数组也是对象）
				引用才放于方法栈中
			附：
				数组也是对象。
		介绍：
			Java的垃圾回收机制会自动进行回收空间，因此这部分空间也是Java垃圾收集器管理的主要区域。
			但对象的引用一直被持有则回收不了。
			由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代...
	方法区
		线程关系：
			线程共享
		方法区保存：
			用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码(编译后的.class字节码)等数据；
			附：
				程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在常量池中，常量池是方法区的一部分。
				例：
					String str = new String("hello");
					上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区的。

	程序计数器
		线程私有,线程之间不相互影响,独立存取;
		线程私有是不会发生gc.并且他们是随线程生随线程灭。
		介绍：
			程序计数器（Program Counter Register），也有称作为PC寄存器。
			想必学过汇编语言的朋友对程序计数器这个概念并不陌生，在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。
			虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示执行哪条指令的。
			由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。
			在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。
			由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。

		
	附：
		1.方法区和堆都是各个线程共享的内存区域.
		2.栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间.
		3.栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。
	附：
		补充1：较新版本的Java（从Java 6的某个更新开始）中，由于JIT编译器的发展和"逃逸分析"技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。
		补充2：运行时常量池相当于Class文件，常量池具有动态性，Java语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String类的intern()方法就是这样的。
JVM加载class文件的原理机制：
	答：
	由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。
	当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。
		类的加载:
			类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。
			
			类加载器：
				Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。
				类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。
				父委托机制（PDM）：
					从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM），PDM更好的保证了Java平台的安全性。
					在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。
					类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。
				关于几个类加载器说明：
					Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
					Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
					System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。
		类的连接:		
			加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。
		类的初始化:
			最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。

GC：（Garbage Collector 垃圾收集）
	介绍：
		GC作用：
			回收堆中没有利用价值的内存。
			没有利用价值的内存指的是：没有被其他对象引用到的对象，或者说是引用数为0的对象。	
		为什么要有GC：
			内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。
			Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理，防止大部分的内存泄露，提高内存的使用效率。
	垃圾回收器：
		./垃圾回收器.txt

	附：
		与垃圾回收相关的JVM参数：
			-Xms / -Xmx — 堆的初始大小 / 堆的最大大小
			-Xmn — 堆中年轻代的大小
			-XX:-DisableExplicitGC — 让System.gc()不产生任何作用
			-XX:+PrintGCDetails — 打印GC的细节
			-XX:+PrintGCDateStamps — 打印GC操作的时间戳
			-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小
			-XX:NewRatio — 可以设置老生代和新生代的比例
			-XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布
			-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值
			-XX:TargetSurvivorRatio：设置幸存区的目标使用率
	？
		（不太理解，activity都要被结束了，那么activity里头的引用对象不是应该也要被终结吗？为啥还要null下了）http://blog.csdn.net/dongsheng186/article/details/46563831	


25、Java 中会存在内存泄漏吗，请简单描述。
	答：
		理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；
		*然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。
		例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。
	例	
		下面例子中的代码也会导致内存泄露。
		import java.util.Arrays;
		import java.util.EmptyStackException;

		public class MyStack<T> {
			private T[] elements;
			private int size = 0;

			private static final int INIT_CAPACITY = 16;

			public MyStack() {
				elements = (T[]) new Object[INIT_CAPACITY];
			}

			public void push(T elem) {
				ensureCapacity();
				elements[size++] = elem;
			}

			public T pop() {
				if(size == 0) 
					throw new EmptyStackException();
				return elements[--size];
			}

			private void ensureCapacity() {
				if(elements.length == size) {
					elements = Arrays.copyOf(elements, 2 * size + 1);
				}
			}
		}
		上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。
		然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。
		在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。
		
		为什么会引起内存泄漏了：
			https://www.cnblogs.com/kissazi2/p/3618464.html
			因为数组其实还是引用着对象，要把对应的位置赋为null数组才没有引用对象，
			不然你只能期望等这整个栈失去引用（将被GC回收时），栈内的elements数组一起被GC回收。
			这种问题很隐蔽，通常只要类自己管理内存（如类中有一个Array或List型的结构），那么我们就应该警惕内存泄露的问题。
？
	对象不可达时,其io资源会被自动回收吗
	弱引用，软引用及虚引用对GC的影响
	jvm执行代码的原理了？如一个实例的方法，为什么可以被多个线程调用了