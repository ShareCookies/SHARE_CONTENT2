https://blog.csdn.net/lee_nacl/article/details/61419606
https://www.cnblogs.com/bulingpan/p/6416362.html


时间复杂度:
算法：
	概念：
	介绍：
	示例：
		题：
		解：
递归算法：
	https://blog.csdn.net/sinat_38052999/article/details/73303111
	概念：直接或者间接不断反复调用自身来达到解决问题的方法。
	介绍：
		递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在。
		有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。
		有回”是指 : 这些问题的演化过程是一个从大到小的过程，并且有一个明确的终点(临界点)，
		一旦到达了这个临界点，就不用再往更小、更远的地方走下去。
		最后，从这个临界点开始，原路返回到原点，原问题解决。　　
	示例：	
		题：用递归求第10个数，它等于前2数之和，如{1，1，2，3，5}
		解：
			理解：
				 f0 = 1; f1 = 1; fn = f(n-1) + f(n - 2) （n >= 2）
			public class FibonacciSequence {
				public static void main(String[] args){
					System.out.println(Fribonacci(9));

				}
				public static int Fribonacci(int n){
					if(n<2)//终止条件，归
						return 1;
					else
						return Fribonacci(n-1)+Fribonacci(n-2);//解决思路相同的子问题，递
				}
			}
快速排序算法：
	http://www.cnblogs.com/hjy9420/p/5032309.html
	概念：
		快速排序的基本思想是，通过一轮的排序将序列分割成独立的两部分，其中一部分序列的关键字（这里主要用值来表示）均比另一部分关键字小。
		继续对长度较短的序列进行同样的分割，最后到达整体有序。
		在排序过程中，由于已经分开的两部分的元素不需要进行比较，故减少了比较次数，降低了排序时间。
	介绍：
	示例：
		选择开始作为基准值，
			如果比基准值小的交换位置，
				从头开始比较，这时比基准值大的交换位置
				如果没有继续比较下一个。start++
				（为啥要从头比了，因为要以基准值把数组分成两部分，左表的比基准值小，右边的比基准值大）
			如果没有继续比较下一个。end--
		题：
		解：	
			public static void main(String []args){
				int[] a = {12,20,5,16,15,1,30,45,23,9};
				int start = 0;
				int end = a.length-1;
				sort(a,start,end);
				for(int i = 0; i<a.length; i++){
					 System.out.println(a[i]);
				 }
			}
			 
			 public static void sort(int[] a,int low,int high){
				 int start = low;
				 int end = high;
				 int key = a[low];//一轮的排序，基准值是不变的
				 
				 System.out.println(start+":"+end+"aa"+low+":"+high);
				 while(end>start){
					 //从后往前比较
					 while(end>start&&a[end]>=key)  //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较
						 end--;
					 if(a[end]<=key){
						 int temp = a[end];
						 a[end] = a[start];
						 a[start] = temp;
					 }
					 //从前往后比较
					 while(end>start&&a[start]<=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置
						start++;
					 if(a[start]>=key){
						int temp = a[start];
						a[start] = a[end];
						a[end] = temp;
					 }
				 //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用
				 }
				 System.out.println(start+":"+end+"aa"+low+":"+high);
				 //递归
				if(start>low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1
				if(end<high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个
		/*        	为啥可以迭代，因为这是一个以第一个为基准数，
					排序成基准数左边均小于基准数，右边均大于基准数的数组。
					这时
						把左边的数组当成一又可以排序的数组，
						右边的数组也当成一又可以排序的数组。（这里符合子问题与父问题是同一算法的规律）
						一直迭代排序下去，直到发现左边无法排序时，这是左表排序结束，
						开始排序右边，直到右边也无法排序时，整个快速排序结束。（这里是临界点，算归来吧）*/
			 }
三种简单排序算法：
 http://www.cnblogs.com/chengxiao/p/6103002.html
冒泡排序(Bubble Sort):
	https://www.cnblogs.com/shen-hua/p/5422676.html
	概念:
		比较两个相邻的元素，将值大的元素交换至右端。
	介绍:
		依次比较相邻的两个数，将小数放在前面，大数放在后面。
		即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，直至把最大的数放到最后。
	示例:
		N个数字要排序完成，总共进行N-1趟排序。每i趟的排序次数为(N-i)次。
		可用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数
		for(int i=1;i<a.length;i++){
			for(int j=1;j<=a.length-i;j++){
				//比较，交换位置
				if(a[j]<a[j-1]){
	                int temp = a[j];
	                a[j] = a[j-1];
	                a[j-1] = temp;
	            }
			}
		}
简单选择排序：
	概念：
		基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，
		直到所有元素排完为止。
	介绍：
	示例：
		题：
		解：
			for(int i=0;i<a.length;i++){
				int min = i;//每一趟循环比较时，min用于存放较小元素的数组下标，这样当前批次比较完毕最终存放的就是此趟内最小的元素的下标，避免每次遇到较小元素都要进行交换。
				for (int j = i + 1; j < a.length; j++) {
					if (a[j] < a[min]) {
						min = j;
					}
				}
				//进行交换，如果min发生变化，则进行交换
				if (min != i) {
					int temp = a[min];
					a[min] = a[i];
					a[i] = temp;
				}
			}
直接插入排序：
	概念：
	　　直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。
	介绍：
	示例：
		题：
		解：
			int[] a = {12,20,5,16,15,1,30,45,23,9};
			for (int i = 1; i < a.length; i++) {
				int j = i;
				while (j > 0 && a[j] < a[j - 1]) {//while满足条件进入{},不满足条件，程序继续执行，即i++
					int temp = a[j];
					a[j] = a[j-1];
					a[j-1] = temp;
					j--;
				}
			}
			