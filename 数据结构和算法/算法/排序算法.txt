https://blog.csdn.net/ccblogger/article/details/82384480
https://blog.csdn.net/qq_36770641/article/details/82669788


快速排序算法：
	http://www.cnblogs.com/hjy9420/p/5032309.html
	概念：
		快速排序的基本思想是，通过一轮的排序将序列分割成独立的两部分，其中一部分序列的关键字（这里主要用值来表示）均比另一部分关键字小。
		继续对长度较短的序列进行同样的分割，最后到达整体有序。
		优势：在排序过程中，由于已经分开的两部分的元素不需要进行比较，故减少了比较次数，降低了排序时间。
	介绍：
	示例：
		./例/排序/QuickSort.java
		./例/排序/QuickSort案例2.txt
		
		
三种简单排序算法：
	1.冒泡排序
	2.简单选择排序
	3.直接插入排序
	详:
		./例/三种简单排序算法.txt
	插入排序:
		核心思想：
			把一个数插入到一个已排序好数组的恰当位置。
		算法实现：
			从a[1]开始拍（当前指针），因为a[0]已经排好了。
			指针左边值与当前指针值比较，若大则换位且指针向左移一位
				交换后则继续循环比较直到指针无法移动或指针比左边值大
			总结:
				1.指针左边为排好序的。
				2.指针与指针左边比，若大则自身换位，
				若小则互换位，
				换完位后指针左边在于指针左左边比较。
				注:比较时要保证指针左左边位置大于0。
				3.比较完后指针向右移一位，直到指针无法移动时就排好序了。
		循环不变式：
			介绍：使用循环不变式来验证算法的正确性？
		例：
			例1：
				https://www.jianshu.com/p/7cf0656e76dd
				public static void main(String[] args) {
					int arr[] = {2,1,5,3,6,4,9,8,7};
					int temp;
					for (int i=1;i<arr.length;i++){
						//待排元素小于有序序列的最后一个元素时，向前插入。（如果符合if条件，我趁待排元素为移动数）
						if (arr[i]<arr[i-1]){
							temp = arr[i]; // 保存下要换的数字。temp = 1;（temp就是移动数）
							// 该for目的为：待排元素一直与前头的比较，如果前头大于移动数，则向后移动一位，知道移动数小等于前头的数或到0则停下来。
							for (int j=i;j>=0;j--){  
								if (j>0 && arr[j-1]>temp) { // j为1>0 && a[0]为2 > temp // 移动数与当前坐标的前一个数比较
									arr[j]=arr[j-1];// 前面 复制到 后面
								}else {
									arr[j]=temp; // （移动数）
									break;
								}
							}
						}
					}
					第一轮 1,2, 5,3,6,4,9,8,7
					System.out.println(Arrays.toString(arr));
					为null为啥可以排，还在前头了
