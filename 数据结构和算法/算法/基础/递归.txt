递归算法：
	https://blog.csdn.net/sinat_38052999/article/details/73303111
	概念：直接或者间接不断反复调用自身来达到解决问题的方法。
	介绍：
		递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在。
		有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。
		有回”是指 : 这些问题的演化过程是一个从大到小的过程，并且有一个明确的终点(临界点)，
		一旦到达了这个临界点，就不用再往更小、更远的地方走下去。
		最后，从这个临界点开始，原路返回到原点，原问题解决。　
		即：
			1. 调用自己
			2. 有终止条件。　
示例：	
	案例1:
		问题：
			有五个人坐在一起，问第五个人多少岁？他说比第四个人大2岁。问第四个人岁数，他说比第三个人大2岁。问第三个人，又说比第二个人大2岁。问第二个人，说比第一个人大2岁。最后问第一个人，他说是10岁。请问第五个人多大。用递归调用的方法设计程序完成本题目。
		实现：    
			当前函数的部分值来自，上个自身函数。
				上个自身函数要有终止的条件
			public int recursionRule(Integer uptoNum){
				if (uptoNum == 1){ return 10;}
				else {
					return recursionRule(uptoNum-1)+2;
				}
			}
			public static void main(String[] args) {
				NumAddRecursion son = new NumAddRecursion();
				System.out.println(son.recursionRule(5));
			}
	案例2:
		题：用递归求第10个数，它等于前2数之和，如{1，1，2，3，5}
		解：
			理解：
				 f0 = 1; f1 = 1; fn = f(n-1) + f(n - 2) （n >= 2）
			public class FibonacciSequence {
				public static void main(String[] args){
					System.out.println(Fribonacci(9));

				}
				public static int Fribonacci(int n){
					if(n<2)//终止条件，归
						return 1;
					else
						return Fribonacci(n-1)+Fribonacci(n-2);//解决思路相同的子问题，递
				}
			}	
			
附：
	递归前后调用方法区别：
		递归前调用的方法参与大的运算，递归前调用的方法参与小的运算（从不可切分单元倒回去）