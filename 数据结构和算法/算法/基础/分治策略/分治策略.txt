分治策略：
	归并排序，它利用了分治策略。
	归并排序的分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤:
		分解(Divide)步骤：
			(递归)将问题划分为一些子问题，子问题的形式与原问题一样， 只是规模更小。
		解决(Conquer)步骤：
			递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。
			附：
				当子问题足够大，需要递归求解时，我们称之为递归情况( recursive case)。
				当子问题变得足够小，不再需要递归时，我们说递归已经“触底”，进入了基本情况(base case)。

		合并(Combine)步骤：
			将子问题的解组合成原问题的解。(递归范围尾部调用合并)
			附：
				有时，除了与原问题形式完全一样的规模更小的子问题外，还需要求解与原问题不完全一样的子问题。
				我们将这些子问题的求解看做合并步骤的一部分。

	递归式？
		递归式与分治方法是紧密相关的，因为使用递归式可以很自然地刻画分治算法的运行时间。
		一个递归式(recurrence)就是一个等式或不等式，它通过更小的输入上的函数值来描述一个函数。
		例：
			归并排序递归式：（pdf52）
		递归式可以有很多形式。
		子问题的规模不必是原问题规模的一个固定比例。
					
		三种求解递归式：？
			本章介绍三种求解递归式的方法，即得出算法的“Θ”或“O”渐近界的方法。
			代入法
				我们猜测一个界，然后用数学归纳法证明这个界是正确的。
			递归树法
				将递归式转换为一棵树，其结点表示不同层次的递归调用产生的代价。然后采用边界和技术来求解递归式。
			主方法
				可求解形 如下面公式的递归式的界:
				T(n)=aT(n/b) +f(n)
				
				其中a≥1，b>1, f(n)是一个给定的函数。
				这种形式的递归式很常见，它刻画了这样一个分治算法:
					生成a个子问题，每个子问题的规模是原问题规模的1/b，
					分解和合并步骤总共花费时间为f(n)。

			附：
				我们偶尔会遇到不是等式而是不等式的递归式，例如T(n)≤2T(n/2)+Θ(n)。因为这样一种递归式仅描述了T(n)的一个上界，因此可以用大O符号而不是Θ符号来描述其解。
				类似地，如果不等式为T(n)≥2T(n/2)+Θ(n)，则由于递归式只给出了T(n)的一个下界，我们应使用Ω符号来描述其解。
			附：
				递归式技术中的细节：pdf53
					在实际应用中，我们会忽略递归式声明和求解的一些技术细节。
					因为通常这些细节对求解影响不大。
例：
	最大子数组问题.txt