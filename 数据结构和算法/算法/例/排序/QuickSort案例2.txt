	示例：
		选择开始作为基准值，
			如果比基准值小的交换位置，
				从头开始比较，这时比基准值大的交换位置
				如果没有继续比较下一个。start++
				（为啥要从头比了，因为要以基准值把数组分成两部分，左表的比基准值小，右边的比基准值大）
			如果没有继续比较下一个。end--
		
		public static void main(String []args){
			int[] a = {12,20,5,16,15,1,30,45,23,9};
			int start = 0;
			int end = a.length-1;
			sort(a,start,end);
			for(int i = 0; i<a.length; i++){
				 System.out.println(a[i]);
			}
		}
		 
		public static void sort(int[] a,int low,int high){
			 int start = low;
			 int end = high;
			 int key = a[low];//一轮的排序，基准值是不变的
			 
			 System.out.println(start+":"+end+"aa"+low+":"+high);
			 while(end>start){
				 //从后往前比较
				 while(end>start&&a[end]>=key)  //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较
					 end--;
				 if(a[end]<=key){
					 int temp = a[end];
					 a[end] = a[start];
					 a[start] = temp;
				 }
				 //从前往后比较
				 while(end>start&&a[start]<=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置
					start++;
				 if(a[start]>=key){
					int temp = a[start];
					a[start] = a[end];
					a[end] = temp;
				 }
				 // 这里为什么要进行后比较，在前比较，是为了移动基准数到最新的位置然后后面的换位直接与基准数来就行
				 // 为啥要移动基准数了，前比较找到不符合的数会与此时的基准数换位，那么换位后基准数后面的数都是符合规则的
				 // 为啥要移动基准数了，后比较找到不符合的数会与此时的基准数换位，那么换位后基准数前面的数都是符合规则的
				 // 12,20,5,16,15,1,30,45,23,9 （基准数 12）
				 // 9,20,5,16,15,1,30,45,23,12 （0 9） 9,12,5,16,15,1,30,45,23,20 （1 9）
				 // 9,1,5,16,15,12,30,45,23,20 （1 5） 9,1,5,12,15,16,30,45,23,20 （3 5）
				 // 9,1,5,12,15,16,30,45,23,20 （3 3）
			 }
			 //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用
			 System.out.println(start+":"+end+"aa"+low+":"+high);
			 //递归
			if(start>low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1
			if(end<high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个
	/*        	为啥可以迭代，因为这是一个以第一个为基准数，
				排序成基准数左边均小于基准数，右边均大于基准数的数组。
				这时
					把左边的数组当成一又可以排序的数组，
					右边的数组也当成一又可以排序的数组。（这里符合子问题与父问题是同一算法的规律）
					一直迭代排序下去，直到发现左边无法排序时，这是左表排序结束，
					开始排序右边，直到右边也无法排序时，整个快速排序结束。（这里是临界点，算归来吧）*/
		}