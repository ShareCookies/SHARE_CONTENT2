复杂度:
	https://blog.csdn.net/weixin_30340819/article/details/98148676
	https://blog.csdn.net/qq_17534301/article/details/82872357
	介绍：
		那么我们应该如何去衡量不同算法之间的优劣呢。主要还是从算法所占用的「时间」和「空间」两个维度去考量。
		时间维度：
			是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
			但时间复杂度表示法公式不是用来计算程序具体耗时的，而是用来表示代码执行时间的增长变化趋势的。
			
			大O符号表示法：
				时间复杂度的公式是： 
					T(n) = O( f(n) )，
					其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，
					这个公式的全称是：算法的渐进时间复杂度。
				例：
					for(i=1; i<=n; ++i)
					{
					   j = i;
					   j++;
					}
					假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，
					那么这个例子的第一行耗时是1个颗粒时间，
					第三行的执行时间是 n个颗粒时间，
					第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），
					那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) =  (1+2n)*颗粒时间。
					从这个结果可以看出，这个算法的耗时是随着n的变化而变化，
					因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) =  O(n)
						为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

						所以上面的例子中，如果n无限大的时候，T(n) =  time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) =  O(n) 就可以了。			
				常见的时间复杂度量级有：
					...

		空间维度：
			是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。
			空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。
			例：
				空间复杂度 O(n)
					我们先看一个代码：
					int[] m = new int[n]
					for(i=1; i<=n; ++i)
					{
					   j = i;
					   j++;
					}
					这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)

什么是算法的稳定性：
	https://segmentfault.com/q/1010000014749041
	

递归:
	核心思想:自己调用自己
	例：
		案例1:
			问题：
				有五个人坐在一起，问第五个人多少岁？他说比第四个人大2岁。问第四个人岁数，他说比第三个人大2岁。问第三个人，又说比第二个人大2岁。问第二个人，说比第一个人大2岁。最后问第一个人，他说是10岁。请问第五个人多大。用递归调用的方法设计程序完成本题目。
			实现：    
				当前函数的部分值来自，上个自身函数。
					上个自身函数要有终止的条件
				public int recursionRule(Integer uptoNum){
					if (uptoNum == 1){ return 10;}
					else {
						return recursionRule(uptoNum-1)+2;
					}
				}
				public static void main(String[] args) {
					NumAddRecursion son = new NumAddRecursion();
					System.out.println(son.recursionRule(5));
				}
		案例2：
			./例/递归.txt
排序算法：
	./排序算法.txt

常见算法：
	https://blog.csdn.net/lee_nacl/article/details/61419606
	https://www.cnblogs.com/bulingpan/p/6416362.html