复杂度:
	https://blog.csdn.net/weixin_30340819/article/details/98148676
	https://blog.csdn.net/qq_17534301/article/details/82872357
	介绍：
		那么我们应该如何去衡量不同算法之间的优劣呢。主要还是从算法所占用的「时间」和「空间」两个维度去考量。
		时间维度：
			介绍：
				我们通常用「时间复杂度」来指执行当前算法所消耗的时间。
				但时间复杂度表示法公式不是用来计算程序具体耗时的，而是用来表示代码执行时间的增长变化趋势的。
			大O符号表示法：（时间复杂度的公式）
				公式： 
					T(n) = O( f(n) )，
					其中f(n) 表示每行代码执行次数之和，而 O 表示T(n)与f(n)成正比例关系。
					这个公式的全称是：算法的渐进时间复杂度。
					总结：
						时间复杂度理解为执行次数最多的那行代码就行了。
				例：
					for(i=1; i<=n; ++i)
					{
					   j = i;
					   j++;
					}
					假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，
					那么这个例子的第一行耗时是1个颗粒时间，
					第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），
					那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) =  (1+2n)*颗粒时间。
					从这个结果可以看出，这个算法的耗时是随着n成正比变量，因此我们可以简化的将这个算法的时间复杂度表示为：T(n) =  O(n)
						为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。
						所以上面的例子中，如果n无限大的时候，T(n) =  time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) =  O(n) 就可以了。
					附：
					最坏情况：
						我们查找一个有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置，那么时间复杂度为O(n)。
						通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间。
				附：
				常见的时间复杂度量级有：
					常数阶O(1) ,对数阶O(logN),线性阶O(n),线性对数阶O(nlogN),平方阶O(n²),立方阶O(n³),K次方阶O(n^k),指数阶(2^n)
					上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。
						例：n为32 ，那么为 1，5，32，32*5，32*32， 32*32*32，32^k?，2^32?
					对数阶O(logN)：
						int i = 1;
						while(i<n)
						{
							i = i * 2;
						}
						从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。
						我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n
						也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)
			...:
				平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法
		空间维度：
			是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。
			空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。
			例：
				空间复杂度 O(n)
					我们先看一个代码：
					int[] m = new int[n]
					for(i=1; i<=n; ++i)
					{
					   j = i;
					   j++;
					}
					这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)
什么是算法的稳定性：
	https://segmentfault.com/q/1010000014749041
递归:
	核心思想:自己调用自己
	例：
		案例1:
			问题：
				有五个人坐在一起，问第五个人多少岁？他说比第四个人大2岁。问第四个人岁数，他说比第三个人大2岁。问第三个人，又说比第二个人大2岁。问第二个人，说比第一个人大2岁。最后问第一个人，他说是10岁。请问第五个人多大。用递归调用的方法设计程序完成本题目。
			实现：    
				当前函数的部分值来自，上个自身函数。
					上个自身函数要有终止的条件
				public int recursionRule(Integer uptoNum){
					if (uptoNum == 1){ return 10;}
					else {
						return recursionRule(uptoNum-1)+2;
					}
				}
				public static void main(String[] args) {
					NumAddRecursion son = new NumAddRecursion();
					System.out.println(son.recursionRule(5));
				}
		案例2：
			./例/递归.txt
排序算法：
	./排序算法.txt
常见算法：
	https://blog.csdn.net/lee_nacl/article/details/61419606
	https://www.cnblogs.com/bulingpan/p/6416362.html