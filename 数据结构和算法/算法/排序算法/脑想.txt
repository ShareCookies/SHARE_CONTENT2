快排思想：
	快排是符合分治思想的。
	分解: 
		元素分成两部分，左边都比右边小的两部分元素。
		附：
			1. 遍历所有元素
			2. 换值换位（要确保值小要位小 值大要位大才不换）
			2.2 经过以上换后，会确保主元左边都比右边小
	解决: 
		这里我把递归算到解决里，因为分解到最小颗粒时，已经算完成了排序的解决。（当然在别的算法里分解到最小颗粒 可能只属于分解步骤）
	合并: 此处无需合并
快排实现：
	开始快排：
	//附:左坐标小右坐标是迭代的终止条件
	if（左元素坐标<右标）{
		分解步骤。
			->能得到左右两个元素部分
		左递归
		右递归
	}

	分解步骤:
	all元素数组，本次分解开始的元素坐标位置，结标。
	1. 第一个元素标为源元素。
		->整个数组会被分为左边比该元素小 右边比该元素大
	2. 从开始位置遍历本次所有分解元素
	2.1 如果位置大，元素小那么换。
		附:
		2. 位置小是因为要确定跟你对比的元素是左边的还是右边的
		1.换是指值换、坐标换。
		
	2.2 如果位置小，元素大那么换。
		可以用else，但最好还是在判断吧，因为其本身就复合规则，那就无需交换，避免耗费资源
		
	附：比这2种情况就够了，因为位置小和大的不符合情况都解决了。
