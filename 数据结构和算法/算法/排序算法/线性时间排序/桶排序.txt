思路：
	1. 桶排序则假设输人是由一个随机过程产生，该过程将元素均匀、独立地分布在[0，1)区间上。
		即桶排序假设输入数据服从均匀分布，(见C.2节中均匀分布的定义).
	2. 将[O，1)区间划分为n个相同大小的子区间(或称为桶)。
	3. 然后将n个输入数分别放到各个桶中。
		因为输人数据是均匀、独立地分布在[O，1)区间上，所以一般不会出现很多数落在同一个桶中的情况。
		有冲突的可用链表存放。
	4. 为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。
实现：
	//假设输入是一个包含n个元素的数组A，且每个元素A[i]满足0≤A[i]<1.
	//此外，算法还需要一个临时数组B[0..n-1]来存放链表(即桶)，
	//并假设存在一种用于维护这些链表的机制(10.2节将介绍如何实现链表的一些基本操作)。
	BUCKET_SORT(a){
		int n = a.length;
		let b[0..n-1] be a new array;
		for(int i =0;i<n;i++){
			b[i] = null;
		}
		// 1. 输入值插入到各个桶中
		for(int i=0;i<n;i++){
			insert a[i] into b[（a[i]）];
		}
		// 2. 桶排
		for (int i=0;i<n;i++){
			// 桶内部先排好
			sort list B[i] with insertion sort
			// 把各个桶连起来即可。(在单独放到一个数组或直接for在输出都行)
			concatenate the lists B[0],B[1],**,B[n- 1] together in order
		}
	}
算法的正确性验证:
	pdf127
桶排序耗时：
	pdf128