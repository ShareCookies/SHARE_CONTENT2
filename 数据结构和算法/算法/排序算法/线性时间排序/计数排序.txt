8.2计数排序
计数排序的基本思想:
	计数排序假设n个输人元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。

	对每一个输人元素x,确定小于x的元素个数。利用这一信息，就可以直接把x放到它在输出数组中的位置上了。
		例
			如果有17个元素小于x，则x就应该在第18个输出位置上。
	附：
		当有几个元素相同时，这一方案要略做修改。因为不能把它们放在同一个输出位置上。

实现：
	假设输人是一个数组A[1..n], A.length=n。
	我们还需要两个数组: B[1..n]存放排序的输出，C[0..k]提供临时存储空间。
	COUNTING_SORT(a, b, k){
		// 1. 计数
		//let C[0,k] be a new array;
		for(int i=0;i<k;i++){
			c[i]=0;
		}
		//C[i]中保存的就是等于i的元素的个数(i=0..k)
		for(int j=0;j<a.length;j++){
			c[a[j]] = c[a[j]]+1;
		}
		//通过加总计算确定有多少输入元素是小于或等于i的(i=0..k)。
		for(i=0;i<k;i++){
			c[i] = c[i]+c[i-1];
		}
		//2. 排序
		//for循环部分，把每个元素A[j]放到它在输出数组B中的正确位
		for(int j=a.length-1;j>=0;j--){
			b[c[a[j]]] = a[j];
			c[a[j]] = c[a[j]]-1;
		}
	}
计数排序的时间代价：
	第2~3行的for循环所花时间为Θ(k)，第4~5行的for循环所花时间为Θ(n)，第7~8行的for循环所花时间为Θ(k)，第10~12行的for循环所花时间为Θ(n)。
	总的时间代价就是Θ(k+n)。在实际工作中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为Θ(n)。
	附：
		计数排序的下界优于我们在8.1节中所证明的Ω(nlgn)，因为它并不是一个比较排序算法。事实上，它的代码中完全没有输人元素之间的比较操作。相反，计数排序是使用输入元索的实际值来确定其在数组中的位置。
		当我们脱离了比较排序模型的时候，Q(nlgn)这一下界就不再适用了 。
注：
	计数排序的一个重要性质就是它是稳定的:
	具有相同值的元素在输出数组中的相对次序与它们在输人数组中的相对次序相同。
	也就是说，对两个相同的数来说，在输人数组中先出现的数，在输出数组中也位于前面。
		例：1 3 3，第一个3因为先取出来，所以排在1 第二个3后取排在2
	通常，这种稳定性只有当进行排序的数据还附带卫星数据时才比较重要。
	附：
		计数排序的稳定性很重要的另一个原因是:计数排序经常会被用作基数排序算法的一个子过程。我们将在下一节中看到，为了使基数排序正确运行，计数排序必须是稳定的。
