堆排序的时间复杂度是O(nlgn)。
堆排序引入了另一种算法设计技巧:使用-种我们称为“堆”的数据结构来进行信息管理。
堆排序同样具有空间原址性:任何时候都只需要常数个额外的元素空间存储临时数据。！

堆：
	(二叉)堆是一个数组，但它可以被看成一个近似的完全二叉树。
		树上的每-个结点对应数组中的一个元素。
		除了最底层外，该树是完全充满的，而且是从左向右填充。
		？
			完全二叉树
		堆有两个元素：
			A. length(通常)给出数组元素的个数
			A. heap-size表示有多少个堆元素存储在该数组中。
			附：
				也就是说，虽然A[1. .A. length]可能都存有数据，但只有A[1.. A. heap-size ]中存放的是堆的有效元素，这里，0≤A. heap-size≤A. length。
	堆树构造：
		树的根结点是A[1]，这样给定一个结点的下标i，我们很容易计算得到它的父结点、左孩子和右孩子的下标:
		PARENT (i)
			return [i/2]
		LEFT (i)
			return 2i
		RIGHT (i)
			return 2i+1
	附：
		在大多数计算机上，通过将i的值左移-位， LEFT过程可以在-条指令内计算出2i。
		采用类似方法，在RIGHT过程中也可以通过将i的值左移1位并在低位加1,快速计算得到2i+1.
		至于PARENT过程，则可以通过把i的值右移1位计算得到[i/2]。在堆排序的好的实现中，这三个函数通常是以“宏”或者“内联函数”的方式实现的。
		？后续在精准
		
	附：
		6.1-7 证明: 当用数组表示存储n个元素的堆时，叶结点下标分别是[n/2]+1, [n/2]+2,..., n
			最后的一个节点为[n/2]，因为[n/2]后的节点也找到叶子节点了.
				[n/2] + 1后的叶子节点为2[n/2] + 2，最大的数(奇数情况)为2[n/2] + 1
			所以最后一个节点后的数都肯定是叶子节点，因为他们找不到后代了。

	例图：
		堆.png
最大堆和最小堆：
	二叉堆可以分为两种形式:最大堆和最小堆。在这两种堆中，结点的值都要满足堆的性质，但-些细节定义则有所差异。
		？堆性质指什么，堆树构造吗
	最大堆：
		在最大堆中，最大堆性质是指除了根以外的所有结点i都要满足:
			A[PARENT(i)]≥A[i]
			也就是说，某个结点的值至多与其父结点一样大。
		因此，堆中的最大元素存放在根结点中;并且，在任-子树中，该子树所包含的所有结点的值都不大于该子树根结点的值。
	最小堆：
		最小堆性质是指除了根以外的所有结点i都有
			A[PARENT(i)]≤A[i]
		最小堆中的最小元素存放在根结点中。
维护堆的性质：(维护最大堆的性质)
	MAX-HEAPIFY是用于维护最大堆性质的重要过程。
	MAX-HEAPIFY中，我们假定根结点为LEFT(i)和RIGHT(i)的二叉树都是最大堆，但这时A[i]有可能小于其孩子，这样就违背了最大堆的性质。
		即只有i是有问题的，不符合最大堆性质。
	MAX-HEAPIFY通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根结点的子树重新遵循最大堆的性质。

	MAX-HEAPIFY(A,i)//它的输人为 一个数组A和 一个下标i。
		l= LEFT (i)
		r= RIGHT (i)
		
		//i与左右比，找出最大的。
		if l ≤ A.heap-size and A[l] > A[i]
			largest = l
		else largest = i
		if r≤A. heap-size and A[r] > A[largest]
			largest = r
		// 如果A[i]是最大的，那么以i为根结点的子树已经是最大堆，程序结束。
		if larget≠i
			exchange A[i] with A[largest] //与最大的互换位置
			//在交换后，下 标为largest的结点的值是原来的A[i]，于是以该结点为根的子树又有可能会违反最大堆的性质。
			//因此，需要对该子树递归调用MAX-HEAPIFY。
			MAX-HEAPIFY (A, largest)
			
			
			在交换后，下 标为largest的结点的值是原来的A[i]，于是以该结点为根的子树又有可能会违反最大堆的性质。
			因此，需要对该子树递归调用MAX-HEAPIFY。
	实现思路总结：
		与左右节点对比，与最大的交换(此时1层符合最大堆性质)，迭代新节点(被交互的节点又可能不符合堆性质)
	时间复杂度：O(h)
		？
建堆：(建最大堆)
	我们可以用自底向上的方法利用过程MAX-HEAPIFY把-一个大小为n=A.length的数组A[1..n]转换为最大堆。
	通过练习6.1-7可以知道，子数组A([n/2] + 1...n)中的元素都是树的叶结点。
	每个叶结点都可以看成只包含一个元素的堆，因此只要对树中的其他结点都调用一次MAX-HEAPIFY，即可实现建堆。(此过程就是BUILD-MAX-HEAP)
		！
			为什么要从[A.length/2]倒推了！因为...
	BUILD-MAX-HEAP(A)
		A.heap-size = A.length，
		for i = [A.length/2]  downto 1
			MAX-HEAPIFY(A, i)
	附：
		证明BUILD-MAX-HEAP正确性：
			循环不变式
			...
			
堆排序算法：
	思路:
		1. 初始时候，堆排序算法利用BUILD-MAX HEAP将输人数组A[1..n]建成最大堆，其中n=A.length。
		2. 因为数组中的最大元素总在根结点A[1]中，通过把它与A[n]进行互换，我们可以让最大元素放到正确的位置。这时候，如果我们从堆中去掉结点n(这一操作可以通过减少A.heap-size的值来实现)，
		3. 剩余的结点中，新的根结点可能会违背最大堆的性质。为了维护最大堆的性质，我们要做的是调用MAX-HEAPIFY(A，1)，从而在A[1..n- 1]上构造一个新的最大堆。
		4. 堆排序算法会不断重复这一过程，直到堆的大小从n-1降到2。
	例：
		HEAPSORT(A)
			BUILD MAX-HEAP(A)
			for i = A. length downto 2
				exchange A[1] with A[i]
				A. heap-size = A. heap-size一1
				MAX-HEAPIFY(A, 1)
	附：
		6.4-4 证明:在最坏情况下，HEAPSORT的时间复杂度是O(nlgn)?。

优先队列: 
	介绍：
		快速排序的性能一般会优于堆排序。但堆仍然有很多应用，如作为高效的优先队列。
		优先队列(priority queue)是一种用来维护由一组元素构成的集合S的数据结构，其中的每一个元素都有一个相关的值，称为关键字(key)。
		一个最大优先队列支持以下操作:
			INSERT(S, x): 把元素x插入集合S中。这一操作等价于S=S ∪ {x}。
			MAXIMUM(S):返回S中具有最大键字的元素。,
			EXTRACT-MAX(S):去掉并返回s中的具有最大键字的元素。
			INCREASE-KEY(S，x, k):将元素x的关键字值增加到k，这里假设k的值不小于x的原关键字值。
		最大优先队列的应用：
			1. 
				其中一个就是在共享计算机系统的作业调度。
				最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。
				当一个作业完成或者被中断后，调度器调用EXTRACT-MAX从所有的等待作业中，选出具有最高优先级的作业来执行。
				在任何时候，调度器可以调用INSERT把一个新作业加人到队列中来。
			2. 
				从一百万个数字中得到前10大的数
				https://blog.csdn.net/sinat_27143551/article/details/80644764
			先取出前100个数，维护一个100个数的最小堆，遍历一遍剩余的元素，在此过程中维护堆就可以了。
	

显然，优先队列可以用堆来实现。
堆元素构成：关键字，句柄。
	对一个像作业调度或事件驱动模拟器这样的应用程序来说，优先队列的元素对应着应用程序中的对象。通常，我们需要确定哪个对象对应一 个给定的优先队列元素。
	因此，在用堆来实现优先队列时，需要在堆中的每个元素里存储对应对象的句柄(handle)。句柄(如一个指针或一个整型数等)的准确含义依赖于具体的应用程序。
	同样，在应用程序的对象中，我们也需要存储一 个堆中对应元素的句柄。通常，这一句柄是数组的下标。
	由于在堆的操作过程中，元素会改变其在数组中的位置，因此，在具体的实现中，在重新确定堆元素位置时，我们也需要更新相应应用程序对象中的数组下标。因为对应用程序对象的访问细节强烈依赖于应用程序及其实现方式，所以这里我们不做详细讨论。需要强调的是，这些句柄也需要被正确地维护。
最大优先队列操作的实现：
	MAXIMUM操作:
		过程HEAP_MAXIMUM可以在Θ(1)时间内实现MAXIMUM操作。
		HEAP-MAXIMUM(A)
			return A[1]
	EXTRACT-MAX操作:
		过程HEAP-EXTRACT-MAX实现EXTRACT-MAX操作。它与HEAPSORT过程中的for循环体部分(第3~5行)很相似。
		HEAP-EXTRACT-MAX(A)
			if A. heap-size < 1
				error“heap underflow”
			max = A[1]
			A[1] = A[A.heap-size]
			A.heap-size = A.heapsize -1
			MAX-HEAPIFY(A, 1)
			return max
		HEAP-EXTRACT-MAX的时间复杂度为O(lgn)。因为除了时间复杂度为O(lgn)的MAX-HEAPIFY以外，它的其他操作都是常数阶的。
		思路:
			获取第一个元素(最大元素)，第一个元素赋值为尾部元素并剔除掉尾部元素，维护堆性质。
	INCREASE-KEY操作：
		HEAP-INCREASE-KEY能够实现INCREASE-KEY操作。
		在包含n个元素的堆上，HEAP-INCREASE KEY的时间复杂度是O(lgn)。
			这是因为在算法第3行做了关键字更新的结点到根结点的路径长度为O(lgn)。

		实现思路：
			HEAP-INCREASE-KEY能将元素A[i]的关键字更新为新值(新增一定大于当前值)。
			因为增大A[i]的关键字可能会违反最大堆的性质，所以当前元素会不断地与其父结点进行比较，如果当前元素的关键字较大，则当前元素与其父结点进行交换。
			这一过程会不断地重复，直到当前元素的关键字小于其父结点时终止，因为此时已经重新符合了最大堆的性质。
		循环不变量：
			准确的循环不变量表示见练习6.5-5

		HEAP-INCREASE-KEY(A, i, key)
			ifkey< A[i]
				error“new key is smaller than current key"
			A[i]= key
			while i> 1 and A[PARENT(i)] < A[i]
				exchange A[i] with A[PARENT(i)]
				i = PARENT(i)
MAX-HEAP-INSERT能够实现INSERT操作。它的输人是要被插人到最大堆A中的新元素
的关键字。MAX HEAP-INSERT首先通过增加一一个关键字为-∞的叶结点来扩展最大堆。然后
调用HEAP-INCREASE-KEY为新结点设置对应的关键字，同时保持最大堆的性质。
MAX HEAP-INSERT(A, key)
1 A.heap-size = A. heap-size + 1
2 A[A. heap-size] =-∞
3 HEAP-INCREASE-KEY(A, A. heap-size, key)
在包含n个元素的堆上，MAX-HEAP INSERT的运行时间为O(lgn)。
总之，在一个包含n个元素的堆中，所有优先队列的操作都可以在O(lgn)时间内完成。
