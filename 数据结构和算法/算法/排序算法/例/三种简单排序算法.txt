三种简单排序算法：
 http://www.cnblogs.com/chengxiao/p/6103002.html
	冒泡排序(Bubble Sort):
		https://www.cnblogs.com/shen-hua/p/5422676.html
		概念:
			比较两个相邻的元素，将值大的元素交换至右端。
		介绍:
			依次比较相邻的两个数，将小数放在前面，大数放在后面。
			即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，直至把最大的数放到最后。
		示例:
			N个数字要排序完成，总共进行N-1趟排序。每i趟的排序次数为(N-i)次。
			可用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数
			for(int i=1;i<a.length;i++){
				for(int j=1;j<=a.length-i;j++){
					//比较，交换位置
					if(a[j]<a[j-1]){
						int temp = a[j];
						a[j] = a[j-1];
						a[j-1] = temp;
					}
				}
			}
	简单选择排序：
		概念：
			基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，
			直到所有元素排完为止。
		介绍：
		示例：
			题：
			解：
				for(int i=0;i<a.length;i++){
					int min = i;//每一趟循环比较时，min用于存放较小元素的数组下标，这样当前批次比较完毕最终存放的就是此趟内最小的元素的下标，避免每次遇到较小元素都要进行交换。
					for (int j = i + 1; j < a.length; j++) {
						if (a[j] < a[min]) {
							min = j;
						}
					}
					//进行交换，如果min发生变化，则进行交换
					if (min != i) {
						int temp = a[min];
						a[min] = a[i];
						a[i] = temp;
					}
				}
	直接插入排序：
		概念：
		　　直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。
		介绍：
		示例：
			题：
			解：
				int[] a = {12,20,5,16,15,1,30,45,23,9};
				for (int i = 1; i < a.length; i++) {
					int j = i;
					while (j > 0 && a[j] < a[j - 1]) {//while满足条件进入{},不满足条件，程序继续执行，即i++
						int temp = a[j];
						a[j] = a[j-1];
						a[j-1] = temp;
						j--;
					}
				}
				
		废2：
		插入排序:
			核心思想：
				把一个数插入到一个已排序好数组的恰当位置。
			算法实现：
				从a[1]开始拍（当前指针），因为a[0]已经排好了。
				指针左边值与当前指针值比较，若大则换位且指针向左移一位
					交换后则继续循环比较直到指针无法移动或指针比左边值大
				总结:
					1.指针左边为排好序的。
					2.指针与指针左边比，若大则自身换位，
					若小则互换位，
					换完位后指针左边在于指针左左边比较。
					注:比较时要保证指针左左边位置大于0。
					3.比较完后指针向右移一位，直到指针无法移动时就排好序了。
			循环不变式：
				介绍：使用循环不变式来验证算法的正确性？
			例：
				例1：
					https://www.jianshu.com/p/7cf0656e76dd
					public static void main(String[] args) {
						int arr[] = {2,1,5,3,6,4,9,8,7};
						int temp;
						for (int i=1;i<arr.length;i++){
							//待排元素小于有序序列的最后一个元素时，向前插入。（如果符合if条件，我趁待排元素为移动数）
							if (arr[i]<arr[i-1]){
								temp = arr[i]; // 保存下要换的数字。temp = 1;（temp就是移动数）
								// 该for目的为：待排元素一直与前头的比较，如果前头大于移动数，则向后移动一位，知道移动数小等于前头的数或到0则停下来。
								for (int j=i;j>=0;j--){  
									if (j>0 && arr[j-1]>temp) { // j为1>0 && a[0]为2 > temp // 移动数与当前坐标的前一个数比较
										arr[j]=arr[j-1];// 前面 复制到 后面
									}else {
										arr[j]=temp; // （移动数）
										break;
									}
								}
							}
						}
						第一轮 1,2, 5,3,6,4,9,8,7
						System.out.println(Arrays.toString(arr));
						为null为啥可以排，还在前头了
