概要：
	许多应用都需要一种动态集合结构， 它至少要支持INSERT、SEARCH和DELETE字典操作。
	散列表(hash table也叫哈希表)就是这样的一种有效数据结构。散列是一种极其有效和实用的技术:基本的字典操作平均只需要0(1)的时间。
		附：尽管最坏情况下，散列表中查找一个元素的时间与链表中查找的时间相同，达到了O(n)。
		然而在实际应用中，散列查找的性能是极好的。在一些合理的假设下，在散列表中查找一个元素的平均时间是O(1)。
	散列表是普通数组概念的推广。
		为什么这么说了.首先要理解下寻址表。
		用数组可以构成一个直接寻找表，缺点一一对应很耗空间。
		而散列表则是进行对地址映射(数组下标映射)优化了，所以为什么说散列表是普通数组概念的推广。
		
直接寻址表(直接数组寻址)
	介绍：
		在直接寻址方式下，具有关键字k的元素被存放在槽k中。
		优点：
			由于对普通数组可以直接寻址，使得能在O(1)时间内访问数组中的任意位置。
			如果存储空间允许，我们可以提供一个数组，为每个可能的关键字保留一个位置，以利用直接寻址技术的优势。
		缺点：
			直接寻址技术的缺点是非常明显的，如果全域U很大，则在一台标准的计算机可用内存容量中，要存储大小为|U|的一张表T也许不太实际，甚至是不可能的。
			还有，实际存储的关键字集合K相对U来说可能很小，使得分配给T的大部分空间都将浪费掉。
	例：
		./imgs/直接寻址表.png
	实现：
		如果构成直接寻址表：
			为表示动态集合，我们用一个数组，或称为直接寻址表(direct-address table)，记为T[0..m—1]。
			其中每个位置，或称为槽(slot)，对应全域U中的一个关键字。
			槽k指向集合中一个关键字为k的元素。如果该集合中没有关键字为k的元素，则T[k]=NIL。
			附：
				对于某些应用，直接寻址表本身就可以存放动态集合中的元素。
					也就是说，并不把每个元素的关键字及其卫星数据都放在直接寻址表外部的一个对象中，再由表中某个槽的指针指向该对象，
					而是直接把该对象存放在表的槽中，从而节省了空间。
				当关键字的全域U比较小时，直接寻址是一种简单而有效的技术。
					假设某应用要用到一个动态集合，其中每个元素都是取自于全域U={0，1，…，m-l}中的一个关键字，这里m不是一个很大的数。
					另外，假设没有两个元素具有相同的关键字。
		
	
散列表：
	介绍：
		当实际存储的关键字数目比全部的可能关键字总数要小时，采用散列表就成为直接数组寻址的一种有效替代，因为散列表使用一个长度与实际存储的关键字数目成比例的数组来存储。
		在散列表中，不是直接把关键字作为数组的下标，而是根据关键字计算出相应的下标。
		在散列方式下，关键字k的元素存放在槽h(k)中;即利用散列函数(HashFunction)h,通过关键字k计算出槽的位置。
	例：
		./imgs/散列表.png
		
		函数h将关键字的全域U映射到散列表(hash table)T[0. . m-1]的槽位上。
			这里散列表的大小m一般要比|U|小得多。
				散列函数缩小了数组下标的范围，即减小了数组的大小，使其由|U|减小为m。
			我们可以说一个具有关键字k的元素被散列到槽h(k).上，也可以说h(k)是关键字k的散列值。
	冲突：
		概要：
			所谓冲突，就是指多个关键字映射到数组的同一个下标。
			11.2 节介绍这种技术的主要思想，着重介绍通过“链接”( chaining)方法解决“冲突”( collision)。
			11.4 节介绍“开放寻址法"(openaddressing)，它是处理冲突的另一种方法。	
		介绍：
			这里存在一个问题:两个关键字可能映射到同一个槽中。我们称这种情形为冲突( collision)。
			由于|U|>m，故至少有两个关键字其散列值相同，所以要想完全避免冲突是不可能的。			
			因此我们一方面可以通过精心设计的散列函数来尽量减少冲突的次数，另一方面仍需要有解决可能出现冲突的办法。
				如何算精心设计的散列函数：
					使h尽可能的“随机”，从而避免冲突或者使冲突的次数最小化。
					实际上术语“散列"原意就是随机混杂和拼凑，即体现了这种思想。
		通过链接法(chaining)解决冲突：
			在链接法中，把散列到同一槽中的所有元素都放在一个链表中。
			槽j中有一个指针，它指向存储所有散列到j的元素的链表的表头;如果不存在这样的元素，则槽j中为NIL。
			在采用链接法解决冲突后，散列表T上的字典操作就很容易实现：
				...p145
			例：
				./imgs/散列表之链表法.png

			链接法散列的分析：
				...
		开放寻址法(open addressing)	:
			...p151
	散列函数：
		导读：11.3 节介绍如何利用散列函数根据关键字计算出数组的下标。
		法(用除法进行散列和用乘法进行散列)本质上属于启发式方法，而第三种方法(全域散列)则利用
了随机技术来提供可证明的良好性能。

		介绍：
			除法进行散列和用乘法进行散列本质上属于启发式方法。
			而全域散列则利用了随机技术来提供可证明的良好性能。
			好的散列函数的特点
				一个好的散列函数应(近似地)满足简单均匀散列假设:每个关键字都被等可能地散列到m个槽位中的任何一个，并与其他关键字已散列到哪个槽位无关。
				遗憾的是，-般无法检查这-条件是否成立，因为很少能知道关键字散列所满足的概率分布，而且各关键字可能并不是完全独立的。
			将关键字转换为自然数
				多数散列函数都假定关键字的全域为自然数集N={0，1，2，..}因此，如果所给关键字不是自然数，就需要找到-种方法来将它们转换为自然数。

		3种散列函数：
			...p147
			在后面的内容中，假定所给的关键字都是自然数。
			11.3. 1除法散列法
				在用来设计散列函数的除法散列法中，通过取k除以m的余数，将关键字k映射到m个槽中的某-一个上，即散列函数为:h(k) = k mod m.
				附：
					避免选择m的某些值：
						当应用除法散列法时，要避免选择m的某些值。例如，m不应为2的幂，因为如果m=2",则h(k)就是k的p个最低位数字。除非已知各种最低p位的排列形式为等可能的...
				例：
					-一个不太接近2的整数幂的素数，常常是m的-一个较好的选择。
					例如，假定我们要分配一张散列表并用链接法解决冲突，表中大约要存放n=2000个字符串，其中每个字符有8位。
					如果我们不介意一次不成功的查找需要平均检查3个元素，这样分配散列表的大小为m=701。
					选择701这个数的原因是，它是-一个接近2000/3但又不接近2的任何次幂的素数。把每个关键字k视为-一个整数，则散列函数如下:
						h(k) = k mod 701
			...
	总结：
		散列表就是根据元素关键字找到元素所在位置。
		散列函数：
			把一个具有关键字k的元素散列到槽h(k)上，h函数即为散列函数。
			散列表的大小:
				约要存放n=2000个字符串,如果我们不介意一次不成功的查找需要平均检查3个元素，这样分配散列表的大小为m=701。
			除法散列函数：
				h(k) = k mod 701
		散列值：
			h(k)
		通过链接法(chaining)解决冲突：
			槽j中有一个指针，它指向存储所有散列到j的元素的链表的表头;如果不存在这样的元素，则槽j中为NIL。

完全散列：
	11.5 节介绍当关键字集合是静态存储(即关键字集合一旦存入后就不再改变)时，“完全散列”(perfect hashing)如何能够在0(1)的最坏情况时间内完成关键字查找。
	...p156
	使用散列技术通常是个好的选择，不仅是因为它有优异的平均情况性能，而且当关键字集合是静态(static)时，散列技术也能提供出色的最坏情况性能。
	所谓静态，就是指一旦各关键字存入表中，关键字集合就不再变化了。一些应用存在着天然的静态关键字集合，如程序设计语言中的保留字集合，或者CD-ROM上的文件名集合。
	一种散列方法称为完全散列(perfect hashing),如果该方法进行查找时，能在最坏情况下用0(1)次访存完成。
	