基本数据结构：
	附：
		动态集合：
			集合作为算机科学的基础，就如同他们在数学中所起的作用。
			数学中的集合是不变的,而由算法操作的集合却在整个过程中增大,缩小或发生其他变化。我们称这样的集合为动态集合。
			
			附:
				10-14章描述了能够用于实现动态集合的几种数据结构。
					本书后面的算法中也会使用其中多种构造来解决各种不同问题。
		指针和对象的实现p134
			当有些语言不支持指针和对象数据类型时，应当如何实现它们呢。
			本节我们将利用数组和数组下标来构造对象和指针。
			...
	栈（stack）：
		介绍：
			1.栈实现的是一种后进先出(last-in，first-out，LIFO)数据策略。
			2.栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。
		实现：
			利用一个简单的数组实现栈。
			public class stack {
				// 用一个数组S[1..n]来实现一个最多可容纳n个元素的栈。
				Objects[] capacity = new Objects[10];
				// 属性top，指向最新插入的元素
				int top = 0;

				// 栈上的INSERT操作称为压人(PUSH)，
				void push(Objects o){
					capacity[top] = o;
					top++;
				}
				// 而无元素参数的DELETE操作称为弹出(POP)。
				void pop(){
					top --;
				}
				// 空栈,进行查询操作STACK-EMPTY。
				// 如果试图对一个空栈执行弹出操作，则称栈下溢(underflow).代码未避免改bug
				// 如果S. top超过了n，则称栈上溢(overflow).代码未避免改bug
				//
			}
	队列（queue）：
		介绍：
			1.队列实现的是一种先进先出(first-in，first-out，FIFO)策略。
			2.队列作为一种数据结构，队列有队头(head)和队尾(tail)，当有一个元素入队时，它被放在队尾的位置，而出队的元素则总是在队头。
				（是一种队尾插入和队尾删除进行操作的线性表）。
		
	链表（linked-list）:
		介绍：
			概念：
				链表(linked list)是一种这样的数据结构，其中的各对象按线性顺序排列。
				数组的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。

			双向链表(doubly linked list)：
				实现思路：
					链表元素属性作用介绍：
						双向链表(doubly linked list)L的每个元素都是一个对象，每个对象有一个关键字key和两个指针:next和 prev。对象中还可以包含其他的辅助数据(或称卫星数据)。
					链表的头(head)：
						链表的第一个元素 （x.prev=NIL，即元素α没有前驱）。
						属性L.head指向链表的第一个元素。如果L.head=NIL，则链表为空。
					链表的尾(tail)：
						链表的最后一个元素（ x. next=NIL ，即元素α没有后继）。
					例：
						图：./imgs/双向链表.png
			单链表：
				如果一个链表是单链接的(ingly linked)，则省略每个元素中的prev指针。
			循环链表(circular list):
				在循环链表(circular list)中，表头元素的prev指针指向表尾元素，而表尾元素的next指针则指向表头元素。
				我们可以将循环链表想象成一个各元素组成的圆环。
			附:
				1.链表排序：
					如果链表是已排序(sorted)的，则链表的线性顺序与链表元素中关键字的线性顺序一致，据此，最小的元素就是表头元素，而最大的元素则是表尾元素。
					如果链表是未排序(unsorted)的，则各元素可以以任何顺序出现。
		链表的一些操作：
			...
	有根树的表示:
		附：
			上一节介绍的表示链表的方法可以推广到任意同构的数据结构上。
			本节中，我们专门讨论用链式数据结构表示有根树的问题。
			与链表类似，假设每个结点都含有一个关键字key。其余我们感兴趣的属性包括指向其他结点的指针，它们随树的种类不同会有所变化。
			（意思是又指向就算链表结构吗）
		二叉树：
			实现思路：
				二叉树的元素属性作用介绍：
					图10-9展示了二叉树T中如何利用属性p、left和right存放指向父结点、左孩子和右孩子的指针。
				结点介绍：
					如果x.p=NIL，则x是根结点。
					如果结点x没有左孩子，则x.left=NIL，右孩子的情况与此类似。
					如果T.root=NIL，则该树为空。
				例：
					./imgs/二叉树.png
		分支无限制的有根树：
			前景：
				二叉树的表示方法可以推广到每个结点的孩子数至多为常数k的任意类型的树:只需要将left和right属性用child1，child2，…，childk代替。
				当孩子的结点数无限制时，这种方法就失效了，因为我们不知道应当预先分配多少个属性(在多数组表示法中就是多少个数组)。
				此外，即使孩子数k限制在一个大的常数以内，但若多数结点只有少量的孩子，则会浪费大量存储空间。
			
			介绍：
				所幸的是，有一个巧妙的方法可以用来表示孩子数任意的树。
				该方法的优势在于，对任意n个结点的有根树，只需要O(n)的存储空间。
				
			左孩子右兄弟表示法(left-child，right-sibling representation):	
				实现思路：
					元素属性作用介绍：
						节点包含3个指针:
						1. 每个结点都包含一个父结点指针p。
						2. x.left-child指向结点x最左边的孩子结点。
						3. x.right-sibling指向x右侧相邻的兄弟结点。

					节点介绍：
						T.root指向树T的根结点。
						如果结点x没有孩子结点，则x.left-child=NIL;
						如果结点x是其父结点的最右孩子，则x.right-sibling=NIL;
		
				例：
					./imgs/分支无限制的有根树.png
		二叉搜索树（搜索树数据结构）：
			附：
				二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。
					对于有n个结点的一棵完全二叉树来说，这些操作的最坏运行时间为O(lgn)。
					然而，如果这棵树是一条n个结点组成的线性链，那么同样的操作就要花费O(n)的最坏运行时间。
				实际上，我们并不能总是保证随机地构造二叉搜索树，然而可以设计二叉搜索树的变体，来保证基本操作具有好的最坏情况性能。
					第13章给出了一个这样的变形，即红黑树，它的树高为O(lgn)。
					第18章将介绍B树，它特别适用于二级(磁盘)存储器上的数据库维护。
			什么是二叉搜索树:
				介绍：
					顾名思义，一棵二叉搜索树是以一棵二叉树来组织的。（这样一棵树可以使用一个链表数据结构来表示，其中每个结点就是一个对象。）
					二叉搜索树性质：
						如果y是x左子树中的一个结点，那么y.key≤x.key。如果y是x右子树中的一个结点，那么y. key≥x. key。
							附：
							不同的二叉搜索树可以代表同一组值的集合。
							大部分搜索树操作的最坏运行时间与树的高度成正比。					
					节点元素：
						除了key和卫星数据之外，每个结点还包含属性left、right 和p，它们分别指向结点的左孩子、右孩子和双亲。
					根结点：
						如果某个孩子结点和父结点不存在，则相应属性的值为NIL.根结点是树中唯一-父指针为NIL的结点。
					
						
					例：
						./imgs/二叉搜索树.png
						(a)一棵包含6个结点、高度为2的二叉搜索树。(b)一 棵包含相同关键字、高度为4的低效二叉搜索树

				二叉搜索树遍历：
					介绍：		
						二叉搜索树性质允许我们通过一个简单的递归算法来按序输出二叉搜索树中的所有关键字，这种算法称为中序遍历(inordertreewalk)算法。
						这样命名的原因是输出的子树根的关键字位于其左子树的关键字值和右子树的关键字值之间。
					附：
						(类似地，先序遍历(preorder tree walk)中输出的根的关键字在其左右子树的关键字值之前，
						而后序遍历( postorder tree walk)输出的根的关键字在其左右子树的关键字值之后。)
					例：
						调用下面的函数，就可以输出一棵二叉搜索树T中的所有元素。
						INORDER-TREE-WALK(x)
						if x!=null
							INORDER-TREE-WALK(x.left)
							print x.key
							INORDER-TREE-WALK(x.right)
						
						对于图12-1中的两棵二叉搜索树，中序遍历输出的关键字次序均为2, 5,5，6, 7，8。
					遍历一棵有n个结点的二叉搜索树需要耗时O(n)证明：
						p162
				二叉搜索树操作：
					二叉搜索树查询操作：
						二叉搜索树还能支持SEARCH、MINIMUM、MAXIMUM、SUCCESSOR和PREDECESSOR等查询操作。
						...p163
						查找：
							我们使用下面的过程在一棵二叉搜索树中查找一个具有给定关键字的结点。
							输人一个指向树根的指针和一个关键字k,如果这个结点存在，TREE-SEARCH返回一个指向关键字为k的结点的指针;否则返回NIL.
								TREE-SEARCH(x,k)
									ifx== NIILork == x. key .
										return x;
									ifk< x. key
										return TREE SEARCH(x,left,k)
									else return TREE SEARCH(x. right,k)
								从树根开始递归期间遇到的结点就形成了一条向下的简单路径，所以TREE SEARCH的运行时间为O(h)，其中h是这棵树的高度。
						最大关键字元素和最小关键字元素：
							最小关键字元素：
								通过从树根开始沿着left 孩子指针直到遇到一个NIL,我们总能在一棵二叉搜索树中找到一个最小元素。
								如果结点工没有左子树，那么由于x右子树中的每个关键字都至少大于或等于x.key， 则以x为根的子树中的最小关键字是x. key。

								TREE- MINIMUM(x)
									while x.left≠NIL
										x = x.left
									return x
							最大关键字元素
								TREE-MAXIMUM(x)
								while x.right≠NIL
									x= x.right
								return x
							时间维度（耗时）：
								这两个过程在一棵高度为h的树上均能在O(h)时间内执行完，因为与TREE- SEARCH一样，它们所遇到的结点均形成了一条从树根向下的简单路径。
						后继和前驱：
							后继：
								介绍：
									如果所有的关键字互不相同，则一个结点x的后继是大于x.key的最小关键字的结点。
									如果x是这棵树中的最大关键字，则返回NIL.
										hcg：就是大于它的最小一个节点。
								例：
								TREE SUCCESSOR(x)
									if x.right≠NIL
										return TREE-MINIMUM(x. right)
									y=x.p
									while y≠NIL and x == y. right //双亲节点不为空 且 节点为双亲节点的右节点
										x=y
										y= y.p
									return y


								把TREE-SUCCESSOR的伪代码分为两种情况。
									1.如果结点x的右子树非空，那么x的后继恰是x右子树中的最左结点，通过第2行中的TREE MINIMUM(x. right)调用可以找到。
									2.？
										如果结点x的右子树非空并有一一个后继y,那么y就是x的有左孩子的最底层祖先，并且它也是x的一个祖先。
										为了找到y,只需简单地从x开始沿树而上直到遇到一个其双亲有左孩子的结点。TREE-SUCCESSOR中的第3~7行正是处理这种情况。
										在图12-2中，关键字为13的结点的后继是关键字为15的结点。
										
										总结：
										即：
											右子树空的话，那么后继为其最底层左双亲节点
											（一直往上双亲节点不为空 且 节点为双亲节点的左节点，第一个父节点）
										hcg：
											右节点空

											1是双亲的左节点
												符合规则后继就是双亲
											2是双亲的右节点
												那么双亲比他小，再看双亲双亲节点。
												当双为双双的左节点，那么双双就是找到的最小的比我大的节点，
												那么双双就是后继。
					插入和删除：
						插入删除时要注意保持二叉搜索树性质的成立。
						插入：
							例：插入z节点
							TREE-INSERT(T,z)
								zParent = NIL
								x= T.root 
								while x≠NIL //找到z的父节点（）
									zParent=x //这里要为深克隆
									if z.key<x.key
										x = x.left
									else x =x. right ;
								z.p=zParent
								// z插入树中
								if y== NIL
									T.root = z // tree T was empty
								else if z.key< zParent.key 
									zParent.left= z
								else zParent.right= z
							1.正如过程TREE SEARCH和ITERATIVE-TREE-SEARCH一样，
							TREE-INSERT从树根开始，指针x记录了一条向下的简单路径，并查找要替换的输入项z的NIL。
							2.与其他搜索树.上的原始操作一样，过程TREE-INSERT在一棵高度为h的树上的运行时间为O(h)。

						删除：
							...p166
							思路：
								从一棵二叉搜索树T中删除一个结点z的整个策略分为三种基本情况，但只有一种情况有点棘手。
								1.如果z没有孩子结点，那么只是简单地将它删除，并修改它的父结点，用NIL作为孩子来替换z。
								2.如果z只有一个孩子，那么将这个孩子提升到树中z的位置上，并修改z的父结点，用z的孩子来替换z。
								3.如果z有两个孩子，那么找z的后继y(一定在z的右子树中)，并让y占据树中z的位置。z的原来右子树部分成为y的新的右子树，并且z的左子树成为y的新的左子树。这种情况稍显麻烦(如下所述)，因为还与y是否为z的右孩子相关。
									z既有一个左孩子又有一个右孩子。我们要查找z的后继y，将y移出原来的位置进行拼接，并替换树中的z。此处又分为两种情况，y为右孩子和不是右孩子：
											注：后继y位于z的右子树中并且没有左孩子(见练习12. 2-5)。
											？12.2-5证明:如果一棵二叉搜索树中的一个结点有两个孩子，那么它的后继没有左孩子，它的前驱没有右孩子。
										1.如果y是z的右孩子(图12-4(c))，那么用y替换z，并仅留下y的右孩子。
										2.y位于z的右子树中但并不是z的右孩子(图12-4(d))。在这种情况下，先用y的右孩子替换y，然后再用y替换z。
							例：
							// RANSPLANT类似红黑树的那个TRANSPLANT
							// TREE-DELETE过程处理4种情况如下。
							TREE-DELETE(T,z)
								if z.left == NIL //第1~2行处理结点z没有左孩子的情况。
									TRANSPLANT(T,z,z. right) // 把z节点和z右孩子进行树转移
								else if z. right == NIL //第3~4行处理z有一个左孩子但没有右孩子情况。
									TRANSPLANT(T,z,z. left) // 把z节点和z左孩子进行树转移
								else // 第5~12行处理剩下的两种情况，也就是z有两个孩子的情形。
									y = TREE-MINIMUM(z. right) // 第5行查找结点y,它是z的后继。因为z的右子树非空，这样后继一定是这个子树中具有最小关键字的结点，因此就调用TREE-MINIMUM(z. right)。

									// 附：如前所述，y没有左孩子。！将y移出它的原来位置进行拼接，并替换树中的z即可。
									if y.p≠z 
										TRANSPLANT(T,y,y. right) //7-9如果y不是z的左孩子，第7~9行用y的右孩子替换y并成为y的双亲的-一个孩子，然后将z的右孩子转变为y的右孩子，最后第10~12行用y替换z并成为z的双亲的一个孩子，再用z的左孩子替换为y的左孩子。
										y.right = z. right
										y.right.p= y
									TRANSPLANT(T,z,y) //10-12 如果y是z的右孩子，那么第10~12行用y替换z并成为z的双亲的一个孩子，用z的左孩子替换y的左孩子。
									y.left = z.left
									y.left.p=y
							耗时:
								除了第5行调用TREE-MINIMUM之外，TREE-DELETE的每一行，包括调用
							TRANSPLANT,都只花费常数时间。因此，在- -棵高度为h的树上，TREE DELETE的运行时
							间为O(h)。
									
		红黑树（平衡二叉搜索树）：
			前言：
				一棵高度为h的二叉搜索树，它的动态集合操作时间复杂度均为O(h)。因此，如果搜索树的高度较低时，这些集合操作会执行得较快。然而，如果树的高度较高时，这些集合操作可能并不比在链表上执行得快。（100个节点高度可能就为100了）
				红黑树(red black tree)是许多“平衡”搜索树中的一一种，可以保证在最坏情况下基本动态集合操作的时间复杂度为O(lgn)。
			介绍：
				红黑树是一棵平衡二叉搜索树。
					它在每个结点上增加了一个存储位来表示结点的颜色，可以是RED或BLACK。
					通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，来达到确保没有一条路径会比其他路径长出2倍，因而是近似于平衡的。
				红黑树性质：					
					一棵红黑树是满足下面红黑性质的二叉搜索树:
						1.每个结点或是红色的，或是黑色的。
						2.根结点是黑色的。
						3.每个叶结点(NIL)是黑色的。
						4.如果一个结点是红色的，则它的两个子结点都是黑色的。
						5.对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。
				附:
					节点属性：
						树中每个结点包含5个属性: color、 key、 left、 right 和p。
					
					如果一个结点没有子结点或父结点，则该结点相应指针属性的值为NIL。我们可以把这些NII视为指向二叉搜索树的叶结点(外部结点)的指针，而把带关键字的结点视为树的内部结点。

					黑高：
						从某个结点x出发(不含该结点)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高(black height),记为b(x)。
					为什么红黑树比其他树更优：
						引理：13.1一棵有n个内部结点的红黑树的高度至多为2lg(n+1)。
						证明：
							先证明以任一结点 x为根的子树中至少包含2^bh(x) -1个内部结点。
								注：bh(x)-1为红黑树黑高
								要证明这点，对x的高度进行归纳。
									如果x的高度为0，则x必为叶结点(T.nil)，且以x为根结点的子树至少包含2^bh(x) -1=2^0 -1=0个内部结点。
									对于归纳步骤，考虑一个高度为正值且有两个子结点的内部结点x。每个子结点有黑高bh(x)或bh(x)-1,其分别取决于自身的颜色是红还是黑。由于x子结点的高度比x本身的高度要低，可以利用归纳假设得出每个子结点至少有2^bh(x)-1 -1个内部结点的结论。于是，以x为根的子树至少包含(2^bh(x)-1 -1)+(2^bh(x)-1 -1)+1=2^bh(x) -1个内部结点，因此得证。
									注：
										为什么根结点的子树至少包含2^bh(x) -1：
											因为全是黑，则是节点最少情况。
											那么3黑高时，每层的节点数为1 2(2^1) 4(2^2),根据高中数学知识（等比数列求和）得出节点总数为2^3-1
							为完成引理的证明，设h为树的高度。
							根据性质4,从根到叶结点(不包括根结点)的任何一条简单路径上都至少有一半的结点为黑色。
								注：因为如果是红那么后面肯定黑。
							因此，根的黑高至少为h/2;于是有n≥2^h/2 -1
							把1移到不等式的左边，再对两边取对数，得到lg(n+1)≥h/2，或者h≤2lg(n+1)。
						总结：由该引理可知，动态集合操作可在高度为h的红黑树上在O(lgn)时间内执行。
							这些操作在一棵高度为h的二叉搜索树上的运行时间为O(h)(参见第12章)。
			插入、删除：
				二叉搜索树的INSERT和DELETE算法并不应用与红黑树,因为它们并不能保证被这些操作修改过的二叉搜索树仍是红黑树。
				那么如何在时间O(Ign)内支持这两个操作呢，我们将在13. 3节和13.4节中介绍。
				旋转：
					指针结构的修改是过通过旋转(ration)来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。
					旋转有两种:左旋和右旋。
						例：
							./img/旋转.png
							LEFT-ROTATE(T, x)： 以x与x右节点为支轴，x向下（左）拉。
							RIGHT-ROTATE(T, y)： 以y与y左节点为支轴，y向下（右）拉。
				插入：
					p178
					RB-INSERT(T, z)
						zParent = NIL
						x= T.root 
						while x≠NIL //找到z的父节点（）
							zParent=x //这里要为深克隆
							if z.key<x.key
								x = x.left
							else x =x. right ;
						z.p=zParent
						// z插入树中
						if y== NIL
							T.root = z // tree T was empty
						else if z.key< zParent.key 
							zParent.left= z
						else zParent.right= z
						z.left = NIL
						z. right = NIL
						z. color = RED //将z着为红色。
						RB-INSERT-FIXUP(T, z) //因为将z着为红色可能违反其中的一-条红黑性质，所以在RB-INSERT的第17行中调用RB INSERT FIXUP(T, z)来保持红黑性质。
					// 方法主要目的就是判断性质2和4是否成立
					RB-INSERT-FIXUP(T, z)
						while z. p. color == RED //如果性质4被破坏 //注意： 只要保证z与z父节点符合性质4，那么这颗树就能符合红黑树。
							if z.p== z.p.p.left //如果z的父节点为左节点
								y= z.p.p.right // z的叔父节点
								if y.color == RED //如果z的叔父节点为红色，则z的父节点重上为黑色 （修正性质4），叔父节点上为黑色，祖父节点上为红色，（然后准备修复性质5），z节点指针上升为祖父节点。
									z. p. color = BLACK// case 1
									y. color = BLACK// case 1
									z. p. p. color = RED// case 1
									z=z.p.p// case 1
								else if z == z. p. right //如果z的叔父节点为黑且z为右节点，z节点指针上升为父节点并左旋。
									Z=z.p// case2
									LEFT-ROTATE(T, z)//case2.
								else //如果z的叔父节点为黑且z为左节点，z父节点上为黑色，z祖父节点上为红色，z祖父节点右旋。
									z. p.color = BLACK// case3
									z. p. p. color = RED// case 3
									RIGHT-ROTATE(T, z.p. p)//case3
							else( same as then clause with“right" and“left" exchanged //同理把子句的所有right改为left即可) 
						T. root. color = BLACK //如果性质2被破坏，则直接把根上为黑色就对了。
						附：
						首先，要确定当结点z被插人并着为红色后，红黑性质中有哪些不能继续保持。
							仅可能被破坏的就是性质2和性质4，即根结点需要为黑色以及一个红结点不能有红孩子。这两个性质可能被破坏是因为z被着为红色。如果z是根结点，则破坏了性质2;如果z的父结点是红结点，则破坏了性质4。
								附：如果有任何红黑性质被破坏，则至多只有一条被破坏，或是性质2,或是性质4。如果性，质2被破坏，其原因为z是根结点且是红结点。如果性质4被破坏，其原因为z和z. p都是红结点。
					耗时：
						由于一棵有n个结点的红黑树的高度为O(lgn),因此RB-INSERT的第1~16行要花费O(lgn)时间。在RB-INSERT-FIXUP中，仅当情况1发生，然后指针z沿着树上升2层，while循环才会重复执行。所以while循环可能被执行的总次数为O(lgn)。因此，RB-INSERT 总共花费O(lgn)时间。此外，该程序所做的旋转从不超过2次，因为只要执行了情况2或情况3，while循环就结束了。

				删除：
					p183
					//为了在二叉搜索树内移动子树，定义一个子过程TRANSPLANT，它是用另一棵子树替换一棵子树并成为其双亲的孩子结点。
					//当TRANSPLANT用一棵以v为根的子树来替换一棵以u为根的子树时，结点u的双亲就变为结点v的双亲，并且最后v成为u的双亲的相应孩子。（即用v子树替换掉u子树）
					RB-TRANSPLANT(T, u, v)
						if u.p== T.nil //第1~2行处理u是T的树根的情况。（u是树跟，则把树根指向v）
							T.root=v
						else if u == u.p. left //如果u是一个左孩子，第3~4行负责u. p. left的更新;（u是其父左节点，则把其父左节点指向v）
							u.p. left= v
						else u. p.righl = V //如果u是一个右孩子，第5行更新u. p. right。（u是其父右节点，则把其父右节点指向v）
						v.p= u.p //第6行对v. p的赋值是无条件执行:（u的父节点赋给v）
					// RB-DELETE与TREE-DELETE类似，只是多了几行伪代码。//多出的几行代码记录结点y的踪迹，y有可能导致红黑性质的破坏。
					RB-DELETE(T, z)
						y=z 
						y original-color = y. color
						if z.left == T.nil
							x=zright
							RB-TRANSPLANT(T, z, z. right)
						else if z. right == T.nil
							x = z.left
							RB- TRANSPLANT(T, z, z. left)
						else y = TREE-MINIMUM(z. right)
							y.original- color = y. color
							x= y.right
							ify.p==z
								x.p= y
							else RB-TRANSPLANT(T, y, y. right)
								y.right = z. right
								y.right.p=y
							RB-TRANSPLANT(T, z, y)
							y.left = z.left
							y.lefi.p=y
							y. color =z.color
						if y.original-color == BLACK
							RB-DELETE-FIXUP(T, x) 
					// RB-DELETE-FIXUP是恢复搜索树的红黑性质。
					RB-DELETE-FIXUP(T, x)
						whilex ≠T. root and x. color == BLACK
							ifx ==x.p. left
								w=x. p. right
								if w. color == RED
									w. color = BLACK// case 1
									x. p. color = RED// case 1
									LEFT-ROTATE(T,x. p)// case 1
									w=x.p.right//case1
								if w. left. color == BLACK and rw. right. color == BLACK
									w. color = RED// case2
									x=x.p// case2
							else if w. right. color == BLACK
									w. left. color = BLACK// case3
									w. color = RED// case3
									RIGHT-ROTATE(T,w)// case3
									w= x. p. right// case3
								w. color =x.p. color// case4
								x. p. color = BLACK// case 4
								w. right. color = BLACK// case4
								LEFT-ROTATE(T, x. p)// case 4
								x = T.root// case4
							else (same as then clause with“right" and“left" exchanged)
						x. color = BLACK
					
					


	散列表：
		介绍：
			散列表(hash table)是实现字典操作的一种有效数据结构。
				附：
				尽管最坏情况下，散列表中查找一个元素的时间与链表中查找的时间相同，达到了O(n)。
				然而在实际应用中，散列查找的性能是极好的。在一些合理的假设下，在散列表中查找一个元素的平均时间是O1)。
			散列表是普通数组概念的推广。
				附：由于对普通数组可以直接寻址，使得能在O(1)时间内访问数组中的任意位置。
			在散列表中，不是直接把关键字作为数组的下标，而是根据关键字计算出相应的下标。
		直接寻址表
			介绍：
				为表示动态集合，我们用一个数组，或称为直接寻址表(direct-address table)，记为T[0..m—1]。
				其中每个位置，或称为槽(slot)，对应全域U中的一个关键字。
				槽k指向集合中一个关键字为k的元素。如果该集合中没有关键字为k的元素，则T[k]=NIL。
				附：
					对于某些应用，直接寻址表本身就可以存放动态集合中的元素。
						也就是说，并不把每个元素的关键字及其卫星数据都放在直接寻址表外部的一个对象中，再由表中某个槽的指针指向该对象，
						而是直接把该对象存放在表的槽中，从而节省了空间。
					当关键字的全域U比较小时，直接寻址是一种简单而有效的技术。
						假设某应用要用到一个动态集合，其中每个元素都是取自于全域U={0，1，…，m-l}中的一个关键字，这里m不是一个很大的数。
						另外，假设没有两个元素具有相同的关键字。
				
			例：
				./imgs/直接寻址表.png
		散列表：
			介绍：
				在直接寻址方式下，具有关键字k的元素被存放在槽k中。
					直接寻址技术的缺点是非常明显的:如果全域U很大，则在一台标准的计算机可用内存容量中，要存储大小为|U|的- -张表T也许不太实际，甚至是不可能的。
					还有，实际存储的关键字集合K相对U来说可能很小，使得分配给T的大部分空间都将浪费掉。
				在散列方式下，该元素存放在槽h(k)中;即利用散列函数(hash function)h,由关键字k计算出槽的位置。
					函数h将关键字的全域U映射到散列表(hash table)T[0. . m-1]的槽位上。
					这里散列表的大小m一般要比|U|小得多。
						散列函数缩小了数组下标的范围，即减小了数组的大小，使其由|U|减小为m。
					我们可以说一个具有关键字k的元素被散列到槽h(k).上，也可以说h(k)是关键字k的散列值。
			例：
				./imgs/散列表.png

			冲突：
				介绍：
					这里存在一个问题:两个关键字可能映射到同一个槽中。我们称这种情形为冲突( collision)。
					由于|U|>m，故至少有两个关键字其散列值相同，所以要想完全避免冲突是不可能的。
					因此我们一方面可以通过精心设计的散列函数来尽量减少冲突的次数，另一方面仍需要有解决可能出现冲突的办法。

				通过链接法(chaining)解决冲突：
					在链接法中，把散列到同一槽中的所有元素都放在一个链表中。
					槽j中有一个指针，它指向存储所有散列到j的元素的链表的表头;如果不存在这样的元素，则槽j中为NIL。
					在采用链接法解决冲突后，散列表T上的字典操作就很容易实现：
						...p145
					例：
						./imgs/散列表之链表法.png

					链接法散列的分析：
						...
				开放寻址法(open addressing)	:
					...p151
			散列函数：
				...p147
		完全散列：
			...p156
			使用散列技术通常是个好的选择，不仅是因为它有优异的平均情况性能，而且当关键字集合是静态(static)时，散列技术也能提供出色的最坏情况性能。
			所谓静态，就是指一旦各关键字存入表中，关键字集合就不再变化了。一些应用存在着天然的静态关键字集合，如程序设计语言中的保留字集合，或者CD-ROM上的文件名集合。
			一种散列方法称为完全散列(perfect hashing),如果该方法进行查找时，能在最坏情况下用0(1)次访存完成。
			
	堆数数据结构：
		第6章
附：
	算法最好结合能结合实际应用部分来学习，不然就略感无聊，
	就似习得18般武艺却毫无用武之地。