基本数据结构：
	附：
		动态集合：
			集合作为算机科学的基础，就如同他们在数学中所起的作用。
			数学中的集合是不变的,而由算法操作的集合却在整个过程中增大,缩小或发生其他变化。我们称这样的集合为动态集合。
			
			附:
				10-14章描述了能够用于实现动态集合的几种数据结构。
					本书后面的算法中也会使用其中多种构造来解决各种不同问题。
		指针和对象的实现p134
			当有些语言不支持指针和对象数据类型时，应当如何实现它们呢。
			本节我们将利用数组和数组下标来构造对象和指针。
			...
	栈（stack）：
		介绍：
			1.栈实现的是一种后进先出(last-in，first-out，LIFO)数据策略。
			2.栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。
		实现：
			利用一个简单的数组实现栈。
			public class stack {
				// 用一个数组S[1..n]来实现一个最多可容纳n个元素的栈。
				Objects[] capacity = new Objects[10];
				// 属性top，指向最新插入的元素
				int top = 0;

				// 栈上的INSERT操作称为压人(PUSH)，
				void push(Objects o){
					capacity[top] = o;
					top++;
				}
				// 而无元素参数的DELETE操作称为弹出(POP)。
				void pop(){
					top --;
				}
				// 空栈,进行查询操作STACK-EMPTY。
				// 如果试图对一个空栈执行弹出操作，则称栈下溢(underflow).代码未避免改bug
				// 如果S. top超过了n，则称栈上溢(overflow).代码未避免改bug
				//
			}
	队列（queue）：
		介绍：
			1.队列实现的是一种先进先出(first-in，first-out，FIFO)策略。
			2.队列作为一种数据结构，队列有队头(head)和队尾(tail)，当有一个元素入队时，它被放在队尾的位置，而出队的元素则总是在队头。
				（是一种队尾插入和队尾删除进行操作的线性表）。
		
	链表（linked-list）:
		介绍：
			概念：
				链表(linked list)是一种这样的数据结构，其中的各对象按线性顺序排列。
				数组的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。

			双向链表(doubly linked list)：
				实现思路：
					链表元素属性作用介绍：
						双向链表(doubly linked list)L的每个元素都是一个对象，每个对象有一个关键字key和两个指针:next和 prev。对象中还可以包含其他的辅助数据(或称卫星数据)。
					链表的头(head)：
						链表的第一个元素 （x.prev=NIL，即元素α没有前驱）。
						属性L.head指向链表的第一个元素。如果L.head=NIL，则链表为空。
					链表的尾(tail)：
						链表的最后一个元素（ x. next=NIL ，即元素α没有后继）。
					例：
						图：./imgs/双向链表.png
			单链表：
				如果一个链表是单链接的(ingly linked)，则省略每个元素中的prev指针。
			循环链表(circular list):
				在循环链表(circular list)中，表头元素的prev指针指向表尾元素，而表尾元素的next指针则指向表头元素。
				我们可以将循环链表想象成一个各元素组成的圆环。
			附:
				1.链表排序：
					如果链表是已排序(sorted)的，则链表的线性顺序与链表元素中关键字的线性顺序一致，据此，最小的元素就是表头元素，而最大的元素则是表尾元素。
					如果链表是未排序(unsorted)的，则各元素可以以任何顺序出现。
		链表的一些操作：
			...
	有根树的表示:
		附：
			上一节介绍的表示链表的方法可以推广到任意同构的数据结构上。
			本节中，我们专门讨论用链式数据结构表示有根树的问题。
			与链表类似，假设每个结点都含有一个关键字key。其余我们感兴趣的属性包括指向其他结点的指针，它们随树的种类不同会有所变化。
			（意思是又指向就算链表结构吗）
		二叉树：
			实现思路：
				二叉树的元素属性作用介绍：
					图10-9展示了二叉树T中如何利用属性p、left和right存放指向父结点、左孩子和右孩子的指针。
				结点介绍：
					如果x.p=NIL，则x是根结点。
					如果结点x没有左孩子，则x.left=NIL，右孩子的情况与此类似。
					如果T.root=NIL，则该树为空。
				例：
					./imgs/二叉树.png
		分支无限制的有根树：
			前景：
				二叉树的表示方法可以推广到每个结点的孩子数至多为常数k的任意类型的树:只需要将left和right属性用child1，child2，…，childk代替。
				当孩子的结点数无限制时，这种方法就失效了，因为我们不知道应当预先分配多少个属性(在多数组表示法中就是多少个数组)。
				此外，即使孩子数k限制在一个大的常数以内，但若多数结点只有少量的孩子，则会浪费大量存储空间。
			
			介绍：
				所幸的是，有一个巧妙的方法可以用来表示孩子数任意的树。
				该方法的优势在于，对任意n个结点的有根树，只需要O(n)的存储空间。
				
			左孩子右兄弟表示法(left-child，right-sibling representation):	
				实现思路：
					元素属性作用介绍：
						节点包含3个指针:
						1. 每个结点都包含一个父结点指针p。
						2. x.left-child指向结点x最左边的孩子结点。
						3. x.right-sibling指向x右侧相邻的兄弟结点。

					节点介绍：
						T.root指向树T的根结点。
						如果结点x没有孩子结点，则x.left-child=NIL;
						如果结点x是其父结点的最右孩子，则x.right-sibling=NIL;
		
				例：
					./imgs/分支无限制的有根树.png
	堆数数据结构：
		第6章