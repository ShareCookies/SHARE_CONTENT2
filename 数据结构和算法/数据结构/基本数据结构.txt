基本数据结构：
	附：
		动态集合：
			集合作为算机科学的基础，就如同他们在数学中所起的作用。
			数学中的集合是不变的,而由算法操作的集合却在整个过程中增大,缩小或发生其他变化。我们称这样的集合为动态集合。
			
			附:
				10-14章描述了能够用于实现动态集合的几种数据结构。
					本书后面的算法中也会使用其中多种构造来解决各种不同问题。
		指针和对象的实现p134
			当有些语言不支持指针和对象数据类型时，应当如何实现它们呢。
			本节我们将利用数组和数组下标来构造对象和指针。
			...
	栈（stack）：
		介绍：
			1.栈实现的是一种后进先出(last-in，first-out，LIFO)数据策略。
			2.栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。
		实现：
			利用一个简单的数组实现栈。
			public class stack {
				// 用一个数组S[1..n]来实现一个最多可容纳n个元素的栈。
				Objects[] capacity = new Objects[10];
				// 属性top，指向最新插入的元素
				int top = 0;

				// 栈上的INSERT操作称为压人(PUSH)，
				void push(Objects o){
					capacity[top] = o;
					top++;
				}
				// 而无元素参数的DELETE操作称为弹出(POP)。
				void pop(){
					top --;
				}
				// 空栈,进行查询操作STACK-EMPTY。
				// 如果试图对一个空栈执行弹出操作，则称栈下溢(underflow).代码未避免改bug
				// 如果S. top超过了n，则称栈上溢(overflow).代码未避免改bug
				//
			}
	队列（queue）：
		介绍：
			1.队列实现的是一种先进先出(first-in，first-out，FIFO)策略。
			2.队列作为一种数据结构，队列有队头(head)和队尾(tail)，当有一个元素入队时，它被放在队尾的位置，而出队的元素则总是在队头。
				（是一种队尾插入和队尾删除进行操作的线性表）。
		
	链表（linked-list）:
		介绍：
			概念：
				链表(linked list)是一种这样的数据结构，其中的各对象按线性顺序排列。
				数组的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。

			双向链表(doubly linked list)：
				实现思路：
					链表元素属性作用介绍：
						双向链表(doubly linked list)L的每个元素都是一个对象，每个对象有一个关键字key和两个指针:next和 prev。对象中还可以包含其他的辅助数据(或称卫星数据)。
					链表的头(head)：
						链表的第一个元素 （x.prev=NIL，即元素α没有前驱）。
						属性L.head指向链表的第一个元素。如果L.head=NIL，则链表为空。
					链表的尾(tail)：
						链表的最后一个元素（ x. next=NIL ，即元素α没有后继）。
					例：
						图：./imgs/双向链表.png
			单链表：
				如果一个链表是单链接的(ingly linked)，则省略每个元素中的prev指针。
			循环链表(circular list):
				在循环链表(circular list)中，表头元素的prev指针指向表尾元素，而表尾元素的next指针则指向表头元素。
				我们可以将循环链表想象成一个各元素组成的圆环。
			附:
				1.链表排序：
					如果链表是已排序(sorted)的，则链表的线性顺序与链表元素中关键字的线性顺序一致，据此，最小的元素就是表头元素，而最大的元素则是表尾元素。
					如果链表是未排序(unsorted)的，则各元素可以以任何顺序出现。
		链表的一些操作：
			...
	有根树的表示:
		附：
			上一节介绍的表示链表的方法可以推广到任意同构的数据结构上。
			本节中，我们专门讨论用链式数据结构表示有根树的问题。
			与链表类似，假设每个结点都含有一个关键字key。其余我们感兴趣的属性包括指向其他结点的指针，它们随树的种类不同会有所变化。
			（意思是又指向就算链表结构吗）
		二叉树：
			实现思路：
				二叉树的元素属性作用介绍：
					图10-9展示了二叉树T中如何利用属性p、left和right存放指向父结点、左孩子和右孩子的指针。
				结点介绍：
					如果x.p=NIL，则x是根结点。
					如果结点x没有左孩子，则x.left=NIL，右孩子的情况与此类似。
					如果T.root=NIL，则该树为空。
				例：
					./imgs/二叉树.png
		分支无限制的有根树：
			前景：
				二叉树的表示方法可以推广到每个结点的孩子数至多为常数k的任意类型的树:只需要将left和right属性用child1，child2，…，childk代替。
				当孩子的结点数无限制时，这种方法就失效了，因为我们不知道应当预先分配多少个属性(在多数组表示法中就是多少个数组)。
				此外，即使孩子数k限制在一个大的常数以内，但若多数结点只有少量的孩子，则会浪费大量存储空间。
			
			介绍：
				所幸的是，有一个巧妙的方法可以用来表示孩子数任意的树。
				该方法的优势在于，对任意n个结点的有根树，只需要O(n)的存储空间。
				
			左孩子右兄弟表示法(left-child，right-sibling representation):	
				实现思路：
					元素属性作用介绍：
						节点包含3个指针:
						1. 每个结点都包含一个父结点指针p。
						2. x.left-child指向结点x最左边的孩子结点。
						3. x.right-sibling指向x右侧相邻的兄弟结点。

					节点介绍：
						T.root指向树T的根结点。
						如果结点x没有孩子结点，则x.left-child=NIL;
						如果结点x是其父结点的最右孩子，则x.right-sibling=NIL;
		
				例：
					./imgs/分支无限制的有根树.png
		搜索树数据结构：
			附：
				二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。
					对于有n个结点的一棵完全二叉树来说，这些操作的最坏运行时间为O(lgn)。
					然而，如果这棵树是一条n个结点组成的线性链，那么同样的操作就要花费O(n)的最坏运行时间。
				实际上，我们并不能总是保证随机地构造二叉搜索树，然而可以设计二叉搜索树的变体，来保证基本操作具有好的最坏情况性能。
					第13章给出了一个这样的变形，即红黑树，它的树高为O(lgn)。
					第18章将介绍B树，它特别适用于二级(磁盘)存储器上的数据库维护。
			什么是二叉搜索树:
				介绍：
					顾名思义，一棵二叉搜索树是以一棵二叉树来组织的。
					这样一棵树可以使用一个链表数据结构来表示，其中每个结点就是一个对象。
					节点元素：除了key和卫星数据之外，每个结点还包含属性left、right 和p，它们分别指向结点的左孩子、右孩子和双亲。
					根结点：如果某个孩子结点和父结点不存在，则相应属性的值为NIL.根结点是树中唯一-父指针为NIL的结点。
					
						
					例：
						核心概念（性质）：
							二叉搜索树，对任何结点x,其左子树中的关键字最大不超过x.key,其右子树中的关键字最小不低于x.key。
								不同的二叉搜索树可以代表同一组值的集合。
									大部分搜索树操作的最坏运行时间与树的高度成正比。
						./imgs/二叉搜索树.png
						(a)一棵包含6个结点、高度为2的二叉搜索树。(b)一 棵包含相同关键字、高度为4的低效二叉搜索树

				二叉搜索树遍历：
					介绍：		
						二叉搜索树性质允许我们通过一个简单的递归算法来按序输出二叉搜索树中的所有关键字，这种算法称为中序遍历(inordertreewalk)算法。
						这样命名的原因是输出的子树根的关键字位于其左子树的关键字值和右子树的关键字值之间。
					附：
						(类似地，先序遍历(preorder tree walk)中输出的根的关键字在其左右子树的关键字值之前，
						而后序遍历( postorder tree walk)输出的根的关键字在其左右子树的关键字值之后。)
					例：
						调用下面的函数，就可以输出一棵二叉搜索树T中的所有元素。
						INORDER-TREE-WALK(x)
						if x!=null
							INORDER-TREE-WALK(x.left)
							print x.key
							INORDER-TREE-WALK(x.right)
						
						对于图12-1中的两棵二叉搜索树，中序遍历输出的关键字次序均为2, 5,5，6, 7，8。
					遍历一棵有n个结点的二叉搜索树需要耗时O(n)证明：
						p162
				二叉搜索树操作：
					二叉搜索树查询操作：
						二叉搜索树还能支持SEARCH、MINIMUM、MAXIMUM、SUCCESSOR和PREDECESSOR等查询操作。
						...p163
						查找：
							我们使用下面的过程在一棵二叉搜索树中查找一个具有给定关键字的结点。
							输人一个指向树根的指针和一个关键字k,如果这个结点存在，TREE-SEARCH返回一个指向关键字为k的结点的指针;否则返回NIL.
								TREE-SEARCH(x,k)
									ifx== NIILork == x. key .
										return x;
									ifk< x. key
										return TREE SEARCH(x,left,k)
									else return TREE SEARCH(x. right,k)
								从树根开始递归期间遇到的结点就形成了一条向下的简单路径，所以TREE SEARCH的运行时间为O(h)，其中h是这棵树的高度。
						最大关键字元素和最小关键字元素：
							最小关键字元素：
								通过从树根开始沿着left 孩子指针直到遇到一个NIL,我们总能在一棵二叉搜索树中找到一个最小元素。
								如果结点工没有左子树，那么由于x右子树中的每个关键字都至少大于或等于x.key， 则以x为根的子树中的最小关键字是x. key。

								TREE- MINIMUM(x)
									while x.left≠NIL
										x = x.left
									return x
							最大关键字元素
								TREE-MAXIMUM(x)
								while x.right≠NIL
									x= x.right
								return x
							时间维度（耗时）：
								这两个过程在一棵高度为h的树上均能在O(h)时间内执行完，因为与TREE- SEARCH一样，它们所遇到的结点均形成了一条从树根向下的简单路径。
						后继和前驱：
							后继：
								介绍：
									如果所有的关键字互不相同，则一个结点x的后继是大于x.key的最小关键字的结点。
									如果x是这棵树中的最大关键字，则返回NIL.
										hcg：就是大于它的最小一个节点。
								例：
								TREE SUCCESSOR(x)
									if x.right≠NIL
										return TREE-MINIMUM(x. right)
									y=x.p
									while y≠NIL and x == y. right //双亲节点不为空 且 节点为双亲节点的右节点
										x=y
										y= y.p
									return y


								把TREE-SUCCESSOR的伪代码分为两种情况。
									1.如果结点x的右子树非空，那么x的后继恰是x右子树中的最左结点，通过第2行中的TREE MINIMUM(x. right)调用可以找到。
									2.？
										如果结点x的右子树非空并有一一个后继y,那么y就是x的有左孩子的最底层祖先，并且它也是x的一个祖先。
										为了找到y,只需简单地从x开始沿树而上直到遇到一个其双亲有左孩子的结点。TREE-SUCCESSOR中的第3~7行正是处理这种情况。
										在图12-2中，关键字为13的结点的后继是关键字为15的结点。
										
										总结：
										即：
											右子树空的话，那么后继为其最底层左双亲节点
											（一直往上双亲节点不为空 且 节点为双亲节点的左节点，第一个父节点）
										hcg：
											右节点空

											1是双亲的左节点
												符合规则后继就是双亲
											2是双亲的右节点
												那么双亲比他小，再看双亲双亲节点。
												当双为双双的左节点，那么双双就是找到的最小的比我大的节点，
												那么双双就是后继。
					插入和删除：
						插入删除时要注意保持二叉搜索树性质的成立。
						插入：
							例：插入z节点
							TREE-INSERT(T,z)
								zParent = NIL
								x= T.root 
								while x≠NIL //找到z的父节点
									zParent=x //这里要为深克隆
									if z.key<x.key
										x = x.left
									else x =x. right ;
								z.p=zParent
								// z插入树中
								ify== NIL
									T.root = z // tree T was empty
								elseif z.key< zParent. key 
									zParent.left= z
								else zParent.right= z
							1.正如过程TREE SEARCH和ITERATIVE-TREE-SEARCH一样，
							TREE-INSERT从树根开始，指针x记录了一条向下的简单路径，并查找要替换的输入项z的NIL。
							2.与其他搜索树.上的原始操作一样，过程TREE-INSERT在一棵高度为h的树上的运行时间为O(h)。

						删除：
							...p166
							思路：
								从一棵二叉搜索树T中删除一个结点z的整个策略分为三种基本情况，但只有一种情况有点棘手。
								1.如果z没有孩子结点，那么只是简单地将它删除，并修改它的父结点，用NIL作为孩子来替换z。
								2.如果z只有一个孩子，那么将这个孩子提升到树中z的位置上，并修改z的父结点，用z的孩子来替换z。
								3.如果z有两个孩子，那么找z的后继y(一定在z的右子树中)，并让y占据树中z的位置。z的原来右子树部分成为y的新的右子树，并且z的左子树成为y的新的左子树。这种情况稍显麻烦(如下所述)，因为还与y是否为z的右孩子相关。
									z既有一个左孩子又有一个右孩子。我们要查找z的后继y，将y移出原来的位置进行拼接，并替换树中的z。此处又分为两种情况，y为右孩子和不是右孩子：
											注：后继y位于z的右子树中并且没有左孩子(见练习12. 2-5)。
											？12.2-5证明:如果一棵二叉搜索树中的-一个结点有两个孩子，那么它的后继没有左孩子，它的前驱没有右孩子。
										1.如果y是z的右孩子(图12-4(c))，那么用y替换z，并仅留下y的右孩子。
										2.y位于z的右子树中但并不是z的右孩子(图12-4(d))。在这种情况下，先用y的右孩子替换y，然后再用y替换z。
							
		红黑树：
			前言：
				一棵高度为h的二叉搜索树，它的动态集合操作时间复杂度均为O(h)。因此，如果搜索树的高度较低时，这些集合操作会执行得较快。然而，如果树的高度较高时，这些集合操作可能并不比在链表上执行得快。（100个节点高度可能就为100了）
				红黑树(red black tree)是许多“平衡”搜索树中的一一种，可以保证在最坏情况下基本动态集合操作的时间复杂度为O(lgn)。
			介绍：
				

	散列表：
		介绍：
			散列表(hash table)是实现字典操作的一种有效数据结构。
				附：
				尽管最坏情况下，散列表中查找一个元素的时间与链表中查找的时间相同，达到了O(n)。
				然而在实际应用中，散列查找的性能是极好的。在一些合理的假设下，在散列表中查找一个元素的平均时间是O1)。
			散列表是普通数组概念的推广。
				附：由于对普通数组可以直接寻址，使得能在O(1)时间内访问数组中的任意位置。
			在散列表中，不是直接把关键字作为数组的下标，而是根据关键字计算出相应的下标。
		直接寻址表
			介绍：
				为表示动态集合，我们用一个数组，或称为直接寻址表(direct-address table)，记为T[0..m—1]。
				其中每个位置，或称为槽(slot)，对应全域U中的一个关键字。
				槽k指向集合中一个关键字为k的元素。如果该集合中没有关键字为k的元素，则T[k]=NIL。
				附：
					对于某些应用，直接寻址表本身就可以存放动态集合中的元素。
						也就是说，并不把每个元素的关键字及其卫星数据都放在直接寻址表外部的一个对象中，再由表中某个槽的指针指向该对象，
						而是直接把该对象存放在表的槽中，从而节省了空间。
					当关键字的全域U比较小时，直接寻址是一种简单而有效的技术。
						假设某应用要用到一个动态集合，其中每个元素都是取自于全域U={0，1，…，m-l}中的一个关键字，这里m不是一个很大的数。
						另外，假设没有两个元素具有相同的关键字。

			例：
				./imgs/直接寻址表.png
		散列表：
			介绍：
				在直接寻址方式下，具有关键字k的元素被存放在槽k中。
					直接寻址技术的缺点是非常明显的:如果全域U很大，则在一台标准的计算机可用内存容量中，要存储大小为|U|的- -张表T也许不太实际，甚至是不可能的。
					还有，实际存储的关键字集合K相对U来说可能很小，使得分配给T的大部分空间都将浪费掉。
				在散列方式下，该元素存放在槽h(k)中;即利用散列函数(hash function)h,由关键字k计算出槽的位置。
					函数h将关键字的全域U映射到散列表(hash table)T[0. . m-1]的槽位上。
					这里散列表的大小m一般要比|U|小得多。
						散列函数缩小了数组下标的范围，即减小了数组的大小，使其由|U|减小为m。
					我们可以说一个具有关键字k的元素被散列到槽h(k).上，也可以说h(k)是关键字k的散列值。
			例：
				./imgs/散列表.png

			冲突：
				介绍：
					这里存在一个问题:两个关键字可能映射到同一个槽中。我们称这种情形为冲突( collision)。
					由于|U|>m，故至少有两个关键字其散列值相同，所以要想完全避免冲突是不可能的。
					因此我们一方面可以通过精心设计的散列函数来尽量减少冲突的次数，另一方面仍需要有解决可能出现冲突的办法。

				通过链接法(chaining)解决冲突：
					在链接法中，把散列到同一槽中的所有元素都放在一个链表中。
					槽j中有一个指针，它指向存储所有散列到j的元素的链表的表头;如果不存在这样的元素，则槽j中为NIL。
					在采用链接法解决冲突后，散列表T上的字典操作就很容易实现：
						...p145
					例：
						./imgs/散列表之链表法.png

					链接法散列的分析：
						...
				开放寻址法(open addressing)	:
					...p151
			散列函数：
				...p147
		完全散列：
			...p156
			使用散列技术通常是个好的选择，不仅是因为它有优异的平均情况性能，而且当关键字集合是静态(static)时，散列技术也能提供出色的最坏情况性能。
			所谓静态，就是指一旦各关键字存入表中，关键字集合就不再变化了。一些应用存在着天然的静态关键字集合，如程序设计语言中的保留字集合，或者CD-ROM上的文件名集合。
			一种散列方法称为完全散列(perfect hashing),如果该方法进行查找时，能在最坏情况下用0(1)次访存完成。
			
	堆数数据结构：
		第6章
附：
	算法最好结合能结合实际应用部分来学习，不然就略感无聊，
	就似习得18般武艺却毫无用武之地。