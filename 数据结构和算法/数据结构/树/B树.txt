B树：
	介绍：
		B树是为磁盘(或其他直接存取的辅助存储设备)而设计的一种平衡搜索树,它能够有效的减低磁盘I/O次数。
		B树类似于红黑树，不同之处在于B树的结点可以有很多孩子，从数个到数千个，这就是减低io次数的诀窍。
			
		附：
			为什么针对磁盘设计的数据结构不同于针对随机访问的主存所设计的数据结构：(为什么要专门设计个B树)
				数据都是很大的，主存太贵磁盘便宜，所以用磁盘来存数据。
				但磁盘缺点是耗时。
					
					磁盘耗时的是定位耗时+转圈读数据耗时。
					定位耗时：
						...
					转圈耗时：
						磁盘旋转一圈需要8.33ms，比硅存储的常见存取时间50ns要高出5个数量级。
						也就是说，如果不得不等待一个磁 盘旋转完整的一-圈， 让一个特定的项到达读/写磁头下方，在这个时间内，我们可能存取主存超过100000次。而且移动磁臂也要耗费时间。在撰写本书时，商用磁盘的平均存取时间在8~11ms范围内。
					./imgs/磁盘驱动器.png
					附：
						磁盘读取会一次存取多个数据项而不是一个。
							为了摊还机械移动所花费的等待时间，磁盘会--次存取多个数据项而不是一个。信息被分为一系列相等大小的在柱面内连续出现的位页面(page)，并且每个磁盘读或写-个或多个完整的页面。
							对于一个典型的磁盘来说，-页的长度可能为2^11~2^l4字节。-旦读/写磁头正确定位，并且盘片已经旋转到所要页面的开头位置，对磁盘的读或写就完全电子化了(除了磁盘的旋转外)，磁盘能够快速地读或写大量的数据。
							B树的“分支因子”通常依赖于所使用的磁盘单元的特性。
				因此读取数据十分在意磁盘存取次数。
				我们使用需要读出或写入磁盘的信息的页数来衡量磁盘存取次数。
					注：磁盘存取时间并不是常量一它依赖于当前磁道和所需磁道之间的距离以及磁盘的初始旋转状态。
					但是，我们仍然使用读或写的页数作为磁盘存取总时间的主要近似值。

				为什么用读取的磁盘页数来衡量存取次数：
					因为内存有限，所以要先把需要的页读进来在写出。
					介绍：
					在一个典型的B树应用中，所要处理的数据量非常大，以至于所有数据无法一次装入主存。
					B树算法将所需页面从磁盘复制到主存，然后将修改过的页面写回磁盘。
					在任何时刻，B树算法都只需在主存中保持一定数量的页面。因此，主存的大小并不限制被处理的B树的大小。
					
					设x为指向一个对象的指针。
					如果该对象正在主存中，那么可以像平常一样引用该对象的各个属性:如x.key。然而，如果x所指向的对象驻留在磁盘上，那么在引用它的属性之前，必须先执行DISK-READ(x)，将该对象读入主存中。(假设如果x已经在主存中，那么DISK-READ(x)不需要磁盘存取，即它是个空操作。)
					类似地，操作DISK-WRITE(x)用来保存对象x的属性所做的任何修改。
					也就是说，一个对象操作的典型模式如下:
						x = a pointer to some object
						DISK- READ(x)
						operations that access and/ or modify the attributes of r
						DISK- WRITE(x) // omitted if no attributes of x were changed
						other operations that access but do not modify attributes of x
					由于在大多数系统中，--个B树算法的运行时间主要由它所执行的DISK-READ和DISK-WRITE操作的次数决定，所以我们希望这些操作能够读或写尽可能多的信息。
					因此，一个B树结点通常和-一个完整磁盘页- -样大，并且磁盘页的大小限制了一个B树结点可以含有的孩子个数。
					对存储在磁盘上的一棵大的B树，通常看到分支因子在50~2000之间，具体取决于-一个关键字相对于- -页的大小。一个大的分支因子可以大大地降低树的高度以及查找任何一个关键字所需的磁盘存取次数。
					图18-3显示的是一棵分支因子为1001、高度为2的B树，它可以存储超过10亿个关键字。不过，由于根结点可以持久地保存在主存中，所以在这棵树中查找某个关键字至多只需两次磁盘存取。

	B树定义：
		为简单起见，我们假定，任何和关键字相联系的“卫星数据”(satellite information)将与关键字-样存放在同一个结点中。
		B树性质：
			一棵B树T是具有以下性质的有根树(根为T. root):
			1.每个结点x有下面属性:
				a. x.n,当前存储在结点x中的关键字个数。
				b.x.n个关键字本身x.key1，x.key2，...，x.keyx.n， 以非降序存放，使得x.key1≤x.key2≤...≤x. keyx.n
				c.x. leaf,一个布尔值，如果x是叶结点，则为TRUE;如果x为内部结点，则为FALSE.
			2.每个内部结点x还包含x.n+1个指向其孩子的指针x.c2，x.c2，...，x.cx.n+1。
			叶结点没有孩子，所以它们的c,属性没有定义。
			3.关键字x.keyi;对存储在各子树中的关键字范围加以分割。如果ki为任意一个存储在以x.ci为根的子树中的关键字，那么
			k≤x.key1≤kz≤x.keyz≤.≤x. keyxn≤kzn+1
			4.每个叶结点具有相同的深度，即树的高度h。
			5.每个结点所包含的关键字个数有上界和下界。用一个被称为B树的最小度数(minmum degree)的固定整数t≥2来表示这些界
				a.除了根结点以外的每个结点必须至少有t-1个关键字。
				因此，除了根结点以外的每个内部结点至少有t个孩子。如果树非空，根结点至少有一个关键字。
				b.每个结点至多可包含2t-1个关键字。
				因此，一个内部结点至多可有2t个孩子。当一个结点恰好有2t-1个关键字时，称该结点是满的(full)。
				t=2时的B树是最简单的。每个内部结点有2个、3个或4个孩子，即一棵2-3-4树。
				然而在实际中，t的值越大，B树的高度就越小。
			./imgs/字母B树.png
		B树的高度:
			B树上大部分的操作所需的磁盘存取次数与B树的高度是成正比的。
			现在来分析B树最坏情况下的高度:
			
			定理18.1如果n≥1，那么对任意一棵包含n个关键字、高度为h、最小度数t≥2的B树T,有 h<=logt (n+1)/2
			证明p280
				./imgs/B树高度证明.png
			与红黑树对比，这里我们看到了B树的能力。尽管二者的高度都以O(lgn)的速度增长(注意t是个常数)，但对B树来说，对数的底可以大很多倍。因此，对大多数树的操作来说，要检查的结点数在B树中要比在红黑树中少大约lgt的因子。由于在- -棵树中检查任意-一个结点都需要--次磁盘访问，所以B树避免了大量的磁盘访问。

		...

B+树：
	一个常见的B树变种，称为B+树(B+tree)，它把所有的卫星数据都存储在叶结点中，内部结点只存放关键字和孩子指针，因此最大化了内部结点的分支因子。
	！
		关键字所对应的指针，应该是有放在节点上吧。
		应该是的，实际上，人们可能只是为每个关键字存放-一个指针，这个指针指向存放该关键字的卫星数据的磁盘页。

