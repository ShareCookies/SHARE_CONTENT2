二叉搜索树（搜索树数据结构）：
	附：
		二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。
			对于有n个结点的一棵完全二叉树来说，这些操作的最坏运行时间为O(lgn)。
			然而，如果这棵树是一条n个结点组成的线性链，那么同样的操作就要花费O(n)的最坏运行时间。
		实际上，我们并不能总是保证随机地构造二叉搜索树，然而可以设计二叉搜索树的变体，来保证基本操作具有好的最坏情况性能。
			第13章给出了一个这样的变形，即红黑树，它的树高为O(lgn)。
			第18章将介绍B树，它特别适用于二级(磁盘)存储器上的数据库维护。
	什么是二叉搜索树:
		介绍：
			符合二叉搜索树性质的二叉树就是二叉搜索树。
			二叉搜索树性质：(二叉搜索树关键字性质)
				对任何结点x,其左子树中的关键字最大不超过x.key,其右子树中的关键字最小不低于x. key。

					即节点x的左边都比它小，右边都比它大。
				附：
					不同的二叉搜索树可以代表同一组值的集合。
					大部分搜索树操作的最坏运行时间与树的高度成正比。					
				附:
				二叉树的性质
					节点元素：
						除了key和卫星数据之外，每个结点还包含属性left、right 和p，它们分别指向结点的左孩子、右孩子和双亲。
					根结点：
						如果某个孩子结点和父结点不存在，则相应属性的值为NIL.根结点是树中唯一-父指针为NIL的结点。
					即：
						节点元素有left、right和parent 3属性。
				
			例：
				./imgs/二叉搜索树.png
				不同的二叉搜索树可以代表同一组值的集合：
					(a)一棵包含6个结点、高度为2的二叉搜索树。
					(b)一 棵包含相同关键字、高度为4的低效二叉搜索树。

		二叉搜索树遍历：（二叉树的遍历）
			介绍：
				二叉搜索树性质允许我们通过一个简单的递归算法来按序输出二叉搜索树中的所有关键字，这种算法称为中序遍历(inordertreewalk)算法。
				这样命名的原因是输出的子树根的关键字位于其左子树的关键字值和右子树的关键字值之间。
			附：
				(类似地，先序遍历(preorder tree walk)中输出的根的关键字在其左右子树的关键字值之前，
				而后序遍历( postorder tree walk)输出的根的关键字在其左右子树的关键字值之后。)
			例：
				调用下面的函数，就可以输出一棵二叉搜索树T中的所有元素。
				
				//一直先不断的递归到左子树最左叶节点，然后输出叶节点值。// 输出最左节点值 // 输出最左节点右节点
				// 接着到最左前个节点，继续上一步骤思路
				// 如此一直不断的遍历完
				
				INORDER-TREE-WALK(x)
				if x!=null
					INORDER-TREE-WALK(x.left)
					print x.key
					INORDER-TREE-WALK(x.right)
				
				对于图12-1中的两棵二叉搜索树，中序遍历输出的关键字次序均为2, 5,5，6, 7，8。
				附：递归过程：先走到其极限条件（终止条件），然后在回到极限前一步往下走。
					例：2节点无法往下走，回到2节点继续，打印2，接着右节点无法往下。
					回到5节点，打印5，接着5右叶子节点。
					5左，打印5节点，5右
			遍历一棵有n个结点的二叉搜索树需要耗时O(n)证明：
				p162
		二叉搜索树操作：
			一棵高度为h的二叉搜索树，它的动态集合操作时间复杂度均为O(h)。
			？因为搜索时间等为O(h)所以称其为二叉搜索树吗
			二叉搜索树查询操作：
				二叉搜索树还能支持SEARCH、MINIMUM、MAXIMUM、SUCCESSOR和PREDECESSOR等查询操作。
				...p163
				查找：
					我们使用下面的过程在一棵二叉搜索树中查找一个具有给定关键字的结点。
					输人一个指向树根的指针和一个关键字k,如果这个结点存在，TREE-SEARCH返回一个指向关键字为k的结点的指针;否则返回NIL.
						TREE-SEARCH(x,k)
							ifx== NIILork == x. key .
								return x;
							ifk< x. key
								return TREE SEARCH(x,left,k)
							else return TREE SEARCH(x. right,k)
						从树根开始递归期间遇到的结点就形成了一条向下的简单路径，所以TREE SEARCH的运行时间为O(h)，其中h是这棵树的高度。
				
				最大关键字元素和最小关键字元素：
					最小关键字元素：
						通过从树根开始沿着left 孩子指针直到遇到一个NIL,我们总能在一棵二叉搜索树中找到一个最小元素。
						如果结点工没有左子树，那么由于x右子树中的每个关键字都至少大于或等于x.key， 则以x为根的子树中的最小关键字是x. key。

						TREE- MINIMUM(x)
							while x.left≠NIL
								x = x.left
							return x
					最大关键字元素
						TREE-MAXIMUM(x)
						while x.right≠NIL
							x= x.right
						return x
					时间维度（耗时）：
						这两个过程在一棵高度为h的树上均能在O(h)时间内执行完，因为与TREE- SEARCH一样，它们所遇到的结点均形成了一条从树根向下的简单路径。
				后继和前驱：
					后继：
						介绍：
							如果所有的关键字互不相同，则一个结点x的后继是大于x.key的最小关键字的结点。
							如果x是这棵树中的最大关键字，则返回NIL.
								hcg：就是大于它的最小一个节点。
						例：
						TREE SUCCESSOR(x)
							if x.right≠NIL
								return TREE-MINIMUM(x. right)
							y=x.p
							while y≠NIL and x == y. right //双亲节点不为空 且 节点为双亲节点的右节点
								x=y
								y= y.p
							return y


						把TREE-SUCCESSOR的伪代码分为两种情况。
							1.如果结点x的右子树非空，那么x的后继恰是x右子树中的最左结点，通过第2行中的TREE MINIMUM(x. right)调用可以找到。
							2.？
								如果结点x的右子树非空并有一一个后继y,那么y就是x的有左孩子的最底层祖先，并且它也是x的一个祖先。
								为了找到y,只需简单地从x开始沿树而上直到遇到一个其双亲有左孩子的结点。TREE-SUCCESSOR中的第3~7行正是处理这种情况。
								在图12-2中，关键字为13的结点的后继是关键字为15的结点。
								
								总结：
								即：
									右子树空的话，那么后继为其最底层左双亲节点
									（一直往上双亲节点不为空 且 节点为双亲节点的左节点，第一个父节点）
								hcg：
									右节点空

									1是双亲的左节点
										符合规则后继就是双亲
									2是双亲的右节点
										那么双亲比他小，再看双亲双亲节点。
										当双为双双的左节点，那么双双就是找到的最小的比我大的节点，
										那么双双就是后继。
			插入和删除：
				插入删除时要注意保持二叉搜索树性质的成立。
				插入：
					例：插入z节点
					TREE-INSERT(T,z)
						zParent = NIL
						x= T.root 
						while x≠NIL //找到z的父节点（）
							zParent=x //这里要为深克隆
							if z.key<x.key
								x = x.left
							else x =x. right ;
						z.p=zParent
						// z插入树中
						if y== NIL
							T.root = z // tree T was empty
						else if z.key< zParent.key 
							zParent.left= z
						else zParent.right= z
					1.正如过程TREE SEARCH和ITERATIVE-TREE-SEARCH一样，
					TREE-INSERT从树根开始，指针x记录了一条向下的简单路径，并查找要替换的输入项z的NIL。
					2.与其他搜索树.上的原始操作一样，过程TREE-INSERT在一棵高度为h的树上的运行时间为O(h)。

				删除：
					...p166
					思路：
						从一棵二叉搜索树T中删除一个结点z的整个策略分为三种基本情况，但只有一种情况有点棘手。
						1.如果z没有孩子结点，那么只是简单地将它删除，并修改它的父结点，用NIL作为孩子来替换z。
						2.如果z只有一个孩子，那么将这个孩子提升到树中z的位置上，并修改z的父结点，用z的孩子来替换z。
						3.如果z有两个孩子，那么找z的后继y(一定在z的右子树中)，并让y占据树中z的位置。z的原来右子树部分成为y的新的右子树，并且z的左子树成为y的新的左子树。这种情况稍显麻烦(如下所述)，因为还与y是否为z的右孩子相关。
							z既有一个左孩子又有一个右孩子。我们要查找z的后继y，将y移出原来的位置进行拼接，并替换树中的z。此处又分为两种情况，y为右孩子和不是右孩子：
									注：后继y位于z的右子树中并且没有左孩子(见练习12. 2-5)。
									？12.2-5证明:如果一棵二叉搜索树中的一个结点有两个孩子，那么它的后继没有左孩子，它的前驱没有右孩子。
								1.如果y是z的右孩子(图12-4(c))，那么用y替换z，并仅留下y的右孩子。
								2.y位于z的右子树中但并不是z的右孩子(图12-4(d))。在这种情况下，先用y的右孩子替换y，然后再用y替换z。
					例：
					// RANSPLANT类似红黑树的那个TRANSPLANT
					// TREE-DELETE过程处理4种情况如下。
					TREE-DELETE(T,z)
						if z.left == NIL //第1~2行处理结点z没有左孩子的情况。
							TRANSPLANT(T,z,z. right) // 把z节点和z右孩子进行树转移
						else if z. right == NIL //第3~4行处理z有一个左孩子但没有右孩子情况。
							TRANSPLANT(T,z,z. left) // 把z节点和z左孩子进行树转移
						else // 第5~12行处理剩下的两种情况，也就是z有两个孩子的情形。
							y = TREE-MINIMUM(z. right) // 第5行查找结点y,它是z的后继。因为z的右子树非空，这样后继一定是这个子树中具有最小关键字的结点，因此就调用TREE-MINIMUM(z. right)。

							// 附：如前所述，y没有左孩子。！将y移出它的原来位置进行拼接，并替换树中的z即可。
							if y.p≠z 
								TRANSPLANT(T,y,y. right) //7-9如果y不是z的左孩子，第7~9行用y的右孩子替换y并成为y的双亲的-一个孩子，然后将z的右孩子转变为y的右孩子，最后第10~12行用y替换z并成为z的双亲的一个孩子，再用z的左孩子替换为y的左孩子。
								y.right = z. right
								y.right.p= y
							TRANSPLANT(T,z,y) //10-12 如果y是z的右孩子，那么第10~12行用y替换z并成为z的双亲的一个孩子，用z的左孩子替换y的左孩子。
							y.left = z.left
							y.left.p=y
					耗时:
						除了第5行调用TREE-MINIMUM之外，TREE-DELETE的每一行，包括调用
					TRANSPLANT,都只花费常数时间。因此，在- -棵高度为h的树上，TREE DELETE的运行时
					间为O(h)。